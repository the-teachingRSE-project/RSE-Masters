[
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "",
    "text": "References"
  },
  {
    "objectID": "generation/generated/rse_thesis.html",
    "href": "generation/generated/rse_thesis.html",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "",
    "text": "The master’s thesis is the culminating component of the RSE programme. In this module, students apply the full spectrum of Research Software Engineering skills in a real-world research setting, demonstrating their ability to independently design, implement, and document a computational research contribution.\nThe thesis must address a research question in collaboration with a scientific or applied domain, but its core should include a substantial computational component. This may involve software development, data-intensive research, reproducibility infrastructure, or performance engineering — depending on the chosen topic and specialization.\nEach thesis must be supervised jointly by:\n\nA domain expert (e.g., in physics, life sciences, or humanities)\nAn RSE mentor (who ensures the quality and relevance of the computational contribution)\n\nStudents are expected to follow best practices in software engineering, version control, testing, and documentation. The final submission must include:\n\nA written thesis describing both the scientific and software contributions\nA structured, reproducible code repository\nA presentation and defense in a thesis colloquium\n\nThe colloquium serves as both a public communication exercise and a final evaluation, where students present their project and reflect on challenges and insights gained during the thesis.\nThesis: RSE Master Thesis\nSWS: 10 ECTS: 30"
  },
  {
    "objectID": "generation/generated/rse_thesis.html#masters-thesis-module-research-software-engineering-thesis",
    "href": "generation/generated/rse_thesis.html#masters-thesis-module-research-software-engineering-thesis",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "",
    "text": "The master’s thesis is the culminating component of the RSE programme. In this module, students apply the full spectrum of Research Software Engineering skills in a real-world research setting, demonstrating their ability to independently design, implement, and document a computational research contribution.\nThe thesis must address a research question in collaboration with a scientific or applied domain, but its core should include a substantial computational component. This may involve software development, data-intensive research, reproducibility infrastructure, or performance engineering — depending on the chosen topic and specialization.\nEach thesis must be supervised jointly by:\n\nA domain expert (e.g., in physics, life sciences, or humanities)\nAn RSE mentor (who ensures the quality and relevance of the computational contribution)\n\nStudents are expected to follow best practices in software engineering, version control, testing, and documentation. The final submission must include:\n\nA written thesis describing both the scientific and software contributions\nA structured, reproducible code repository\nA presentation and defense in a thesis colloquium\n\nThe colloquium serves as both a public communication exercise and a final evaluation, where students present their project and reflect on challenges and insights gained during the thesis.\nThesis: RSE Master Thesis\nSWS: 10 ECTS: 30"
  },
  {
    "objectID": "generation/generated/rse_softwareengineering.html",
    "href": "generation/generated/rse_softwareengineering.html",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "",
    "text": "This module extends the Classical Software Engineering Module with research specific learnings. This includes but is not limited to\n\nsoftware re-use (see SRU in (Goth et al. 2024))\ncreating documented code building blocks (see DOCBB in (Goth et al. 2024))\nbuilding distributable software (see DIST in (Goth et al. 2024))\nresearch specific programming languages\nresearch specific code requirements (scalability, functional programming, …)\nAdapting the software life cycle to research (see SWLC in (Goth et al. 2024))\nSoftware behaviour awareness and analysis (see MOD in (Goth et al. 2024))\nResearch specific Engineering Patterns\n\nLecture: RSE Software Engineering This is an advanced class to … SWS: None ECTS: None"
  },
  {
    "objectID": "generation/generated/rse_softwareengineering.html#rse-software-engineering",
    "href": "generation/generated/rse_softwareengineering.html#rse-software-engineering",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "",
    "text": "This module extends the Classical Software Engineering Module with research specific learnings. This includes but is not limited to\n\nsoftware re-use (see SRU in (Goth et al. 2024))\ncreating documented code building blocks (see DOCBB in (Goth et al. 2024))\nbuilding distributable software (see DIST in (Goth et al. 2024))\nresearch specific programming languages\nresearch specific code requirements (scalability, functional programming, …)\nAdapting the software life cycle to research (see SWLC in (Goth et al. 2024))\nSoftware behaviour awareness and analysis (see MOD in (Goth et al. 2024))\nResearch specific Engineering Patterns\n\nLecture: RSE Software Engineering This is an advanced class to … SWS: None ECTS: None"
  },
  {
    "objectID": "generation/generated/rse_softwareengineering.html#module-competences",
    "href": "generation/generated/rse_softwareengineering.html#module-competences",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "Module Competences",
    "text": "Module Competences\n\n\n\nID\nDescription\nDisciplines\nPrerequisites\nEvidence\nAuthor\nSource\n\n\n\n\nrse_practices_1\nApply good coding practices including formatting, linting, and modular design\nResearch Software Engineering\nrse_tooling_2\nSubmit a code project demonstrating modularity, consistent formatting, and use of linters\nRSE Curriculum Draft\nLink\n\n\nrse_practices_2\nWrite code and documentation that supports reproducibility in research\nResearch Software Engineering\nrse_tooling_1, rse_tooling_4\nSubmit a project with data, software, and instructions allowing full reproduction of results\nRSE Curriculum Draft\nLink\n\n\nrse_practices_3\nOrganise files and name code artifacts using clear, consistent conventions\nResearch Software Engineering\n\nSubmit a software repository with a structured layout and consistent naming scheme\nRSE Curriculum Draft\nLink\n\n\nrse_practices_4\nVersion control code and collaborate using platforms like GitHub or GitLab\nResearch Software Engineering\nrse_tooling_12\nParticipate in a collaborative coding project using Git-based workflows and merge requests\nRSE Curriculum Draft\nLink\n\n\nrse_practices_5\nWrite effective documentation and user-facing error messages\nResearch Software Engineering\nrse_tooling_8\nProvide documentation and example error handling demonstrating clarity and user support\nRSE Curriculum Draft\nLink\n\n\nrse_practices_12\nWrite performant code suitable for use in compute-intensive contexts\nResearch Software Engineering\nrse_tooling_2\nSubmit benchmark results comparing an optimized version of code with a naive implementation\nRSE Curriculum Draft\nLink\n\n\nrse_practices_13\nPublish code and software in trusted repositories and package managers\nResearch Software Engineering\nrse_practices_6\nPublish software to a repository (e.g., GitHub, PyPI, CRAN) and register it with a long-term archive (e.g., Zenodo)\nRSE Curriculum Draft\nLink\n\n\nrse_practices_6\nApply licensing and publishing strategies to make software reusable and citable\nResearch Software Engineering\n\nSubmit a software project with an appropriate open license and published DOI (e.g., via Zenodo)\nRSE Curriculum Draft\nLink\n\n\nrse_practices_7\nApply principles of Open Source and FAIR (Findable, Accessible, Interoperable, Reusable) software\nResearch Software Engineering\nrse_practices_6\nReview or create a software project and evaluate its compliance with FAIR/Open Source principles\nRSE Curriculum Draft\nLink\n\n\nrse_practices_14\nManage data within a software project in accordance with best practices\nResearch Software Engineering, Data Management\n\nSubmit a data-driven project showing clear data organisation, metadata, and reproducibility\nRSE Curriculum Draft\nLink"
  },
  {
    "objectID": "generation/generated/rse_softwareengineering.html#sources-implementations",
    "href": "generation/generated/rse_softwareengineering.html#sources-implementations",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "Sources & Implementations:",
    "text": "Sources & Implementations:\n\nCourses\n\nTODO\n\n\n\nGoth, F, R Alves, M Braun, LJ Castro, G Chourdakis, S Christ, J Cohen, et al. 2024. “Foundational Competencies and Responsibilities of a Research Software Engineer [Version 1; Peer Review: Awaiting Peer Review].” F1000Research 13 (1429). https://doi.org/10.12688/f1000research.157778.1."
  },
  {
    "objectID": "generation/generated/rse_management.html",
    "href": "generation/generated/rse_management.html",
    "title": "RSE Management and Communication",
    "section": "",
    "text": "This module comprises the communication and management skills that are relevant for working in the interdisciplinary setting of RSE-professionals.\nThis includes but is not limited to:\n\nworking in a team (see TEAM in (Goth et al. 2024))\nteaching RSE-basics (see TEACH in (Goth et al. 2024))\nproject management (see PM in (Goth et al. 2024))\ninteraction with users and other stakeholders (see USERS in (Goth et al. 2024))\n\n\n\n\n\nresearch management\n\nresearch cycle\nopen science, FAIR, FAIR4RS\npublication workflow: obstacles and embargoes\nlegal aspects of research data, e.g. GDPR\npseudonymization/anonymization methods for data privacy\npublic databases\n\nquality control\n\nrequirements engineering\ntrying goals with quality: test-driven development\nbehavior-driven development, Gherkin-Style acceptance testing\nproject folder organization\ncode review principles\n\ncommunication and collaboration\n\ncommunication frameworks, e.g. AIDA, RACE, 7 C’s\npersonality traits and their impact on cooperation\ncollaboration frameworks for remote work\nrealisation and benefits of pair programming and mob/ensemble programming\ntechnical English writing skills: writing in issues and merge requests, code review…\nconflict management, e.g. dealing with researchers that do not listen\nhow to address relevant stakeholders (i.e. users and SEs) with different background knowledge, experience and expectations\nequity, diversity and inclusion principles\n\nteam management\n\nchallenges of transient teams (that only exist for 5-15 hours)\neffects of varying team sizes\nmanagement depending on project size/type\nspecialised roles in a software team\nintercultural and interdisciplinary differences\nteam management methodologies\nimportance of shared values in a RSE team\ndual goals: project vs. personal goal\n\ntime and project management\n\ngoal-setting\nproject management methods, their strengths and weaknesses\nagile (not necessarily Scrum)\nLean & Kanban (Small-Batch Philosophies)\ndivision of tasks into sub-tasks and task-dependencies\niterative workflows\ncontinuous delivery\ncommunication with a manager/supervisor\n\n\nLecture: RSE-Management Lecture This is an introductory lecture covering research, project and team management techniques an RSE needs in everyday life. SWS: 2 ECTS: 3\nExercise: RSE-Management Exercise This is an exercise to apply and practice the taught methods with case-studys, role-plays etc. SWS: 2 ECTS: 3\n\n\n\n\n\n\nID\nDescription\nDisciplines\nPrerequisites\nEvidence\nAuthor\nSource\n\n\n\n\nrse_practices_8\nBuild and manage sustainable research software communities\nResearch Software Engineering, Community Engagement\nrse_tooling_13\nDocument strategies used for user engagement, feedback, and community growth in a real project\nRSE Curriculum Draft\nLink\n\n\nrse_practices_9\nWork in an agile software development process, including requirement gathering and iteration\nResearch Software Engineering\n\nSubmit a project that uses agile planning (e.g., user stories, sprints, stand-ups) and reflects on iteration outcomes\nRSE Curriculum Draft\nLink\n\n\nrse_practices_10\nDefine project scope, gather requirements, and manage stakeholder expectations\nResearch Software Engineering\n\nProvide a requirements document and stakeholder communication log for a software project\nRSE Curriculum Draft\nLink\n\n\nrse_practices_11\nPlan for software maintenance and long-term sustainability, including archiving strategies\nResearch Software Engineering\nrse_practices_6\nSubmit a sustainability or exit plan describing how the software will be maintained or archived\nRSE Curriculum Draft\nLink\n\n\nrse_management_01\nExplain particular implementation choices in a convincing manner\nResearch Software Engineering\n\nDeliver a defense of chosen implementation decisions in a discussion with a domain expert who has limited technical knowledge (ideally oral examination or project presentation with potential ‘customer/user’ questions)\nRSE Community\nLink\n\n\nrse_management_02\nExemplify and articulate shared team values and their impact on work\nResearch Software Engineering\n\nIdentify core team values and demonstrate how they influence key implementation decisions (e.g., design, communication, and collaboration)\nRSE Community\nLink\n\n\nrse_management_03\nPlan and manage projects using standard methods effectively and efficiently\nResearch Software Engineering\n\nDevelop a comprehensive project plan for a given project, including scope, milestones, risks, resources, and success criteria\nRSE Community\nLink\n\n\nrse_management_04\nDiscuss methods to set up a Diversity, Equity and Inclusion (DEI) framework in an RSE team\nResearch Software Engineering\n\nAnalyse and evaluate a DEI framework for a given project\nRSE Community\nLink\n\n\n\n\n\n\n\n\n\nRSE Leadership Course\n\n\n\n\n\nRemote Mob Programming\nCode with the Wisdom of the Crowd\nCollaboration Explained\nTeam Topologies\nTechnical Agile Coaching with the Samman method\nLean Product and Process Development\nExtreme Programming Explained\n\n\n\nGoth, F, R Alves, M Braun, LJ Castro, G Chourdakis, S Christ, J Cohen, et al. 2024. “Foundational Competencies and Responsibilities of a Research Software Engineer [Version 1; Peer Review: Awaiting Peer Review].” F1000Research 13 (1429). https://doi.org/10.12688/f1000research.157778.1."
  },
  {
    "objectID": "generation/generated/rse_management.html#introduction",
    "href": "generation/generated/rse_management.html#introduction",
    "title": "RSE Management and Communication",
    "section": "",
    "text": "This module comprises the communication and management skills that are relevant for working in the interdisciplinary setting of RSE-professionals.\nThis includes but is not limited to:\n\nworking in a team (see TEAM in (Goth et al. 2024))\nteaching RSE-basics (see TEACH in (Goth et al. 2024))\nproject management (see PM in (Goth et al. 2024))\ninteraction with users and other stakeholders (see USERS in (Goth et al. 2024))"
  },
  {
    "objectID": "generation/generated/rse_management.html#contents",
    "href": "generation/generated/rse_management.html#contents",
    "title": "RSE Management and Communication",
    "section": "",
    "text": "research management\n\nresearch cycle\nopen science, FAIR, FAIR4RS\npublication workflow: obstacles and embargoes\nlegal aspects of research data, e.g. GDPR\npseudonymization/anonymization methods for data privacy\npublic databases\n\nquality control\n\nrequirements engineering\ntrying goals with quality: test-driven development\nbehavior-driven development, Gherkin-Style acceptance testing\nproject folder organization\ncode review principles\n\ncommunication and collaboration\n\ncommunication frameworks, e.g. AIDA, RACE, 7 C’s\npersonality traits and their impact on cooperation\ncollaboration frameworks for remote work\nrealisation and benefits of pair programming and mob/ensemble programming\ntechnical English writing skills: writing in issues and merge requests, code review…\nconflict management, e.g. dealing with researchers that do not listen\nhow to address relevant stakeholders (i.e. users and SEs) with different background knowledge, experience and expectations\nequity, diversity and inclusion principles\n\nteam management\n\nchallenges of transient teams (that only exist for 5-15 hours)\neffects of varying team sizes\nmanagement depending on project size/type\nspecialised roles in a software team\nintercultural and interdisciplinary differences\nteam management methodologies\nimportance of shared values in a RSE team\ndual goals: project vs. personal goal\n\ntime and project management\n\ngoal-setting\nproject management methods, their strengths and weaknesses\nagile (not necessarily Scrum)\nLean & Kanban (Small-Batch Philosophies)\ndivision of tasks into sub-tasks and task-dependencies\niterative workflows\ncontinuous delivery\ncommunication with a manager/supervisor\n\n\nLecture: RSE-Management Lecture This is an introductory lecture covering research, project and team management techniques an RSE needs in everyday life. SWS: 2 ECTS: 3\nExercise: RSE-Management Exercise This is an exercise to apply and practice the taught methods with case-studys, role-plays etc. SWS: 2 ECTS: 3"
  },
  {
    "objectID": "generation/generated/rse_management.html#module-competences",
    "href": "generation/generated/rse_management.html#module-competences",
    "title": "RSE Management and Communication",
    "section": "",
    "text": "ID\nDescription\nDisciplines\nPrerequisites\nEvidence\nAuthor\nSource\n\n\n\n\nrse_practices_8\nBuild and manage sustainable research software communities\nResearch Software Engineering, Community Engagement\nrse_tooling_13\nDocument strategies used for user engagement, feedback, and community growth in a real project\nRSE Curriculum Draft\nLink\n\n\nrse_practices_9\nWork in an agile software development process, including requirement gathering and iteration\nResearch Software Engineering\n\nSubmit a project that uses agile planning (e.g., user stories, sprints, stand-ups) and reflects on iteration outcomes\nRSE Curriculum Draft\nLink\n\n\nrse_practices_10\nDefine project scope, gather requirements, and manage stakeholder expectations\nResearch Software Engineering\n\nProvide a requirements document and stakeholder communication log for a software project\nRSE Curriculum Draft\nLink\n\n\nrse_practices_11\nPlan for software maintenance and long-term sustainability, including archiving strategies\nResearch Software Engineering\nrse_practices_6\nSubmit a sustainability or exit plan describing how the software will be maintained or archived\nRSE Curriculum Draft\nLink\n\n\nrse_management_01\nExplain particular implementation choices in a convincing manner\nResearch Software Engineering\n\nDeliver a defense of chosen implementation decisions in a discussion with a domain expert who has limited technical knowledge (ideally oral examination or project presentation with potential ‘customer/user’ questions)\nRSE Community\nLink\n\n\nrse_management_02\nExemplify and articulate shared team values and their impact on work\nResearch Software Engineering\n\nIdentify core team values and demonstrate how they influence key implementation decisions (e.g., design, communication, and collaboration)\nRSE Community\nLink\n\n\nrse_management_03\nPlan and manage projects using standard methods effectively and efficiently\nResearch Software Engineering\n\nDevelop a comprehensive project plan for a given project, including scope, milestones, risks, resources, and success criteria\nRSE Community\nLink\n\n\nrse_management_04\nDiscuss methods to set up a Diversity, Equity and Inclusion (DEI) framework in an RSE team\nResearch Software Engineering\n\nAnalyse and evaluate a DEI framework for a given project\nRSE Community\nLink"
  },
  {
    "objectID": "generation/generated/rse_management.html#sources-implementations",
    "href": "generation/generated/rse_management.html#sources-implementations",
    "title": "RSE Management and Communication",
    "section": "",
    "text": "RSE Leadership Course\n\n\n\n\n\nRemote Mob Programming\nCode with the Wisdom of the Crowd\nCollaboration Explained\nTeam Topologies\nTechnical Agile Coaching with the Samman method\nLean Product and Process Development\nExtreme Programming Explained\n\n\n\nGoth, F, R Alves, M Braun, LJ Castro, G Chourdakis, S Christ, J Cohen, et al. 2024. “Foundational Competencies and Responsibilities of a Research Software Engineer [Version 1; Peer Review: Awaiting Peer Review].” F1000Research 13 (1429). https://doi.org/10.12688/f1000research.157778.1."
  },
  {
    "objectID": "generation/generated/mnt_wildcard.html",
    "href": "generation/generated/mnt_wildcard.html",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "",
    "text": "This module offers RSE students the opportunity to deepen their understanding of a scientific discipline outside of their home domain. Students choose a science module — such as physics, chemistry, biology, or earth sciences — and engage with its research practices, core questions, and data/software challenges.\nThe goal is to help students become better collaborators by gaining first-hand exposure to the terminology, logic, and needs of another scientific domain. This broadens the student’s ability to apply RSE skills in interdisciplinary teams and unfamiliar environments.\nThe module may consist of lectures, lab sessions, and domain-specific mini-projects. RSEs are encouraged to reflect on how software engineering, data handling, reproducibility, and tooling intersect with the chosen discipline.\nThis module is deliberately flexible to accommodate institutional offerings and student interests as well as providing the option to stay attached to the identity of the chosen discipline.\nLecture: Wildcard Science I\nSWS: 2 ECTS: 3\nLecture: Wildcard Science II\nSWS: 2 ECTS: 3\nLab: Wildcard Science Lab I\nSWS: 4 ECTS: 6\nLab: Wildcard Science Lab II\nSWS: 2 ECTS: 2"
  },
  {
    "objectID": "generation/generated/mnt_wildcard.html#wildcard-science-module",
    "href": "generation/generated/mnt_wildcard.html#wildcard-science-module",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "",
    "text": "This module offers RSE students the opportunity to deepen their understanding of a scientific discipline outside of their home domain. Students choose a science module — such as physics, chemistry, biology, or earth sciences — and engage with its research practices, core questions, and data/software challenges.\nThe goal is to help students become better collaborators by gaining first-hand exposure to the terminology, logic, and needs of another scientific domain. This broadens the student’s ability to apply RSE skills in interdisciplinary teams and unfamiliar environments.\nThe module may consist of lectures, lab sessions, and domain-specific mini-projects. RSEs are encouraged to reflect on how software engineering, data handling, reproducibility, and tooling intersect with the chosen discipline.\nThis module is deliberately flexible to accommodate institutional offerings and student interests as well as providing the option to stay attached to the identity of the chosen discipline.\nLecture: Wildcard Science I\nSWS: 2 ECTS: 3\nLecture: Wildcard Science II\nSWS: 2 ECTS: 3\nLab: Wildcard Science Lab I\nSWS: 4 ECTS: 6\nLab: Wildcard Science Lab II\nSWS: 2 ECTS: 2"
  },
  {
    "objectID": "generation/generated/mnt_compwildcard.html",
    "href": "generation/generated/mnt_compwildcard.html",
    "title": "Wildcard Computational Science",
    "section": "",
    "text": "Wildcard Computational Science\nThis module offers RSE students the opportunity to deepen their understanding of computational methods specific to a science discipline. Students choose a science module — such as physics, chemistry, biology, or earth sciences — and engage with its computational practices, core questions, and data/software challenges.\nThe goal is to apply the general competences acquired in the general programming and software engineering courses to the practices and special needs of the chosen discipline. Computational Physics might face different algorithmic or conceptual challenges than computational chemistry. This module is intended for the case that the institution offers such a specialized computational course.\nLecture: Computational Wildcard Science\nSWS: 2 ECTS: 3\nLab: Wildcard Science Lab\nSWS: 4 ECTS: 6"
  },
  {
    "objectID": "generation/generated/gen_programming.html",
    "href": "generation/generated/gen_programming.html",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "",
    "text": "This is an example module to showcase the integration pipeline\n\n\n\n\n\nIntroduction to computer science, basic concepts of operating systems using UNIX/Linux as an example\nFrom problem to algorithm: concept of an algorithm, design of algorithms, pseudocode, refinement, brute-force algorithms, models and modeling, graphs and their representation, simple algorithms on graphs, analysis of algorithms (correctness, termination, runtime)\nImplementation of algorithms (e.g., using Python)\nProgramming paradigms: procedural, object-oriented, and functional programming; recursion versus iteration\nFrom program to process: assembly languages, assembler, compiler, interpreter, syntax and semantics of programming languages\nLimits of algorithms: computability, decidability, undecidability\n\nLecture: Basic Programming\nSWS: 2 ECTS: 1\nExercise: Basic Programming Exercise\nSWS: 4 ECTS: 4\n\n\n\n\n\n\nProgramming with an imperative-procedural language (such as C):\n\nData types, type casting, control structures, functions and procedures, parameter passing paradigms, call stack\nPointers, arrays, strings, structured types\nErrors and their handling\nDynamic memory management\nProgram libraries\n\n\n\n\n\nClasses, objects, constructors\nInheritance, polymorphism, abstract classes/interfaces\nExceptions and exception handling\nNamespaces (packages)\nGeneric classes and types\nProgram libraries\n\nLecture: Applied Programming\nSWS: 2 ECTS: 1\nExercise: Applied Programming Exercise\nSWS: 4 ECTS: 4"
  },
  {
    "objectID": "generation/generated/gen_programming.html#example-module-fundamentals-of-computer-science",
    "href": "generation/generated/gen_programming.html#example-module-fundamentals-of-computer-science",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "",
    "text": "This is an example module to showcase the integration pipeline\n\n\n\n\n\nIntroduction to computer science, basic concepts of operating systems using UNIX/Linux as an example\nFrom problem to algorithm: concept of an algorithm, design of algorithms, pseudocode, refinement, brute-force algorithms, models and modeling, graphs and their representation, simple algorithms on graphs, analysis of algorithms (correctness, termination, runtime)\nImplementation of algorithms (e.g., using Python)\nProgramming paradigms: procedural, object-oriented, and functional programming; recursion versus iteration\nFrom program to process: assembly languages, assembler, compiler, interpreter, syntax and semantics of programming languages\nLimits of algorithms: computability, decidability, undecidability\n\nLecture: Basic Programming\nSWS: 2 ECTS: 1\nExercise: Basic Programming Exercise\nSWS: 4 ECTS: 4\n\n\n\n\n\n\nProgramming with an imperative-procedural language (such as C):\n\nData types, type casting, control structures, functions and procedures, parameter passing paradigms, call stack\nPointers, arrays, strings, structured types\nErrors and their handling\nDynamic memory management\nProgram libraries\n\n\n\n\n\nClasses, objects, constructors\nInheritance, polymorphism, abstract classes/interfaces\nExceptions and exception handling\nNamespaces (packages)\nGeneric classes and types\nProgram libraries\n\nLecture: Applied Programming\nSWS: 2 ECTS: 1\nExercise: Applied Programming Exercise\nSWS: 4 ECTS: 4"
  },
  {
    "objectID": "generation/generated/gen_programming.html#module-competences",
    "href": "generation/generated/gen_programming.html#module-competences",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "Module Competences",
    "text": "Module Competences\n\n\n\nID\nDescription\nDisciplines\nPrerequisites\nEvidence\nAuthor\nSource\n\n\n\n\nex_programming_mod1_1\nUse an imperative-procedural programming language (e.g., C) and an object-oriented language (e.g., Java) with confidence\nComputer Science\n\nSubmit working programs in both languages demonstrating syntax and language-specific features\nUniversity of Potsdam\nLink\n\n\nex_programming_mod1_2\nImplement basic data structures and algorithms\nComputer Science\nex_programming_mod1_1\nSubmit a project with implemented algorithms and data structures (e.g., lists, trees, sorting)\nUniversity of Potsdam\nLink\n\n\nex_programming_mod1_3\nDistinguish between error types and handle them appropriately in code\nComputer Science\nex_programming_mod1_1\nDemonstrate error handling techniques in submitted code (e.g., input validation, error codes, exceptions)\nUniversity of Potsdam\nLink\n\n\nex_programming_mod1_4\nIdentify and use appropriate library functions in programming tasks\nComputer Science\nex_programming_mod1_1\nIntegrate external libraries in coding tasks and document their usage\nUniversity of Potsdam\nLink\n\n\nex_programming_mod1_5\nUse basic functions and mechanisms of operating systems using UNIX/Linux as an example\nComputer Science\n\nDemonstrate file handling, permissions, and process control using UNIX/Linux commands\nUniversity of Potsdam\nLink\n\n\nex_programming_mod1_6\nCreate and refine simple algorithms using semi-formal notation\nComputer Science\n\nSubmit pseudocode or flowcharts for given algorithmic problems\nUniversity of Potsdam\nLink\n\n\nex_programming_mod1_7\nEvaluate and compare algorithms using runtime analysis\nComputer Science\nex_programming_mod1_6\nProvide time complexity comparisons for multiple algorithmic solutions\nUniversity of Potsdam\nLink\n\n\nex_programming_mod1_8\nImplement simple algorithms using imperative and functional programming styles (e.g., in Python)\nComputer Science\nex_programming_mod1_6\nSubmit code demonstrating both imperative and functional styles for the same problem\nUniversity of Potsdam\nLink\n\n\nex_programming_mod1_9\nDistinguish between programming paradigms and identify their characteristics\nComputer Science\nex_programming_mod1_1\nClassify given code snippets by paradigm and justify the classification\nUniversity of Potsdam\nLink\n\n\nC10\nExpress simple programs in an assembly language\nComputer Science\n\nTranslate simple high-level logic into assembler code\nUniversity of Potsdam\nLink\n\n\nC11\nDiscuss the limits of algorithms, including computability and decidability\nComputer Science\n\nWrite a short essay or present on concepts such as the Halting Problem or undecidability\nUniversity of Potsdam\nLink"
  },
  {
    "objectID": "generation/generated/gen_programming.html#sources-implementations",
    "href": "generation/generated/gen_programming.html#sources-implementations",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "Sources & Implementations:",
    "text": "Sources & Implementations:\n\nCurricula\n\nComputing Curricula 2020\n\n\n\nCourses\n\nUP Grundlagen der Programmierung\nUP Praxis der Programmierung\nPython for Psychologists\nGrundlagen der Informatik\n\n\n\nPrograms\n\nUP Computational Science Master"
  },
  {
    "objectID": "generation/generated/curriculum.html",
    "href": "generation/generated/curriculum.html",
    "title": "General Study Process",
    "section": "",
    "text": "Type\nDescription\nSWS\nECTS\n\n\n\n\nSeminar\nRSE Nuts and Bolts I\n2\n3\n\n\nLecture\nWildcard Science I\n2\n3\n\n\nLecture\nBasic Programming\n2\n1\n\n\nExercise\nBasic Programming Exercise\n4\n4\n\n\nLecture\nMathematical Foundations of Data Science\n4\n6\n\n\nLecture\nRSE-Management Lecture\n2\n3\n\n\nExercise\nRSE-Management Exercise\n2\n3\n\n\n\nTotal ECTS: 23\n\n\n\n\n\n\nType\nDescription\nSWS\nECTS\n\n\n\n\nLecture\nApplied Programming\n2\n1\n\n\nExercise\nApplied Programming Exercise\n4\n4\n\n\nLecture\nWildcard Science II\n2\n3\n\n\nLab\nWildcard Science Lab I\n4\n6\n\n\nLecture\nStatistical Data Analysis\n4\n4\n\n\nLecture\nScientific Computing Basics\n2\n3\n\n\nExercise\nScientific Computing Basics Exercise\n2\n3\n\n\n\nTotal ECTS: 24\n\n\n\n\n\n\nType\nDescription\nSWS\nECTS\n\n\n\n\nSeminar\nRSE Nuts and Bolts II\n2\n3\n\n\nLab\nWildcard Science Lab II\n2\n2\n\n\nExercise\nText2Data\n4\n4\n\n\nLecture\nComputational Wildcard Science\n2\n3\n\n\nLecture\nSoftware Engineering I\n2\n4\n\n\nExercise\nSoftware Engineering I Exercise\n2\n2\n\n\nLecture\nHigh Performance Computing\n2\n3\n\n\nExercise\nHigh Performance Computing Exercise\n2\n3\n\n\n\nTotal ECTS: 24\n\n\n\n\n\n\nType\nDescription\nSWS\nECTS\n\n\n\n\nThesis\nRSE Master Thesis\n10\n30\n\n\n\nTotal ECTS: 30\nTotal Curriculum ECTS: 101"
  },
  {
    "objectID": "generation/generated/curriculum.html#semester-1",
    "href": "generation/generated/curriculum.html#semester-1",
    "title": "General Study Process",
    "section": "",
    "text": "Type\nDescription\nSWS\nECTS\n\n\n\n\nSeminar\nRSE Nuts and Bolts I\n2\n3\n\n\nLecture\nWildcard Science I\n2\n3\n\n\nLecture\nBasic Programming\n2\n1\n\n\nExercise\nBasic Programming Exercise\n4\n4\n\n\nLecture\nMathematical Foundations of Data Science\n4\n6\n\n\nLecture\nRSE-Management Lecture\n2\n3\n\n\nExercise\nRSE-Management Exercise\n2\n3\n\n\n\nTotal ECTS: 23"
  },
  {
    "objectID": "generation/generated/curriculum.html#semester-2",
    "href": "generation/generated/curriculum.html#semester-2",
    "title": "General Study Process",
    "section": "",
    "text": "Type\nDescription\nSWS\nECTS\n\n\n\n\nLecture\nApplied Programming\n2\n1\n\n\nExercise\nApplied Programming Exercise\n4\n4\n\n\nLecture\nWildcard Science II\n2\n3\n\n\nLab\nWildcard Science Lab I\n4\n6\n\n\nLecture\nStatistical Data Analysis\n4\n4\n\n\nLecture\nScientific Computing Basics\n2\n3\n\n\nExercise\nScientific Computing Basics Exercise\n2\n3\n\n\n\nTotal ECTS: 24"
  },
  {
    "objectID": "generation/generated/curriculum.html#semester-3",
    "href": "generation/generated/curriculum.html#semester-3",
    "title": "General Study Process",
    "section": "",
    "text": "Type\nDescription\nSWS\nECTS\n\n\n\n\nSeminar\nRSE Nuts and Bolts II\n2\n3\n\n\nLab\nWildcard Science Lab II\n2\n2\n\n\nExercise\nText2Data\n4\n4\n\n\nLecture\nComputational Wildcard Science\n2\n3\n\n\nLecture\nSoftware Engineering I\n2\n4\n\n\nExercise\nSoftware Engineering I Exercise\n2\n2\n\n\nLecture\nHigh Performance Computing\n2\n3\n\n\nExercise\nHigh Performance Computing Exercise\n2\n3\n\n\n\nTotal ECTS: 24"
  },
  {
    "objectID": "generation/generated/curriculum.html#semester-4",
    "href": "generation/generated/curriculum.html#semester-4",
    "title": "General Study Process",
    "section": "",
    "text": "Type\nDescription\nSWS\nECTS\n\n\n\n\nThesis\nRSE Master Thesis\n10\n30\n\n\n\nTotal ECTS: 30\nTotal Curriculum ECTS: 101"
  },
  {
    "objectID": "generation/generated/cs_formalmethods.html",
    "href": "generation/generated/cs_formalmethods.html",
    "title": "Formal Methods in Software Engineering",
    "section": "",
    "text": "This module covers advanced topics in Software Engineering with a focus on formal methods for specification, modeling, and verification.\n\n\n\nThe module includes the following topics:\n\nSoftware Quality Assurance: Formal methods for specifying and verifying system properties.\nService Engineering: The role of formal methods in service-based architectures.\nSystem Design: Use of formal methods in system design, focusing on specification and verification.\n\n\n\n\n\nUnderstand and apply formal methods in system design and software engineering.\nAnalyse theoretical and practical problems in modeling and implementation using formal methods.\n\n\n\n\n\nEither a 90-minute written exam.\nOr a 20-30 minute oral examination.\n\nLecture: Formal Methods in Software Engineering Lecture covering formal methods in system design, software specification, and verification. SWS: 2 ECTS: 2\nExercise: Formal Methods Exercise Exercise for hands-on application of formal methods in system modeling and analysis. SWS: 2 ECTS: 4\n\n\n\n\n\n\nID\nDescription\nDisciplines\nPrerequisites\nEvidence\nAuthor\nSource\n\n\n\n\nformal_methods_1\napply formal methods in system design and software engineering.\nComputer Science\nBasic knowledge of software engineering.\nSubmit application of formal methods for a given software system.\nUniversity of Potsdam\nLink\n\n\nformal_methods_2\nAnalyse theoretical and practical problems in modelling and implementation using formal methods together with others.\nComputer Science\nBasic knowledge of formal methods.\nParticipate in self-regulated team exercises and presentations.\nUniversity of Potsdam\nLink\n\n\n\n\n\n\n\n\n\nNone\n\n\n\n\n\nUP Formal Methods in Software Engineering\n\n\n\n\n\nNone\n\n\n\n\n\nUP Computational Science Master"
  },
  {
    "objectID": "generation/generated/cs_formalmethods.html#introduction",
    "href": "generation/generated/cs_formalmethods.html#introduction",
    "title": "Formal Methods in Software Engineering",
    "section": "",
    "text": "This module covers advanced topics in Software Engineering with a focus on formal methods for specification, modeling, and verification."
  },
  {
    "objectID": "generation/generated/cs_formalmethods.html#contents",
    "href": "generation/generated/cs_formalmethods.html#contents",
    "title": "Formal Methods in Software Engineering",
    "section": "",
    "text": "The module includes the following topics:\n\nSoftware Quality Assurance: Formal methods for specifying and verifying system properties.\nService Engineering: The role of formal methods in service-based architectures.\nSystem Design: Use of formal methods in system design, focusing on specification and verification."
  },
  {
    "objectID": "generation/generated/cs_formalmethods.html#competences",
    "href": "generation/generated/cs_formalmethods.html#competences",
    "title": "Formal Methods in Software Engineering",
    "section": "",
    "text": "Understand and apply formal methods in system design and software engineering.\nAnalyse theoretical and practical problems in modeling and implementation using formal methods."
  },
  {
    "objectID": "generation/generated/cs_formalmethods.html#examination-methods",
    "href": "generation/generated/cs_formalmethods.html#examination-methods",
    "title": "Formal Methods in Software Engineering",
    "section": "",
    "text": "Either a 90-minute written exam.\nOr a 20-30 minute oral examination.\n\nLecture: Formal Methods in Software Engineering Lecture covering formal methods in system design, software specification, and verification. SWS: 2 ECTS: 2\nExercise: Formal Methods Exercise Exercise for hands-on application of formal methods in system modeling and analysis. SWS: 2 ECTS: 4"
  },
  {
    "objectID": "generation/generated/cs_formalmethods.html#module-competences",
    "href": "generation/generated/cs_formalmethods.html#module-competences",
    "title": "Formal Methods in Software Engineering",
    "section": "",
    "text": "ID\nDescription\nDisciplines\nPrerequisites\nEvidence\nAuthor\nSource\n\n\n\n\nformal_methods_1\napply formal methods in system design and software engineering.\nComputer Science\nBasic knowledge of software engineering.\nSubmit application of formal methods for a given software system.\nUniversity of Potsdam\nLink\n\n\nformal_methods_2\nAnalyse theoretical and practical problems in modelling and implementation using formal methods together with others.\nComputer Science\nBasic knowledge of formal methods.\nParticipate in self-regulated team exercises and presentations.\nUniversity of Potsdam\nLink"
  },
  {
    "objectID": "generation/generated/cs_formalmethods.html#sources-implementations",
    "href": "generation/generated/cs_formalmethods.html#sources-implementations",
    "title": "Formal Methods in Software Engineering",
    "section": "",
    "text": "None\n\n\n\n\n\nUP Formal Methods in Software Engineering\n\n\n\n\n\nNone\n\n\n\n\n\nUP Computational Science Master"
  },
  {
    "objectID": "generation/generated/cs_distributedsystems.html",
    "href": "generation/generated/cs_distributedsystems.html",
    "title": "Distributed Systems",
    "section": "",
    "text": "This module deals with distributed IT systems.\n\n\n\nThe module covers a selection of the following topics:\n\nReliability of distributed systems: Concepts of distributed file systems, synchronization techniques for reliable distributed applications, concepts of load balancing in high-availability clusters,\nExample: Sensor networks: Routing in sensor networks, operating systems for sensor networks, security in sensor networks,\nSecure internet protocols (IP security (IPsec), Pretty Good Privacy (PGP), Secure Socket Layer (SSL), Transport Layer Security (TLS), Secure Shell (SSH), DNS security (DNSsec)), secure IPv6 networks.\n\n\n\n\n\ncan evaluate existing distributed systems in terms of reliability and security and identify vulnerabilities.\ncan correctly identify reliability and security requirements when designing new distributed systems and consider them early in the development process.\n\n\n\n\n\neither 120 min written exam\nor 20-30 min oral examination\n\nLecture: Distributed Systems\nSWS: 2 ECTS: 2\nExercise: Distributed Systems Exercise\nSWS: 2 ECTS: 4\n\n\n\n\n\n\nID\nDescription\nDisciplines\nPrerequisites\nEvidence\nAuthor\nSource\n\n\n\n\ndist_systems_1\nevaluate existing distributed systems in terms of reliability and security and identify vulnerabilities\nComputer Science\n\nSubmit written analysis of existing distributed systems\nUniversity of Potsdam\nLink\n\n\ndist_systems_2\nidentify reliability and security requirements when designing new distributed system and consider them early in the development process\nComputer Science\n\ndiscuss necessary requirements for a design of a distributed system\nUniversity of Potsdam\nLink\n\n\n\n\n\n\n\n\n\nNone\n\n\n\n\n\nUP Verteilte Systeme\n\n\n\n\n\nTODO\n\n\n\n\n\nUP Computational Science Master"
  },
  {
    "objectID": "generation/generated/cs_distributedsystems.html#introduction",
    "href": "generation/generated/cs_distributedsystems.html#introduction",
    "title": "Distributed Systems",
    "section": "",
    "text": "This module deals with distributed IT systems."
  },
  {
    "objectID": "generation/generated/cs_distributedsystems.html#contents",
    "href": "generation/generated/cs_distributedsystems.html#contents",
    "title": "Distributed Systems",
    "section": "",
    "text": "The module covers a selection of the following topics:\n\nReliability of distributed systems: Concepts of distributed file systems, synchronization techniques for reliable distributed applications, concepts of load balancing in high-availability clusters,\nExample: Sensor networks: Routing in sensor networks, operating systems for sensor networks, security in sensor networks,\nSecure internet protocols (IP security (IPsec), Pretty Good Privacy (PGP), Secure Socket Layer (SSL), Transport Layer Security (TLS), Secure Shell (SSH), DNS security (DNSsec)), secure IPv6 networks."
  },
  {
    "objectID": "generation/generated/cs_distributedsystems.html#competences",
    "href": "generation/generated/cs_distributedsystems.html#competences",
    "title": "Distributed Systems",
    "section": "",
    "text": "can evaluate existing distributed systems in terms of reliability and security and identify vulnerabilities.\ncan correctly identify reliability and security requirements when designing new distributed systems and consider them early in the development process."
  },
  {
    "objectID": "generation/generated/cs_distributedsystems.html#examination-methods",
    "href": "generation/generated/cs_distributedsystems.html#examination-methods",
    "title": "Distributed Systems",
    "section": "",
    "text": "either 120 min written exam\nor 20-30 min oral examination\n\nLecture: Distributed Systems\nSWS: 2 ECTS: 2\nExercise: Distributed Systems Exercise\nSWS: 2 ECTS: 4"
  },
  {
    "objectID": "generation/generated/cs_distributedsystems.html#module-competences",
    "href": "generation/generated/cs_distributedsystems.html#module-competences",
    "title": "Distributed Systems",
    "section": "",
    "text": "ID\nDescription\nDisciplines\nPrerequisites\nEvidence\nAuthor\nSource\n\n\n\n\ndist_systems_1\nevaluate existing distributed systems in terms of reliability and security and identify vulnerabilities\nComputer Science\n\nSubmit written analysis of existing distributed systems\nUniversity of Potsdam\nLink\n\n\ndist_systems_2\nidentify reliability and security requirements when designing new distributed system and consider them early in the development process\nComputer Science\n\ndiscuss necessary requirements for a design of a distributed system\nUniversity of Potsdam\nLink"
  },
  {
    "objectID": "generation/generated/cs_distributedsystems.html#sources-implementations",
    "href": "generation/generated/cs_distributedsystems.html#sources-implementations",
    "title": "Distributed Systems",
    "section": "",
    "text": "None\n\n\n\n\n\nUP Verteilte Systeme\n\n\n\n\n\nTODO\n\n\n\n\n\nUP Computational Science Master"
  },
  {
    "objectID": "general/preambel_general.html#research-skills",
    "href": "general/preambel_general.html#research-skills",
    "title": "WORK IN PROGRESS THIS IS NOT THE OFFICIAL STATEMENT OF THE COMMUNITY BUT THE CURRENT VERSION",
    "section": "Research skills",
    "text": "Research skills\nTODO add text here\nResearch skills are implemented in the following components:\n\nmnt_project (TODO work/elaborate on naming, add cross-reference)\nmnt_wildcard\nrse_thesis\n\nTechnical skills are implemented in:\n\ngen_datascience\ngen_programming\ngen_softwareengineering\nrse_softwareengineering\nrse_programming\n\n(TODO check if technical training assumes too big a role)\ncommunication skills are implemented in:\n\nrse_management\nmnt_project\nrse_theory"
  },
  {
    "objectID": "general/ideas.html",
    "href": "general/ideas.html",
    "title": "Ideas",
    "section": "",
    "text": "Electronic Lab course. Heard of this in Erlangen for physics. Talks about ELN among other things.\n\n\nThe target audience for such a master’s programme would be students holding a bachelor’s degree from a domain science, which we will call home domain in the following.\nThere is explicitly no restriction on the candidates’ home domain: it may be from the STEM disciplines, life sciences, humanities or social sciences. Candidates with a bachelor’s degree in computer science are also explicitly included, although we acknowledge that their master’s programme should include adaptations to make their interaction effective with other domain scientists.\nIn order to give the future RSE the necessary breadth, we expect this to be a four semester curriculum.\nThe curriculum is formed from a combination of modules, some of which are core modules teaching essential skills that must be completed by all students. Other modules introduce more specialised concepts and skills.\nDuring the master’s programme, students should pick an RSE specialisation from the list in this paper and attend these additional modules to deepen their knowledge in the field.\nCore modules are of course drawn from the three pillars of the RSE and can be categorised accordingly.\n\n\n\nFoundational module\nIntroduction to programming: Emphasising use cases over programming paradigms, students learn at least two languages:\n\nA language that facilitates prototyping and data processing e.g., Python or R\nA language for designing complex, performance-critical systems e.g., C/Cpp\nThis exposes them to computers in a hands-on fashion and is the foundation for DOCBB, DIST.\n\nComputing environment module\nProgramming languages are not enough to work in a landscape of many interconnected software components. Hence, we require something like software craftsmanship:\n\nTools: Unix shell, version control systems, build systems, documentation generators, package distribution platforms, and software discovery systems\nThis strengthens skills in DIST, DOCBB, SWREPOS, SRU.\n\nSoftware engineering module\nDevelop foundational software engineering competencies:\n\nRequirements engineering\nSoftware architecture and design\nImplementation, quality assurance, and software evolution\nEmphasising and strengthening DOCBB, DIST on a more abstract level.\n\n\n\n\n\n\nOptional domain mastery module\nAdditional minor research courses; students with a home-domain already have the research part well-covered.\nResearch tools module\nTeach tools used to distribute and publish software, and introduce domain-specific data repositories, gaining foundational knowledge in SRU, SP, DOMREP.\nMeta-research module\nTeach how research works: Introduce the research life cycle, the data life cycle, and the software life cycle abstractly.\n\n\n\n\n\nProject management methods\nTeach project management methods that are useful in science, such as agile ones PM.\nCommunication skills module\nCourses focusing on:\n\nInterdisciplinary communication\nInteracting across cultures\nCommunication in hierarchies\nSupporting end users effectively\nAll facets of the USERS skill.\n\nTeaching module\nCovers topics to effectively design courses and teaching material for various digital tools, strengthening the TEACH skill.\n\n\n\n\n\nRSE work also involves craftsmanship skills. Hands-on practice is integral.\n\nAt least two lab projects are required within the mandatory curriculum.\nThese should be team-based and involve a question from a domain science.\nIdeally, projects cover both the candidate’s home domain and another domain.\nProjects should stem from collaborations with scientists within the institution, with RSE students taking on a consultant role.\n\nThis setup strengthens TEAM, TEACH, USERS and likely also MOD through interaction.\nTo emphasise exposure beyond their bachelor’s domain, RSEs should support their non-home-domain project with introductory courses from that discipline. This encourages adapting vocabulary and thinking—an aspect of MOD.\n\n\n\nTo align with the specialisations listed in this paper, example optional modules include:\n\nHPC engineering / parallel programming\nNumerical mathematics / scientific computing\nWeb technologies\nData stewardship\nAI models / statistics\nCommunity management / training\n\n\n\n\nThe programme concludes with a master’s thesis that should:\n\nBe dual-supervised by an RSE project supervisor and a domain supervisor\nAnswer a relevant research question strengthening NEW using computational methods\nInclude software development as a required, gradable deliverable\n\nThe RSE supervisor ensures and grades the software craftsmanship. This ensures the effective application of RSE skills in an actual research environment."
  },
  {
    "objectID": "general/ideas.html#original-motivation",
    "href": "general/ideas.html#original-motivation",
    "title": "Ideas",
    "section": "",
    "text": "The target audience for such a master’s programme would be students holding a bachelor’s degree from a domain science, which we will call home domain in the following.\nThere is explicitly no restriction on the candidates’ home domain: it may be from the STEM disciplines, life sciences, humanities or social sciences. Candidates with a bachelor’s degree in computer science are also explicitly included, although we acknowledge that their master’s programme should include adaptations to make their interaction effective with other domain scientists.\nIn order to give the future RSE the necessary breadth, we expect this to be a four semester curriculum.\nThe curriculum is formed from a combination of modules, some of which are core modules teaching essential skills that must be completed by all students. Other modules introduce more specialised concepts and skills.\nDuring the master’s programme, students should pick an RSE specialisation from the list in this paper and attend these additional modules to deepen their knowledge in the field.\nCore modules are of course drawn from the three pillars of the RSE and can be categorised accordingly.\n\n\n\nFoundational module\nIntroduction to programming: Emphasising use cases over programming paradigms, students learn at least two languages:\n\nA language that facilitates prototyping and data processing e.g., Python or R\nA language for designing complex, performance-critical systems e.g., C/Cpp\nThis exposes them to computers in a hands-on fashion and is the foundation for DOCBB, DIST.\n\nComputing environment module\nProgramming languages are not enough to work in a landscape of many interconnected software components. Hence, we require something like software craftsmanship:\n\nTools: Unix shell, version control systems, build systems, documentation generators, package distribution platforms, and software discovery systems\nThis strengthens skills in DIST, DOCBB, SWREPOS, SRU.\n\nSoftware engineering module\nDevelop foundational software engineering competencies:\n\nRequirements engineering\nSoftware architecture and design\nImplementation, quality assurance, and software evolution\nEmphasising and strengthening DOCBB, DIST on a more abstract level.\n\n\n\n\n\n\nOptional domain mastery module\nAdditional minor research courses; students with a home-domain already have the research part well-covered.\nResearch tools module\nTeach tools used to distribute and publish software, and introduce domain-specific data repositories, gaining foundational knowledge in SRU, SP, DOMREP.\nMeta-research module\nTeach how research works: Introduce the research life cycle, the data life cycle, and the software life cycle abstractly.\n\n\n\n\n\nProject management methods\nTeach project management methods that are useful in science, such as agile ones PM.\nCommunication skills module\nCourses focusing on:\n\nInterdisciplinary communication\nInteracting across cultures\nCommunication in hierarchies\nSupporting end users effectively\nAll facets of the USERS skill.\n\nTeaching module\nCovers topics to effectively design courses and teaching material for various digital tools, strengthening the TEACH skill."
  },
  {
    "objectID": "general/ideas.html#hands-on-practice",
    "href": "general/ideas.html#hands-on-practice",
    "title": "Ideas",
    "section": "",
    "text": "RSE work also involves craftsmanship skills. Hands-on practice is integral.\n\nAt least two lab projects are required within the mandatory curriculum.\nThese should be team-based and involve a question from a domain science.\nIdeally, projects cover both the candidate’s home domain and another domain.\nProjects should stem from collaborations with scientists within the institution, with RSE students taking on a consultant role.\n\nThis setup strengthens TEAM, TEACH, USERS and likely also MOD through interaction.\nTo emphasise exposure beyond their bachelor’s domain, RSEs should support their non-home-domain project with introductory courses from that discipline. This encourages adapting vocabulary and thinking—an aspect of MOD."
  },
  {
    "objectID": "general/ideas.html#optional-modules-and-specialisations",
    "href": "general/ideas.html#optional-modules-and-specialisations",
    "title": "Ideas",
    "section": "",
    "text": "To align with the specialisations listed in this paper, example optional modules include:\n\nHPC engineering / parallel programming\nNumerical mathematics / scientific computing\nWeb technologies\nData stewardship\nAI models / statistics\nCommunity management / training"
  },
  {
    "objectID": "general/ideas.html#masters-thesis",
    "href": "general/ideas.html#masters-thesis",
    "title": "Ideas",
    "section": "",
    "text": "The programme concludes with a master’s thesis that should:\n\nBe dual-supervised by an RSE project supervisor and a domain supervisor\nAnswer a relevant research question strengthening NEW using computational methods\nInclude software development as a required, gradable deliverable\n\nThe RSE supervisor ensures and grades the software craftsmanship. This ensures the effective application of RSE skills in an actual research environment."
  },
  {
    "objectID": "event/kickoff-workshops/workshops.html",
    "href": "event/kickoff-workshops/workshops.html",
    "title": "Workshops for the Research Software Engineering Master",
    "section": "",
    "text": "In modern science, software-based research is playing an increasingly central role. The professional development and competent use of software are crucial for progress in nearly all scientific disciplines. Accordingly, the professional profile of Research Software Engineers (RSEs) has emerged—characterized by a combination of expertise in software development and a deep understanding of scientific research processes. With the growing importance of this role, particularly in the context of emerging Research Software Engineering (RSE) service centers at and for research institutions, there is an increasing demand for dedicated Master’s programs in RSE or for the integration of RSE profiles into existing, thematically related Master’s programs.\nWe invite all members of the RSE community and interested scientists and educators to join us in developing a Master’s curriculum tailored to the unique needs, interests, and challenges of RSE. Each module represents a specific area of the RSE landscape and will be shaped by community-driven short online workshops (2–3 hours each).\nThe main idea is to supplement general courses on software engineering, data science and advanced science classes with RSE-specific courses tailored to the growing field of software engineering in research. Mapping necessary required basic courses is part the process.\nThese example modules will be new in structure and content and provide universities a suggestion how to hire and support the growing need for RSE competencies. These courses will be optional in the sense that alternatives or similar existing classes will be suggested if a specialized lecturer is not available.\nIn these workshops, we collaboratively define:\n\nRelevant competences\nSuggested course structures\nRSE-specific perspectives\n\nThese efforts will feed directly into the development of a comprehensive and inclusive RSE Master’s curriculum. You can explore the broader project here: RSE Masters Curriculum GitHub Repository"
  },
  {
    "objectID": "event/kickoff-workshops/workshops.html#rse-management-and-communication",
    "href": "event/kickoff-workshops/workshops.html#rse-management-and-communication",
    "title": "Workshops for the Research Software Engineering Master",
    "section": "1. RSE Management and Communication",
    "text": "1. RSE Management and Communication\nThis module encapsulates the communication and management skills that are relevant for working in the interdisciplinary setting of RSE-professionals.\nThis may include but is not limited to:\n\nworking in a team (see TEAM in (Goth et al. 2024))\nteaching RSE-basics (see TEACH in (Goth et al. 2024))\nproject management (see PM in (Goth et al. 2024))\ninteraction with users and other stakeholders (see USERS in (Goth et al. 2024))\nFAIR for humans and machines\nSoftware Management Plans for research software"
  },
  {
    "objectID": "event/kickoff-workshops/workshops.html#the-missing-semester-tooling-utility",
    "href": "event/kickoff-workshops/workshops.html#the-missing-semester-tooling-utility",
    "title": "Workshops for the Research Software Engineering Master",
    "section": "2. The Missing Semester / Tooling / Utility",
    "text": "2. The Missing Semester / Tooling / Utility\nIn reference to the MIT Missing Semester this module tries to convey the nuts and bolts of code development.\nThis may include (but is not limited to):\n\nShell Tools and Scripting\nEditors & IDE (i.e. Vim)\nData Wrangling\nCommand-line Environment\nVersion Control (Git)\nDebugging and Profiling\nMetaprogramming\nDocumentation\nSecurity and Cryptography (ssh, md5)\n\nThese general competencies can be extended to RSE-specific techniques such as:\n\nSoftware publication and citation (see SP in (Goth et al. 2024))\nUsing domain repositories/directories (see DOMREP in (Goth et al. 2024))\n\nOne early idea is to employ inquiry-based learning and peer teaching to convey these issues that may otherwise be too applied to a university curriculum. This would serve the idea that communicating and teaching RSE-skills is one of the cornerstones of a RSE professional (see TEACH in (Goth et al. 2024))."
  },
  {
    "objectID": "event/kickoff-workshops/workshops.html#rse-efficient-computing-and-hardware",
    "href": "event/kickoff-workshops/workshops.html#rse-efficient-computing-and-hardware",
    "title": "Workshops for the Research Software Engineering Master",
    "section": "3. RSE Efficient Computing and Hardware",
    "text": "3. RSE Efficient Computing and Hardware\nRSEs with expertise in HPC and other performance-critical computing domains specialize in optimizing code for efficient execution across various platforms, including clusters, cloud, edge, and embedded systems. They understand parallel programming models, hardware-specific optimizations, profiling tools, and platform constraints such as memory, energy, and latency. Their skills enable them to adapt software to diverse infrastructures, manage complex dependencies, and support researchers in accessing and using advanced computing resources effectively and sustainably.\nDepending on the goals of the workshop, it may be useful to focus on participants with a background in technical computer science or some prior exposure to parallel programming. Familiarity with teaching multithreading, MPI, or GPU programming (e.g., CUDA) could be helpful, especially if we dive into hands-on HPC RSE aspects."
  },
  {
    "objectID": "event/kickoff-workshops/workshops.html#programming-and-software-engineering-for-research",
    "href": "event/kickoff-workshops/workshops.html#programming-and-software-engineering-for-research",
    "title": "Workshops for the Research Software Engineering Master",
    "section": "4. Programming and Software Engineering for Research",
    "text": "4. Programming and Software Engineering for Research\n\nProgramming for Research\nThe RSE programming module extends the Fundamentals of Computer Science module with a focus on RSE-specific programming patterns, necessary technologies and good practices.\nThis may include, but is not limited to\n\nsoftware re-use (see SRU in (Goth et al. 2024))\ncreating documented code building blocks (see DOCBB in (Goth et al. 2024))\nbuilding distributable software (see DIST in (Goth et al. 2024))\nresearch specific programming languages\nresearch specific code requirements (scalability, functional programming, …)\nVector and graph database in generative AI applications //This topic (LLM or AI) has been not yet deeply explored in RSE field. Perhaps someone here is an AI expert who can suggest more specific programmes?\n\n\n\nResearch Software Engineering\nThis module extends the Classical Software Engineering Module with research specific learnings. This may include but is not limited to\n\nAdapting the software life cycle to research (see SWLC in (Goth et al. 2024))\nSoftware behaviour awareness and analysis (see MOD in (Goth et al. 2024))\nResearch specific Engineering Patterns"
  },
  {
    "objectID": "event/kickoff-workshops/workshops.html#rse-theory",
    "href": "event/kickoff-workshops/workshops.html#rse-theory",
    "title": "Workshops for the Research Software Engineering Master",
    "section": "5. RSE Theory",
    "text": "5. RSE Theory\nThe RSE master program is more than a computer science specialisation for researchers. People working as RSE are often involved in digitalization projects, institutional development or other non-technical tasks.\nFor a university level study program it is fitting that students learn an abstract high-level understanding of their field so that they can adapt technical models, communication frameworks and policy recommendations to the complex cases. For this they need a solid understanding in some of the more theoretical fields such as …\n\nphilosophy of science\nsociology of technology\nethics and artificial intelligence\nhuman computer interaction\ndigital humanities\n\nThis module conveys competences in areas such as but not limited to …\n\nconducting and leading research (NEW)\nunderstanding the research cycle (RC)\ninteraction with users and stakeholders (USERS)"
  },
  {
    "objectID": "event/kickoff-workshops/workshops.html#rse-for-natural-sciences",
    "href": "event/kickoff-workshops/workshops.html#rse-for-natural-sciences",
    "title": "Workshops for the Research Software Engineering Master",
    "section": "6. RSE for Natural Sciences",
    "text": "6. RSE for Natural Sciences\nThis workshop focuses on the specific requirements and priorities in the natural sciences. One of the intended profiles for the RSE Master’s curriculum is the professional development and specialization of researchers working in natural science disciplines.\nThe workshop will address the following topics:\n\nRSE competencies required in the natural sciences\nProfessional development and specific working conditions in the natural sciences\nInstitutional stakeholders and interested parties involved in shaping the MNT (Mathematics, Natural Sciences, and Technology) profile"
  },
  {
    "objectID": "event/kickoff-workshops/workshops.html#institutional-constraints-of-the-rse-master",
    "href": "event/kickoff-workshops/workshops.html#institutional-constraints-of-the-rse-master",
    "title": "Workshops for the Research Software Engineering Master",
    "section": "7. Institutional Constraints of the RSE Master",
    "text": "7. Institutional Constraints of the RSE Master\nThis workshop aims to clarify the structural framework of a Master’s program in Research Software Engineering (RSE). We will discuss the typical program duration (two years in Germany) and whether alternatives—such as one- or three-year formats—should be considered.\nKey questions include:\n\nWhich faculties or departments are authorized to grant the degree? Should it be restricted to Computer Science, or could other disciplines also serve as the awarding body under certain conditions?\nWhat should the admission requirements be, particularly for applicants from interdisciplinary backgrounds?\n\nWe will also explore the composition of the curriculum:\n\nIs it possible to structure levels of RSE competence similarly to the German Informatics Society’s model for Computer Science degrees?\nHow should the program balance the research (R) and software engineering (SE) components?\nWhat profiles or tracks might be envisioned, and how modular and flexible should the curriculum be?"
  },
  {
    "objectID": "components/rse_thesis/description.html",
    "href": "components/rse_thesis/description.html",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "",
    "text": "The master’s thesis is the culminating component of the RSE programme. In this module, students apply the full spectrum of Research Software Engineering skills in a real-world research setting, demonstrating their ability to independently design, implement, and document a computational research contribution.\nThe thesis must address a research question in collaboration with a scientific or applied domain, but its core should include a substantial computational component. This may involve software development, data-intensive research, reproducibility infrastructure, or performance engineering — depending on the chosen topic and specialization.\nEach thesis must be supervised jointly by:\n\nA domain expert (e.g., in physics, life sciences, or humanities)\nAn RSE mentor (who ensures the quality and relevance of the computational contribution)\n\nStudents are expected to follow best practices in software engineering, version control, testing, and documentation. The final submission must include:\n\nA written thesis describing both the scientific and software contributions\nA structured, reproducible code repository\nA presentation and defense in a thesis colloquium\n\nThe colloquium serves as both a public communication exercise and a final evaluation, where students present their project and reflect on challenges and insights gained during the thesis."
  },
  {
    "objectID": "components/rse_thesis/description.html#masters-thesis-module-research-software-engineering-thesis",
    "href": "components/rse_thesis/description.html#masters-thesis-module-research-software-engineering-thesis",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "",
    "text": "The master’s thesis is the culminating component of the RSE programme. In this module, students apply the full spectrum of Research Software Engineering skills in a real-world research setting, demonstrating their ability to independently design, implement, and document a computational research contribution.\nThe thesis must address a research question in collaboration with a scientific or applied domain, but its core should include a substantial computational component. This may involve software development, data-intensive research, reproducibility infrastructure, or performance engineering — depending on the chosen topic and specialization.\nEach thesis must be supervised jointly by:\n\nA domain expert (e.g., in physics, life sciences, or humanities)\nAn RSE mentor (who ensures the quality and relevance of the computational contribution)\n\nStudents are expected to follow best practices in software engineering, version control, testing, and documentation. The final submission must include:\n\nA written thesis describing both the scientific and software contributions\nA structured, reproducible code repository\nA presentation and defense in a thesis colloquium\n\nThe colloquium serves as both a public communication exercise and a final evaluation, where students present their project and reflect on challenges and insights gained during the thesis."
  },
  {
    "objectID": "components/rse_softwareengineering/description.html",
    "href": "components/rse_softwareengineering/description.html",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "",
    "text": "This module extends the Classical Software Engineering Module with research specific learnings. This includes but is not limited to\n\nsoftware re-use (see SRU in (Goth et al. 2024))\ncreating documented code building blocks (see DOCBB in (Goth et al. 2024))\nbuilding distributable software (see DIST in (Goth et al. 2024))\nresearch specific programming languages\nresearch specific code requirements (scalability, functional programming, …)\nAdapting the software life cycle to research (see SWLC in (Goth et al. 2024))\nSoftware behaviour awareness and analysis (see MOD in (Goth et al. 2024))\nResearch specific Engineering Patterns"
  },
  {
    "objectID": "components/rse_softwareengineering/description.html#rse-software-engineering",
    "href": "components/rse_softwareengineering/description.html#rse-software-engineering",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "",
    "text": "This module extends the Classical Software Engineering Module with research specific learnings. This includes but is not limited to\n\nsoftware re-use (see SRU in (Goth et al. 2024))\ncreating documented code building blocks (see DOCBB in (Goth et al. 2024))\nbuilding distributable software (see DIST in (Goth et al. 2024))\nresearch specific programming languages\nresearch specific code requirements (scalability, functional programming, …)\nAdapting the software life cycle to research (see SWLC in (Goth et al. 2024))\nSoftware behaviour awareness and analysis (see MOD in (Goth et al. 2024))\nResearch specific Engineering Patterns"
  },
  {
    "objectID": "components/rse_management/description.html",
    "href": "components/rse_management/description.html",
    "title": "RSE Management and Communication",
    "section": "",
    "text": "This module comprises the communication and management skills that are relevant for working in the interdisciplinary setting of RSE-professionals.\nThis includes but is not limited to:\n\nworking in a team (see TEAM in (Goth et al. 2024))\nteaching RSE-basics (see TEACH in (Goth et al. 2024))\nproject management (see PM in (Goth et al. 2024))\ninteraction with users and other stakeholders (see USERS in (Goth et al. 2024))\n\n\n\n\n\nresearch management\n\nresearch cycle\nopen science, FAIR, FAIR4RS\npublication workflow: obstacles and embargoes\nlegal aspects of research data, e.g. GDPR\npseudonymization/anonymization methods for data privacy\npublic databases\n\nquality control\n\nrequirements engineering\ntrying goals with quality: test-driven development\nbehavior-driven development, Gherkin-Style acceptance testing\nproject folder organization\ncode review principles\n\ncommunication and collaboration\n\ncommunication frameworks, e.g. AIDA, RACE, 7 C’s\npersonality traits and their impact on cooperation\ncollaboration frameworks for remote work\nrealisation and benefits of pair programming and mob/ensemble programming\ntechnical English writing skills: writing in issues and merge requests, code review…\nconflict management, e.g. dealing with researchers that do not listen\nhow to address relevant stakeholders (i.e. users and SEs) with different background knowledge, experience and expectations\nequity, diversity and inclusion principles\n\nteam management\n\nchallenges of transient teams (that only exist for 5-15 hours)\neffects of varying team sizes\nmanagement depending on project size/type\nspecialised roles in a software team\nintercultural and interdisciplinary differences\nteam management methodologies\nimportance of shared values in a RSE team\ndual goals: project vs. personal goal\n\ntime and project management\n\ngoal-setting\nproject management methods, their strengths and weaknesses\nagile (not necessarily Scrum)\nLean & Kanban (Small-Batch Philosophies)\ndivision of tasks into sub-tasks and task-dependencies\niterative workflows\ncontinuous delivery\ncommunication with a manager/supervisor"
  },
  {
    "objectID": "components/rse_management/description.html#introduction",
    "href": "components/rse_management/description.html#introduction",
    "title": "RSE Management and Communication",
    "section": "",
    "text": "This module comprises the communication and management skills that are relevant for working in the interdisciplinary setting of RSE-professionals.\nThis includes but is not limited to:\n\nworking in a team (see TEAM in (Goth et al. 2024))\nteaching RSE-basics (see TEACH in (Goth et al. 2024))\nproject management (see PM in (Goth et al. 2024))\ninteraction with users and other stakeholders (see USERS in (Goth et al. 2024))"
  },
  {
    "objectID": "components/rse_management/description.html#contents",
    "href": "components/rse_management/description.html#contents",
    "title": "RSE Management and Communication",
    "section": "",
    "text": "research management\n\nresearch cycle\nopen science, FAIR, FAIR4RS\npublication workflow: obstacles and embargoes\nlegal aspects of research data, e.g. GDPR\npseudonymization/anonymization methods for data privacy\npublic databases\n\nquality control\n\nrequirements engineering\ntrying goals with quality: test-driven development\nbehavior-driven development, Gherkin-Style acceptance testing\nproject folder organization\ncode review principles\n\ncommunication and collaboration\n\ncommunication frameworks, e.g. AIDA, RACE, 7 C’s\npersonality traits and their impact on cooperation\ncollaboration frameworks for remote work\nrealisation and benefits of pair programming and mob/ensemble programming\ntechnical English writing skills: writing in issues and merge requests, code review…\nconflict management, e.g. dealing with researchers that do not listen\nhow to address relevant stakeholders (i.e. users and SEs) with different background knowledge, experience and expectations\nequity, diversity and inclusion principles\n\nteam management\n\nchallenges of transient teams (that only exist for 5-15 hours)\neffects of varying team sizes\nmanagement depending on project size/type\nspecialised roles in a software team\nintercultural and interdisciplinary differences\nteam management methodologies\nimportance of shared values in a RSE team\ndual goals: project vs. personal goal\n\ntime and project management\n\ngoal-setting\nproject management methods, their strengths and weaknesses\nagile (not necessarily Scrum)\nLean & Kanban (Small-Batch Philosophies)\ndivision of tasks into sub-tasks and task-dependencies\niterative workflows\ncontinuous delivery\ncommunication with a manager/supervisor"
  },
  {
    "objectID": "components/rse_computing/hpc_computing.html",
    "href": "components/rse_computing/hpc_computing.html",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "",
    "text": "High‑Performance Scientific Computing\n\nModule Overview\nBuilding on “Basic Scientific Computing”, this module dives deeper into scalable algorithms, architectures, and software engineering techniques required to run large‑scale simulations and data analysis on high‑performance computing (HPC) systems.\n\n\nIntended Learning Outcomes\nParticipants who successfully complete the module will be able to\n\nClassify scientific problems by their dominant parallel pattern (memory‑parallel, compute‑parallel, task‑parallel).\nMap each class to appropriate numerical libraries and hardware architectures.\nAnalyse floating‑point and algorithmic approximation errors at scale.\nExplain modern HPC hardware features (GPUs, SIMD/AVX, NUMA, high‑speed interconnects) and select relevant optimisation strategies.\nDesign portable, performance‑portable code employing MPI, OpenMP, and accelerator frameworks.\nUse continuous benchmarking to guide sustainable performance evolution of research software.\nPlan for long‑term maintenance, archival, and FAIR publication of large‑scale codes and data.\n\n\n\nSyllabus (Indicative Content)\n\n\n\n\n\n\n\n\nWeek\nTheme\nTopics\n\n\n\n\n1\nParallel Problem Taxonomy\nSparse vs. dense linear algebra · embarrassingly parallel workloads\n\n\n2\nDistributed Memory (MPI)\nDomain decomposition · halo exchange · scalability metrics\n\n\n3\nShared Memory & SIMD\nOpenMP · threading pitfalls · AVX intrinsics\n\n\n4\nAccelerator Programming\nMulti‑GPU kernels · unified memory · portability layers (Kokkos, SYCL)\n\n\n5\nAdvanced I/O & Checkpointing\nParallel file systems · burst buffers · HDF5/ADIOS‑based workflows\n\n\n6\nPerformance Engineering\nRoofline model · continuous & comparative benchmarking · autotuning\n\n\n7\nSustainable HPC Software\nRelease engineering · long‑term archiving · community governance\n\n\n\n\n\nTeaching & Learning Methods\nBlended delivery: interactive lectures (40%), coding workshops on the national cluster (50%), expert seminars (10%).\n\n\nAssessment\n\n\n\n\n\n\n\n\nComponent\nWeight\nDetails\n\n\n\n\nCluster labs\n30%\nSubmission of working MPI/OpenMP/GPU exercises\n\n\nPerformance study\n30%\nRoofline + scaling analysis of an existing code\n\n\nCapstone project\n40%\nImplement & optimise a solver or ML pipeline at scale, plus written report\n\n\n\n\n\nPrerequisites\n\nCompletion of “Basic Scientific Computing” or equivalent experience\nFamiliarity with Linux command line and version control\n\n\n\nKey Resources\n\nreplace CHatGPT fantasies"
  },
  {
    "objectID": "components/mnt_wildcard/description.html",
    "href": "components/mnt_wildcard/description.html",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "",
    "text": "This module offers RSE students the opportunity to deepen their understanding of a scientific discipline outside of their home domain. Students choose a science module — such as physics, chemistry, biology, or earth sciences — and engage with its research practices, core questions, and data/software challenges.\nThe goal is to help students become better collaborators by gaining first-hand exposure to the terminology, logic, and needs of another scientific domain. This broadens the student’s ability to apply RSE skills in interdisciplinary teams and unfamiliar environments.\nThe module may consist of lectures, lab sessions, and domain-specific mini-projects. RSEs are encouraged to reflect on how software engineering, data handling, reproducibility, and tooling intersect with the chosen discipline.\nThis module is deliberately flexible to accommodate institutional offerings and student interests as well as providing the option to stay attached to the identity of the chosen discipline."
  },
  {
    "objectID": "components/mnt_wildcard/description.html#wildcard-science-module",
    "href": "components/mnt_wildcard/description.html#wildcard-science-module",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "",
    "text": "This module offers RSE students the opportunity to deepen their understanding of a scientific discipline outside of their home domain. Students choose a science module — such as physics, chemistry, biology, or earth sciences — and engage with its research practices, core questions, and data/software challenges.\nThe goal is to help students become better collaborators by gaining first-hand exposure to the terminology, logic, and needs of another scientific domain. This broadens the student’s ability to apply RSE skills in interdisciplinary teams and unfamiliar environments.\nThe module may consist of lectures, lab sessions, and domain-specific mini-projects. RSEs are encouraged to reflect on how software engineering, data handling, reproducibility, and tooling intersect with the chosen discipline.\nThis module is deliberately flexible to accommodate institutional offerings and student interests as well as providing the option to stay attached to the identity of the chosen discipline."
  },
  {
    "objectID": "components/mnt_compwildcard/description.html",
    "href": "components/mnt_compwildcard/description.html",
    "title": "Wildcard Computational Science",
    "section": "",
    "text": "Wildcard Computational Science\nThis module offers RSE students the opportunity to deepen their understanding of computational methods specific to a science discipline. Students choose a science module — such as physics, chemistry, biology, or earth sciences — and engage with its computational practices, core questions, and data/software challenges.\nThe goal is to apply the general competences acquired in the general programming and software engineering courses to the practices and special needs of the chosen discipline. Computational Physics might face different algorithmic or conceptual challenges than computational chemistry. This module is intended for the case that the institution offers such a specialized computational course."
  },
  {
    "objectID": "components/gen_softwareengineering/se1.html",
    "href": "components/gen_softwareengineering/se1.html",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "",
    "text": "Basic concepts of software engineering, software and product life cycle, process models for the design of large software systems, semantic aspects of domain description, hierarchy, parallelism, real-time and embedded systems as fundamental paradigms, organizational principles of complex software systems, design by contract, patterns in modeling and design methods of quality assurance, evolution and re-engineering, selected languages and tools for process- and object-oriented modeling, methods and languages for object-oriented design, architectures and architectural patterns of software systems, architecture of enterprise applications, design and implementation models in the object-oriented paradigm, e.g., Java 2 SE, design patterns, software testing methods."
  },
  {
    "objectID": "components/gen_softwareengineering/se1.html#software-engineering-i",
    "href": "components/gen_softwareengineering/se1.html#software-engineering-i",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "",
    "text": "Basic concepts of software engineering, software and product life cycle, process models for the design of large software systems, semantic aspects of domain description, hierarchy, parallelism, real-time and embedded systems as fundamental paradigms, organizational principles of complex software systems, design by contract, patterns in modeling and design methods of quality assurance, evolution and re-engineering, selected languages and tools for process- and object-oriented modeling, methods and languages for object-oriented design, architectures and architectural patterns of software systems, architecture of enterprise applications, design and implementation models in the object-oriented paradigm, e.g., Java 2 SE, design patterns, software testing methods."
  },
  {
    "objectID": "components/gen_programming/description.html",
    "href": "components/gen_programming/description.html",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "",
    "text": "This is an example module to showcase the integration pipeline"
  },
  {
    "objectID": "components/gen_programming/description.html#example-module-fundamentals-of-computer-science",
    "href": "components/gen_programming/description.html#example-module-fundamentals-of-computer-science",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "",
    "text": "This is an example module to showcase the integration pipeline"
  },
  {
    "objectID": "components/gen_programming/applied_programming.html",
    "href": "components/gen_programming/applied_programming.html",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "",
    "text": "Applied Programming\n\nProcedural Programming Concepts\nProgramming with an imperative-procedural language (such as C):\n\nData types, type casting, control structures, functions and procedures, parameter passing paradigms, call stack\nPointers, arrays, strings, structured types\nErrors and their handling\nDynamic memory management\nProgram libraries\n\n\n\nProgramming in an Object-Oriented Language (e.g., Java)\n\nClasses, objects, constructors\nInheritance, polymorphism, abstract classes/interfaces\nExceptions and exception handling\nNamespaces (packages)\nGeneric classes and types\nProgram libraries"
  },
  {
    "objectID": "components/cs_securitycomplexity/description.html",
    "href": "components/cs_securitycomplexity/description.html",
    "title": "Security, Information and Complexity",
    "section": "",
    "text": "This module deals with correctness, security and complexity of algorithms.\n\n\n\n\nMethods for secure and reliable transmission and processing of information, error-correcting coding methods\nFundamentals of cryptographic systems, methods for information analysis, complexity aspects, applications\nNecessary foundations of mathematics and complexity theory are introduced alongside the topics\n\n\n\n\n\nUnderstand the mathematical foundations of secure and reliable information processing and their complexity-theoretical basis.\nAre familiar with the fundamentals of error-protected transmission and storage of data.\nAre capable of analysing the correctness, security, and complexity of methods\n\n\n\n\n\nEither a written exam (90 minutes).\nOr an oral examination (30 minutes)."
  },
  {
    "objectID": "components/cs_securitycomplexity/description.html#introduction",
    "href": "components/cs_securitycomplexity/description.html#introduction",
    "title": "Security, Information and Complexity",
    "section": "",
    "text": "This module deals with correctness, security and complexity of algorithms."
  },
  {
    "objectID": "components/cs_securitycomplexity/description.html#contents",
    "href": "components/cs_securitycomplexity/description.html#contents",
    "title": "Security, Information and Complexity",
    "section": "",
    "text": "Methods for secure and reliable transmission and processing of information, error-correcting coding methods\nFundamentals of cryptographic systems, methods for information analysis, complexity aspects, applications\nNecessary foundations of mathematics and complexity theory are introduced alongside the topics"
  },
  {
    "objectID": "components/cs_securitycomplexity/description.html#competences",
    "href": "components/cs_securitycomplexity/description.html#competences",
    "title": "Security, Information and Complexity",
    "section": "",
    "text": "Understand the mathematical foundations of secure and reliable information processing and their complexity-theoretical basis.\nAre familiar with the fundamentals of error-protected transmission and storage of data.\nAre capable of analysing the correctness, security, and complexity of methods"
  },
  {
    "objectID": "components/cs_securitycomplexity/description.html#examination-methods",
    "href": "components/cs_securitycomplexity/description.html#examination-methods",
    "title": "Security, Information and Complexity",
    "section": "",
    "text": "Either a written exam (90 minutes).\nOr an oral examination (30 minutes)."
  },
  {
    "objectID": "components/cs_example/description.html",
    "href": "components/cs_example/description.html",
    "title": "Module title",
    "section": "",
    "text": "This is an example module to showcase the integration pipeline\n\n\n\n\ndsfd\n\n\n\n\n\ndfsd\n\n\n\n\n\nEither a 90-minute written exam.\nOr a 20-30 minute oral examination."
  },
  {
    "objectID": "components/cs_example/description.html#introduction",
    "href": "components/cs_example/description.html#introduction",
    "title": "Module title",
    "section": "",
    "text": "This is an example module to showcase the integration pipeline"
  },
  {
    "objectID": "components/cs_example/description.html#contents",
    "href": "components/cs_example/description.html#contents",
    "title": "Module title",
    "section": "",
    "text": "dsfd"
  },
  {
    "objectID": "components/cs_example/description.html#competences",
    "href": "components/cs_example/description.html#competences",
    "title": "Module title",
    "section": "",
    "text": "dfsd"
  },
  {
    "objectID": "components/cs_example/description.html#examination-methods",
    "href": "components/cs_example/description.html#examination-methods",
    "title": "Module title",
    "section": "",
    "text": "Either a 90-minute written exam.\nOr a 20-30 minute oral examination."
  },
  {
    "objectID": "components/cs_compilertechnologies/description.html",
    "href": "components/cs_compilertechnologies/description.html",
    "title": "Module title",
    "section": "",
    "text": "This module provides an in-depth understanding of programming languages and compiler technology. Topics covered include lexical analysis, syntax parsing, code generation, and optimisation techniques for compilers. The course includes both theoretical lectures and practical exercises, culminating in a project where students will build a simple compiler.\n\n\n\n\nVirtualization\nProgramming Languages and Design\nSoftware System Security\n\n\n\n\n\ndescribe paradigms and tools for the specification, development, and quality assurance of modern software systems, as well as their application in different contexts\nuse various approaches in programming languages and compiler technology\n\n\n\n\n\neither a written exam (90-100 minutes)\nor an oral examination (20-30 minutes)\nor a project report (20-30 pages)"
  },
  {
    "objectID": "components/cs_compilertechnologies/description.html#introduction",
    "href": "components/cs_compilertechnologies/description.html#introduction",
    "title": "Module title",
    "section": "",
    "text": "This module provides an in-depth understanding of programming languages and compiler technology. Topics covered include lexical analysis, syntax parsing, code generation, and optimisation techniques for compilers. The course includes both theoretical lectures and practical exercises, culminating in a project where students will build a simple compiler."
  },
  {
    "objectID": "components/cs_compilertechnologies/description.html#contents",
    "href": "components/cs_compilertechnologies/description.html#contents",
    "title": "Module title",
    "section": "",
    "text": "Virtualization\nProgramming Languages and Design\nSoftware System Security"
  },
  {
    "objectID": "components/cs_compilertechnologies/description.html#competences",
    "href": "components/cs_compilertechnologies/description.html#competences",
    "title": "Module title",
    "section": "",
    "text": "describe paradigms and tools for the specification, development, and quality assurance of modern software systems, as well as their application in different contexts\nuse various approaches in programming languages and compiler technology"
  },
  {
    "objectID": "components/cs_compilertechnologies/description.html#examination-methods",
    "href": "components/cs_compilertechnologies/description.html#examination-methods",
    "title": "Module title",
    "section": "",
    "text": "either a written exam (90-100 minutes)\nor an oral examination (20-30 minutes)\nor a project report (20-30 pages)"
  },
  {
    "objectID": "components/cs_distributedsystems/description.html",
    "href": "components/cs_distributedsystems/description.html",
    "title": "Distributed Systems",
    "section": "",
    "text": "This module deals with distributed IT systems.\n\n\n\nThe module covers a selection of the following topics:\n\nReliability of distributed systems: Concepts of distributed file systems, synchronization techniques for reliable distributed applications, concepts of load balancing in high-availability clusters,\nExample: Sensor networks: Routing in sensor networks, operating systems for sensor networks, security in sensor networks,\nSecure internet protocols (IP security (IPsec), Pretty Good Privacy (PGP), Secure Socket Layer (SSL), Transport Layer Security (TLS), Secure Shell (SSH), DNS security (DNSsec)), secure IPv6 networks.\n\n\n\n\n\ncan evaluate existing distributed systems in terms of reliability and security and identify vulnerabilities.\ncan correctly identify reliability and security requirements when designing new distributed systems and consider them early in the development process.\n\n\n\n\n\neither 120 min written exam\nor 20-30 min oral examination"
  },
  {
    "objectID": "components/cs_distributedsystems/description.html#introduction",
    "href": "components/cs_distributedsystems/description.html#introduction",
    "title": "Distributed Systems",
    "section": "",
    "text": "This module deals with distributed IT systems."
  },
  {
    "objectID": "components/cs_distributedsystems/description.html#contents",
    "href": "components/cs_distributedsystems/description.html#contents",
    "title": "Distributed Systems",
    "section": "",
    "text": "The module covers a selection of the following topics:\n\nReliability of distributed systems: Concepts of distributed file systems, synchronization techniques for reliable distributed applications, concepts of load balancing in high-availability clusters,\nExample: Sensor networks: Routing in sensor networks, operating systems for sensor networks, security in sensor networks,\nSecure internet protocols (IP security (IPsec), Pretty Good Privacy (PGP), Secure Socket Layer (SSL), Transport Layer Security (TLS), Secure Shell (SSH), DNS security (DNSsec)), secure IPv6 networks."
  },
  {
    "objectID": "components/cs_distributedsystems/description.html#competences",
    "href": "components/cs_distributedsystems/description.html#competences",
    "title": "Distributed Systems",
    "section": "",
    "text": "can evaluate existing distributed systems in terms of reliability and security and identify vulnerabilities.\ncan correctly identify reliability and security requirements when designing new distributed systems and consider them early in the development process."
  },
  {
    "objectID": "components/cs_distributedsystems/description.html#examination-methods",
    "href": "components/cs_distributedsystems/description.html#examination-methods",
    "title": "Distributed Systems",
    "section": "",
    "text": "either 120 min written exam\nor 20-30 min oral examination"
  },
  {
    "objectID": "components/cs_formalmethods/description.html",
    "href": "components/cs_formalmethods/description.html",
    "title": "Formal Methods in Software Engineering",
    "section": "",
    "text": "This module covers advanced topics in Software Engineering with a focus on formal methods for specification, modeling, and verification.\n\n\n\nThe module includes the following topics:\n\nSoftware Quality Assurance: Formal methods for specifying and verifying system properties.\nService Engineering: The role of formal methods in service-based architectures.\nSystem Design: Use of formal methods in system design, focusing on specification and verification.\n\n\n\n\n\nUnderstand and apply formal methods in system design and software engineering.\nAnalyse theoretical and practical problems in modeling and implementation using formal methods.\n\n\n\n\n\nEither a 90-minute written exam.\nOr a 20-30 minute oral examination."
  },
  {
    "objectID": "components/cs_formalmethods/description.html#introduction",
    "href": "components/cs_formalmethods/description.html#introduction",
    "title": "Formal Methods in Software Engineering",
    "section": "",
    "text": "This module covers advanced topics in Software Engineering with a focus on formal methods for specification, modeling, and verification."
  },
  {
    "objectID": "components/cs_formalmethods/description.html#contents",
    "href": "components/cs_formalmethods/description.html#contents",
    "title": "Formal Methods in Software Engineering",
    "section": "",
    "text": "The module includes the following topics:\n\nSoftware Quality Assurance: Formal methods for specifying and verifying system properties.\nService Engineering: The role of formal methods in service-based architectures.\nSystem Design: Use of formal methods in system design, focusing on specification and verification."
  },
  {
    "objectID": "components/cs_formalmethods/description.html#competences",
    "href": "components/cs_formalmethods/description.html#competences",
    "title": "Formal Methods in Software Engineering",
    "section": "",
    "text": "Understand and apply formal methods in system design and software engineering.\nAnalyse theoretical and practical problems in modeling and implementation using formal methods."
  },
  {
    "objectID": "components/cs_formalmethods/description.html#examination-methods",
    "href": "components/cs_formalmethods/description.html#examination-methods",
    "title": "Formal Methods in Software Engineering",
    "section": "",
    "text": "Either a 90-minute written exam.\nOr a 20-30 minute oral examination."
  },
  {
    "objectID": "components/gen_datascience/statistic_data_analysis.html",
    "href": "components/gen_datascience/statistic_data_analysis.html",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "",
    "text": "This module focuses on the statistical study and quantitative analysis of the dependence between observed random variables (e.g., yield/production settings; lifespan/treatment type and injury type). Essential foundations for the statistical treatment of such relationships are provided by the linear regression model, which is studied in detail in the first part of the lecture. Within this framework, topics such as estimation, testing, and uncertainty quantification (analysis of variance) are addressed. In the second part, an introduction to advanced methods and approaches for examining relationships is offered, including nonlinear and nonparametric regression models. Additionally, questions of classification and dimensionality reduction are covered."
  },
  {
    "objectID": "components/gen_datascience/statistic_data_analysis.html#statistical-data-analysis",
    "href": "components/gen_datascience/statistic_data_analysis.html#statistical-data-analysis",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "",
    "text": "This module focuses on the statistical study and quantitative analysis of the dependence between observed random variables (e.g., yield/production settings; lifespan/treatment type and injury type). Essential foundations for the statistical treatment of such relationships are provided by the linear regression model, which is studied in detail in the first part of the lecture. Within this framework, topics such as estimation, testing, and uncertainty quantification (analysis of variance) are addressed. In the second part, an introduction to advanced methods and approaches for examining relationships is offered, including nonlinear and nonparametric regression models. Additionally, questions of classification and dimensionality reduction are covered."
  },
  {
    "objectID": "components/gen_programming/basics_programming.html",
    "href": "components/gen_programming/basics_programming.html",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "",
    "text": "Basics of Computer Science\n\nBasic Concepts\n\nIntroduction to computer science, basic concepts of operating systems using UNIX/Linux as an example\nFrom problem to algorithm: concept of an algorithm, design of algorithms, pseudocode, refinement, brute-force algorithms, models and modeling, graphs and their representation, simple algorithms on graphs, analysis of algorithms (correctness, termination, runtime)\nImplementation of algorithms (e.g., using Python)\nProgramming paradigms: procedural, object-oriented, and functional programming; recursion versus iteration\nFrom program to process: assembly languages, assembler, compiler, interpreter, syntax and semantics of programming languages\nLimits of algorithms: computability, decidability, undecidability"
  },
  {
    "objectID": "components/gen_softwareengineering/description.html",
    "href": "components/gen_softwareengineering/description.html",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "",
    "text": "To summarise the vast range of the skills a software engineer is typically equipped with, we refer to the Guide to the Software Engineering Body of Knowledge (Bourque, Fairley, and IEEE Computer Society 2014). Because research software engineering is an interface discipline, RSEs are often stronger in topics more commonly encountered in research software contexts (e.g., mathematical and engineering foundations) than in other areas (e.g., software engineering economics). However, they bring a solid level of competence in all software engineering topics. Therefore, RSEs can set and analyse software requirements in the context of open-ended, question-driven research. They can design software so that it can sustainably grow, often in an environment of rapid turnover of contributors. They are competent in implementing solutions themselves in a wide range of technologies fit for different scientific applications. They can formulate and implement various types of tests, they can independently maintain software and automate operations of the integration and release process. They can provide working, scalable, and future-proof solutions in a professional context and with common project and software management techniques, adapted to the needs of the research environment. Finally, as people who have often gained significant research experience in a particular discipline, they combine the necessary foundations from their domain with software engineering skills to develop complex software.(Goth et al. 2024)\nThis module tries to lay the foundations for the advanced RSE software engineering training.\n\n\nBourque, Pierre, Richard E. Fairley, and IEEE Computer Society. 2014. Guide to the Software Engineering Body of Knowledge (SWEBOK(R)): Version 3.0. 3rd ed. Washington, DC, USA: IEEE Computer Society Press.\n\n\nGoth, F, R Alves, M Braun, LJ Castro, G Chourdakis, S Christ, J Cohen, et al. 2024. “Foundational Competencies and Responsibilities of a Research Software Engineer [Version 1; Peer Review: Awaiting Peer Review].” F1000Research 13 (1429). https://doi.org/10.12688/f1000research.157778.1."
  },
  {
    "objectID": "components/gen_softwareengineering/description.html#classical-software-engineering",
    "href": "components/gen_softwareengineering/description.html#classical-software-engineering",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "",
    "text": "To summarise the vast range of the skills a software engineer is typically equipped with, we refer to the Guide to the Software Engineering Body of Knowledge (Bourque, Fairley, and IEEE Computer Society 2014). Because research software engineering is an interface discipline, RSEs are often stronger in topics more commonly encountered in research software contexts (e.g., mathematical and engineering foundations) than in other areas (e.g., software engineering economics). However, they bring a solid level of competence in all software engineering topics. Therefore, RSEs can set and analyse software requirements in the context of open-ended, question-driven research. They can design software so that it can sustainably grow, often in an environment of rapid turnover of contributors. They are competent in implementing solutions themselves in a wide range of technologies fit for different scientific applications. They can formulate and implement various types of tests, they can independently maintain software and automate operations of the integration and release process. They can provide working, scalable, and future-proof solutions in a professional context and with common project and software management techniques, adapted to the needs of the research environment. Finally, as people who have often gained significant research experience in a particular discipline, they combine the necessary foundations from their domain with software engineering skills to develop complex software.(Goth et al. 2024)\nThis module tries to lay the foundations for the advanced RSE software engineering training.\n\n\nBourque, Pierre, Richard E. Fairley, and IEEE Computer Society. 2014. Guide to the Software Engineering Body of Knowledge (SWEBOK(R)): Version 3.0. 3rd ed. Washington, DC, USA: IEEE Computer Society Press.\n\n\nGoth, F, R Alves, M Braun, LJ Castro, G Chourdakis, S Christ, J Cohen, et al. 2024. “Foundational Competencies and Responsibilities of a Research Software Engineer [Version 1; Peer Review: Awaiting Peer Review].” F1000Research 13 (1429). https://doi.org/10.12688/f1000research.157778.1."
  },
  {
    "objectID": "components/gen_softwareengineering/se2.html",
    "href": "components/gen_softwareengineering/se2.html",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "",
    "text": "The module covers a selection of advanced topics in the field of software engineering, such as software quality assurance, service engineering, virtualization, programming languages and design, and formal methods in system design."
  },
  {
    "objectID": "components/gen_softwareengineering/se2.html#software-engineering-2",
    "href": "components/gen_softwareengineering/se2.html#software-engineering-2",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "",
    "text": "The module covers a selection of advanced topics in the field of software engineering, such as software quality assurance, service engineering, virtualization, programming languages and design, and formal methods in system design."
  },
  {
    "objectID": "components/mnt_project/description.html",
    "href": "components/mnt_project/description.html",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "",
    "text": "Applied Research Software Engineering in MINT Sciences\nThis lab module provides students with a hands-on opportunity to apply research software engineering principles to real-world scientific problems from the MINT disciplines (Mathematics, Informatics, Natural Sciences, and Technology). Students work on projects originating from active research contexts — such as simulations in physics, data analysis in chemistry, modeling in biology, or"
  },
  {
    "objectID": "components/mnt_project/description.html#science-lab-module",
    "href": "components/mnt_project/description.html#science-lab-module",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "",
    "text": "Applied Research Software Engineering in MINT Sciences\nThis lab module provides students with a hands-on opportunity to apply research software engineering principles to real-world scientific problems from the MINT disciplines (Mathematics, Informatics, Natural Sciences, and Technology). Students work on projects originating from active research contexts — such as simulations in physics, data analysis in chemistry, modeling in biology, or"
  },
  {
    "objectID": "components/rse_computing/description.html",
    "href": "components/rse_computing/description.html",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "",
    "text": "RSEs with expertise in HPC and other performance-critical computing domains specialize in optimizing code for efficient execution across various platforms, including clusters, cloud, edge, and embedded systems. They understand parallel programming models, hardware-specific optimizations, profiling tools, and platform constraints such as memory, energy, and latency. Their skills enable them to adapt software to diverse infrastructures, manage complex dependencies, and support researchers in accessing and using advanced computing resources effectively and sustainably."
  },
  {
    "objectID": "components/rse_computing/description.html#rse-computing",
    "href": "components/rse_computing/description.html#rse-computing",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "",
    "text": "RSEs with expertise in HPC and other performance-critical computing domains specialize in optimizing code for efficient execution across various platforms, including clusters, cloud, edge, and embedded systems. They understand parallel programming models, hardware-specific optimizations, profiling tools, and platform constraints such as memory, energy, and latency. Their skills enable them to adapt software to diverse infrastructures, manage complex dependencies, and support researchers in accessing and using advanced computing resources effectively and sustainably."
  },
  {
    "objectID": "components/rse_computing/scientific_computing.html",
    "href": "components/rse_computing/scientific_computing.html",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "",
    "text": "Basic Scientific Computing\n\nModule Overview\nThis module provides an entry‑level yet rigorous foundation in scientific computing for graduate students and researchers who need to design, implement, and evaluate computational experiments. Learners gain an awareness of the numerical underpinnings of modern simulation and data‑driven research, with an emphasis on writing reproducible, efficient, and trustworthy code.\n\n\nIntended Learning Outcomes\nBy the end of the module participants will be able to\n\nBenchmark small programs and interpret performance metrics in a research context.\nExplain how approximation theory and floating‑point arithmetic affect numerical accuracy and stability.\nIdentify when to use established simulation libraries (e.g. BLAS/LAPACK, PETSc, Trilinos) instead of custom code.\nWrite simple GPU kernels and describe the core principles of accelerator programming.\nSubmit and monitor batch & array jobs on a mid‑size compute cluster.\nDescribe common HPC challenges—such as I/O bottlenecks, threading, and NUMA—and propose mitigation strategies.\nMaintain research software through continuous benchmarking.\n\n\n\nSyllabus (Indicative Content)\n\n\n\n\n\n\n\n\nWeek\nTheme\nTopics\n\n\n\n\n1\nBenchmarking & Profiling\nTiming strategies · micro vs. macro benchmarks · tooling overview\n\n\n2\nPrecision & Approximation\nIEEE‑754 recap · conditioning & stability · error propagation\n\n\n3\nScientific Libraries\nBLAS/LAPACK anatomy · hierarchical I/O libraries · overview of PETSc/Trilinos/Hypre\n\n\n4\nGPU Primer\nKernel model · memory hierarchy · CUDA/OpenCL/PyTorch lightning intro\n\n\n5\nWorking on a Cluster\nSlurm basics · job arrays · job dependencies · simple Bash launchers\n\n\n6\nHPC Pitfalls\nI/O throughput · thread oversubscription · NUMA awareness\n\n\n7\nSoftware Maintenance\nRegression + performance tests · continuous benchmarking pipelines\n\n\n\n\n\nTeaching & Learning Methods\nShort lectures (30%) are coupled with hands‑on labs (70%). Students complete weekly notebooks and a mini‑project that reproduces and optimises a published computational result.\n\n\nAssessment\n\n\n\nComponent\nWeight\nDetails\n\n\n\n\nContinuous labs\n40%\nWeekly graded notebooks\n\n\nFinal mini‑project\n60%\nReport, code, and benchmark suite\n\n\n\n\n\nPrerequisites\n\nBasic programming in Python, C/C++, or Julia\nUndergraduate calculus & linear algebra\n\n\n\nKey Resources\nChatGPT fantasy"
  },
  {
    "objectID": "components/rse_missingsemester/description.html",
    "href": "components/rse_missingsemester/description.html",
    "title": "RSE Nuts and Bolts",
    "section": "",
    "text": "This module, inspired by the MIT Missing Semester, addresses the “nuts and bolts” often missing from traditional academic training in computing. It aims to provide students with practical skills and conceptual understanding for building robust, maintainable, and reproducible research software—key competencies in Research Software Engineering (RSE).\n\n\n\nThe module begins with general-purpose computing tools and techniques that are foundational for any research software engineer:\n\nShell tools and scripting\nCommand-line environments\nEditors and IDEs (e.g., Vim)\nVersion control (Git)\nData wrangling\nDebugging and profiling\nMetaprogramming\nSecurity and cryptography\n\n\n\n\nBuilding on these foundations, the module introduces RSE-specific concepts and good practices:\n\nVersion control and collaboration\n\nGit for code history, collaboration, and issue tracking\n\nVirtualization concepts\n\nContainerization and environment management\n\nThe Data Life Cycle\n\nManaging research data and understanding data provenance\n\nGood coding practices\n\nReproducible and testable code\nMeaningful documentation and error messages\nModular software design\nPerformance-conscious coding\nEasily installable and distributable software\nCoding standards, formatting, and linting\n\nSoftware management planning\n\nWriting Data and Software Management Plans\nSustainable development and community involvement\n\nLow-level programming\n\nIntroduction to a compiled language (e.g., C) to expose hardware-level concerns and efficient memory management\n\nLong-term software maintenance\n\nVersion tracking, bug management, and sustainability strategies\nBuilding and maintaining research software communities\n\n\n\n\n\nFinally, the module touches on practices that support the scholarly nature of research software:\n\nSoftware publication and citation (see SP in (Goth et al. 2024))\nUse of domain-specific repositories and registries (see DOMREP in (Goth et al. 2024))\n\nBy the end of this module, students will be well-equipped to design, develop, document, and maintain research software that meets high standards of quality, sustainability, and reproducibility.\nThe module is made up of two seminars that the students take at different stages in their master’s program: In the first seminar during their first semester, students mainly learn new concepts and get to know essential tools, whereas the second seminar in the third semester focuses on teaching others about research software and the development process of it (see TEACH in (Goth et al. 2024))."
  },
  {
    "objectID": "components/rse_missingsemester/description.html#introduction",
    "href": "components/rse_missingsemester/description.html#introduction",
    "title": "RSE Nuts and Bolts",
    "section": "",
    "text": "This module, inspired by the MIT Missing Semester, addresses the “nuts and bolts” often missing from traditional academic training in computing. It aims to provide students with practical skills and conceptual understanding for building robust, maintainable, and reproducible research software—key competencies in Research Software Engineering (RSE)."
  },
  {
    "objectID": "components/rse_missingsemester/description.html#general-competencies",
    "href": "components/rse_missingsemester/description.html#general-competencies",
    "title": "RSE Nuts and Bolts",
    "section": "",
    "text": "The module begins with general-purpose computing tools and techniques that are foundational for any research software engineer:\n\nShell tools and scripting\nCommand-line environments\nEditors and IDEs (e.g., Vim)\nVersion control (Git)\nData wrangling\nDebugging and profiling\nMetaprogramming\nSecurity and cryptography"
  },
  {
    "objectID": "components/rse_missingsemester/description.html#rse-specific-topics",
    "href": "components/rse_missingsemester/description.html#rse-specific-topics",
    "title": "RSE Nuts and Bolts",
    "section": "",
    "text": "Building on these foundations, the module introduces RSE-specific concepts and good practices:\n\nVersion control and collaboration\n\nGit for code history, collaboration, and issue tracking\n\nVirtualization concepts\n\nContainerization and environment management\n\nThe Data Life Cycle\n\nManaging research data and understanding data provenance\n\nGood coding practices\n\nReproducible and testable code\nMeaningful documentation and error messages\nModular software design\nPerformance-conscious coding\nEasily installable and distributable software\nCoding standards, formatting, and linting\n\nSoftware management planning\n\nWriting Data and Software Management Plans\nSustainable development and community involvement\n\nLow-level programming\n\nIntroduction to a compiled language (e.g., C) to expose hardware-level concerns and efficient memory management\n\nLong-term software maintenance\n\nVersion tracking, bug management, and sustainability strategies\nBuilding and maintaining research software communities"
  },
  {
    "objectID": "components/rse_missingsemester/description.html#beyond-the-basics",
    "href": "components/rse_missingsemester/description.html#beyond-the-basics",
    "title": "RSE Nuts and Bolts",
    "section": "",
    "text": "Finally, the module touches on practices that support the scholarly nature of research software:\n\nSoftware publication and citation (see SP in (Goth et al. 2024))\nUse of domain-specific repositories and registries (see DOMREP in (Goth et al. 2024))\n\nBy the end of this module, students will be well-equipped to design, develop, document, and maintain research software that meets high standards of quality, sustainability, and reproducibility.\nThe module is made up of two seminars that the students take at different stages in their master’s program: In the first seminar during their first semester, students mainly learn new concepts and get to know essential tools, whereas the second seminar in the third semester focuses on teaching others about research software and the development process of it (see TEACH in (Goth et al. 2024))."
  },
  {
    "objectID": "components/rse_theory/description.html",
    "href": "components/rse_theory/description.html",
    "title": "RSE Philosophy",
    "section": "",
    "text": "The RSE master program is more than a computer science specialisation for researchers. People working as RSE are often involved in digitalization projects, institutional development or other non-technical tasks.\n\n\n\nFor a university level study program it is fitting that students learn an abstract high-level understanding of their field so that they can adapt technical models, communication frameworks and policy recommendations to the complex cases. For this they need a solid understanding in some of the more theoretical fields such as …\n\nphilosophy of science\nsociology of technology\nethics and artificial intelligence\nhuman computer interaction\ndigital humanities\n\n\n\n\nThis module conveys competences in areas such as but not limited to …\n\nconducting and leading research (NEW)\nunderstanding the research cycle (RC)\ninteraction with users and stakeholders (USERS)"
  },
  {
    "objectID": "components/rse_theory/description.html#introduction",
    "href": "components/rse_theory/description.html#introduction",
    "title": "RSE Philosophy",
    "section": "",
    "text": "The RSE master program is more than a computer science specialisation for researchers. People working as RSE are often involved in digitalization projects, institutional development or other non-technical tasks."
  },
  {
    "objectID": "components/rse_theory/description.html#contents",
    "href": "components/rse_theory/description.html#contents",
    "title": "RSE Philosophy",
    "section": "",
    "text": "For a university level study program it is fitting that students learn an abstract high-level understanding of their field so that they can adapt technical models, communication frameworks and policy recommendations to the complex cases. For this they need a solid understanding in some of the more theoretical fields such as …\n\nphilosophy of science\nsociology of technology\nethics and artificial intelligence\nhuman computer interaction\ndigital humanities"
  },
  {
    "objectID": "components/rse_theory/description.html#general-competences",
    "href": "components/rse_theory/description.html#general-competences",
    "title": "RSE Philosophy",
    "section": "",
    "text": "This module conveys competences in areas such as but not limited to …\n\nconducting and leading research (NEW)\nunderstanding the research cycle (RC)\ninteraction with users and stakeholders (USERS)"
  },
  {
    "objectID": "event/kickoff-workshops/schedule.html",
    "href": "event/kickoff-workshops/schedule.html",
    "title": "Preliminary Schedule for RSE Community Workshops",
    "section": "",
    "text": "Preliminary Schedule for RSE Community Workshops\nAll times are in Berlin time (CEST).\nSign in here for the workshops.\nAll the workshops will take place in the regular deRSE zoom. Contact julian.dehne@gi.de for the access details."
  },
  {
    "objectID": "general/glossary.html",
    "href": "general/glossary.html",
    "title": "Glossary",
    "section": "",
    "text": "Glossary\nC A general-purpose programming language often used for system-level development.\nCpp C++ — an extension of C that supports object-oriented programming.\nDIST Software distribution — the practice of packaging and delivering software and its dependencies.\nDOCBB Documentation and best practices — ensuring code is understandable and maintainable.\nDOMREP Domain repositories — platforms that store and share domain-specific research data.\nHPC High-Performance Computing — using supercomputers and parallel processing for complex tasks.\nMOD Modularity — the design principle of separating software into interchangeable, functional components.\nNEW Novel research — work that contributes original insights to a scientific domain.\nPM Project Management — planning, executing, and overseeing projects effectively.\nPython A high-level programming language widely used in data science and scripting.\nR A programming language and environment for statistical computing and graphics.\nRSE Research Software Engineer — someone who applies software engineering skills to scientific research.\nSP Software publication — the process of preparing and disseminating software artifacts.\nSRU Software reuse — the practice of using existing software components in new projects.\nSTEM Science, Technology, Engineering, and Mathematics.\nSWREPOS Software repositories — systems for storing and managing software code and versions.\nTEAM Teamwork — the ability to collaborate effectively in a group setting.\nTEACH Teaching — the skill of communicating knowledge and helping others learn.\nUSERS End users — the scientists or researchers who rely on software tools."
  },
  {
    "objectID": "general/job_roles.html",
    "href": "general/job_roles.html",
    "title": "Possible Job Roles for an RSE",
    "section": "",
    "text": "Open science and FAIRness of data and software are increasingly important topics in research, as exemplified by the demand of an increasing amount of research funding agencies requiring openness. Hence, an Open Science RSE is required to have a deeper knowledge in Research Culture (RC) and how to distribute software publicly (Software Reusability (SRU), Software Publication (SP)). Open Science RSEs can help researchers navigate the technical questions that come up when practising Open Science, such as:\n\n“How do I make my code presentable?”\n“How do I make my code citable?”\n“What do I need to do to make my software FAIR?”\n“How do I sustainably work with an (international) team on a large code base?”\n\nLike the Data-focused RSE, they have a deep understanding of Research Data Management (RDM) topics.\n\n\n\nWhen research software projects become larger, they need someone who manages processes and people. In practice, this concerns change management for code and documentation, and community work to safeguard usability and adaptability, but also handling project governance and scalable decision-making processes. This gap can be filled by people who invest in the Project Management (PM), User Support (USERS), and Team Management (TEAM) skills.\nBuilding a community around a research project is an important building block in building sustainable software (Segal 2009), so these RSEs play an important role, even if they do not necessarily touch much of the code themselves.\n\n\n\nRSEs interested in developing their Teaching (TEACH) skill can focus on teaching the next generation of researchers and/or RSEs and will play a vital role in improving the quality of research software. They need to have a good understanding of all RSE competencies relevant to their domain and additionally should have experience or training in the educational field.\n\n\n\nScientific software is a complex product that often needs to be refined in order to be usable even by other scientists. To facilitate this, there are people required that specialise in the Documentation & Best Practices (DOCBB) and probably the Distribution (DIST) competency with a focus on making end-user-facing software really reusable and hence FAIR. This task is supported by strong Modelling (MOD) skills to reason about the behaviour of potential users of the software."
  },
  {
    "objectID": "general/job_roles.html#open-science-rse",
    "href": "general/job_roles.html#open-science-rse",
    "title": "Possible Job Roles for an RSE",
    "section": "",
    "text": "Open science and FAIRness of data and software are increasingly important topics in research, as exemplified by the demand of an increasing amount of research funding agencies requiring openness. Hence, an Open Science RSE is required to have a deeper knowledge in Research Culture (RC) and how to distribute software publicly (Software Reusability (SRU), Software Publication (SP)). Open Science RSEs can help researchers navigate the technical questions that come up when practising Open Science, such as:\n\n“How do I make my code presentable?”\n“How do I make my code citable?”\n“What do I need to do to make my software FAIR?”\n“How do I sustainably work with an (international) team on a large code base?”\n\nLike the Data-focused RSE, they have a deep understanding of Research Data Management (RDM) topics."
  },
  {
    "objectID": "general/job_roles.html#projectcommunity-manager-rses",
    "href": "general/job_roles.html#projectcommunity-manager-rses",
    "title": "Possible Job Roles for an RSE",
    "section": "",
    "text": "When research software projects become larger, they need someone who manages processes and people. In practice, this concerns change management for code and documentation, and community work to safeguard usability and adaptability, but also handling project governance and scalable decision-making processes. This gap can be filled by people who invest in the Project Management (PM), User Support (USERS), and Team Management (TEAM) skills.\nBuilding a community around a research project is an important building block in building sustainable software (Segal 2009), so these RSEs play an important role, even if they do not necessarily touch much of the code themselves."
  },
  {
    "objectID": "general/job_roles.html#teaching-rses",
    "href": "general/job_roles.html#teaching-rses",
    "title": "Possible Job Roles for an RSE",
    "section": "",
    "text": "RSEs interested in developing their Teaching (TEACH) skill can focus on teaching the next generation of researchers and/or RSEs and will play a vital role in improving the quality of research software. They need to have a good understanding of all RSE competencies relevant to their domain and additionally should have experience or training in the educational field."
  },
  {
    "objectID": "general/job_roles.html#user-interfaceuser-experience-designers-for-research-software",
    "href": "general/job_roles.html#user-interfaceuser-experience-designers-for-research-software",
    "title": "Possible Job Roles for an RSE",
    "section": "",
    "text": "Scientific software is a complex product that often needs to be refined in order to be usable even by other scientists. To facilitate this, there are people required that specialise in the Documentation & Best Practices (DOCBB) and probably the Distribution (DIST) competency with a focus on making end-user-facing software really reusable and hence FAIR. This task is supported by strong Modelling (MOD) skills to reason about the behaviour of potential users of the software."
  },
  {
    "objectID": "generation/generated/cs_compilertechnologies.html",
    "href": "generation/generated/cs_compilertechnologies.html",
    "title": "Module title",
    "section": "",
    "text": "This module provides an in-depth understanding of programming languages and compiler technology. Topics covered include lexical analysis, syntax parsing, code generation, and optimisation techniques for compilers. The course includes both theoretical lectures and practical exercises, culminating in a project where students will build a simple compiler.\n\n\n\n\nVirtualization\nProgramming Languages and Design\nSoftware System Security\n\n\n\n\n\ndescribe paradigms and tools for the specification, development, and quality assurance of modern software systems, as well as their application in different contexts\nuse various approaches in programming languages and compiler technology\n\n\n\n\n\neither a written exam (90-100 minutes)\nor an oral examination (20-30 minutes)\nor a project report (20-30 pages)\n\nLecture: Programming Languages and Compiler Technologies\nSWS: 2 ECTS: 2\nProject: Programming Languages and Compiler Technologies Project\nSWS: 2 ECTS: 4\n\n\n\n\n\n\nID\nDescription\nDisciplines\nPrerequisites\nEvidence\nAuthor\nSource\n\n\n\n\ncompiler_tech_1\napply modelling techniques\nComputer Science\n\ndevelop solutions through technical methods\nUniversity of Potsdam\nLink\n\n\ncompiler_tech_2\nanalyse problems in given software systems\nComputer Science\n\ndiscuss problems in a team\nUniversity of Potsdam\nLink\n\n\n\n\n\n\n\n\n\nNone\n\n\n\n\n\nUP Programmiersprachen und Compilertechnologien\n\n\n\n\n\nTODO\n\n\n\n\n\nUP Computational Science Master"
  },
  {
    "objectID": "generation/generated/cs_compilertechnologies.html#introduction",
    "href": "generation/generated/cs_compilertechnologies.html#introduction",
    "title": "Module title",
    "section": "",
    "text": "This module provides an in-depth understanding of programming languages and compiler technology. Topics covered include lexical analysis, syntax parsing, code generation, and optimisation techniques for compilers. The course includes both theoretical lectures and practical exercises, culminating in a project where students will build a simple compiler."
  },
  {
    "objectID": "generation/generated/cs_compilertechnologies.html#contents",
    "href": "generation/generated/cs_compilertechnologies.html#contents",
    "title": "Module title",
    "section": "",
    "text": "Virtualization\nProgramming Languages and Design\nSoftware System Security"
  },
  {
    "objectID": "generation/generated/cs_compilertechnologies.html#competences",
    "href": "generation/generated/cs_compilertechnologies.html#competences",
    "title": "Module title",
    "section": "",
    "text": "describe paradigms and tools for the specification, development, and quality assurance of modern software systems, as well as their application in different contexts\nuse various approaches in programming languages and compiler technology"
  },
  {
    "objectID": "generation/generated/cs_compilertechnologies.html#examination-methods",
    "href": "generation/generated/cs_compilertechnologies.html#examination-methods",
    "title": "Module title",
    "section": "",
    "text": "either a written exam (90-100 minutes)\nor an oral examination (20-30 minutes)\nor a project report (20-30 pages)\n\nLecture: Programming Languages and Compiler Technologies\nSWS: 2 ECTS: 2\nProject: Programming Languages and Compiler Technologies Project\nSWS: 2 ECTS: 4"
  },
  {
    "objectID": "generation/generated/cs_compilertechnologies.html#module-competences",
    "href": "generation/generated/cs_compilertechnologies.html#module-competences",
    "title": "Module title",
    "section": "",
    "text": "ID\nDescription\nDisciplines\nPrerequisites\nEvidence\nAuthor\nSource\n\n\n\n\ncompiler_tech_1\napply modelling techniques\nComputer Science\n\ndevelop solutions through technical methods\nUniversity of Potsdam\nLink\n\n\ncompiler_tech_2\nanalyse problems in given software systems\nComputer Science\n\ndiscuss problems in a team\nUniversity of Potsdam\nLink"
  },
  {
    "objectID": "generation/generated/cs_compilertechnologies.html#sources-implementations",
    "href": "generation/generated/cs_compilertechnologies.html#sources-implementations",
    "title": "Module title",
    "section": "",
    "text": "None\n\n\n\n\n\nUP Programmiersprachen und Compilertechnologien\n\n\n\n\n\nTODO\n\n\n\n\n\nUP Computational Science Master"
  },
  {
    "objectID": "generation/generated/cs_example.html",
    "href": "generation/generated/cs_example.html",
    "title": "Module title",
    "section": "",
    "text": "This is an example module to showcase the integration pipeline\n\n\n\n\ndsfd\n\n\n\n\n\ndfsd\n\n\n\n\n\nEither a 90-minute written exam.\nOr a 20-30 minute oral examination.\n\nLecture: …\nSWS: 2 ECTS: 2\nExercise: … Exercise\nSWS: 2 ECTS: 4\n\n\n\n\n\n\nID\nDescription\nDisciplines\nPrerequisites\nEvidence\nAuthor\nSource\n\n\n\n\ndist_systems_1\nUse\nComputer Science\n\nSubmit working programs in …\nUniversity of Potsdam\nLink\n\n\n\n\n\n\n\n\n\nNone\n\n\n\n\n\nUP Verteilte Systeme\n\n\n\n\n\nTODO\n\n\n\n\n\nUP Computational Science Master"
  },
  {
    "objectID": "generation/generated/cs_example.html#introduction",
    "href": "generation/generated/cs_example.html#introduction",
    "title": "Module title",
    "section": "",
    "text": "This is an example module to showcase the integration pipeline"
  },
  {
    "objectID": "generation/generated/cs_example.html#contents",
    "href": "generation/generated/cs_example.html#contents",
    "title": "Module title",
    "section": "",
    "text": "dsfd"
  },
  {
    "objectID": "generation/generated/cs_example.html#competences",
    "href": "generation/generated/cs_example.html#competences",
    "title": "Module title",
    "section": "",
    "text": "dfsd"
  },
  {
    "objectID": "generation/generated/cs_example.html#examination-methods",
    "href": "generation/generated/cs_example.html#examination-methods",
    "title": "Module title",
    "section": "",
    "text": "Either a 90-minute written exam.\nOr a 20-30 minute oral examination.\n\nLecture: …\nSWS: 2 ECTS: 2\nExercise: … Exercise\nSWS: 2 ECTS: 4"
  },
  {
    "objectID": "generation/generated/cs_example.html#module-competences",
    "href": "generation/generated/cs_example.html#module-competences",
    "title": "Module title",
    "section": "",
    "text": "ID\nDescription\nDisciplines\nPrerequisites\nEvidence\nAuthor\nSource\n\n\n\n\ndist_systems_1\nUse\nComputer Science\n\nSubmit working programs in …\nUniversity of Potsdam\nLink"
  },
  {
    "objectID": "generation/generated/cs_example.html#sources-implementations",
    "href": "generation/generated/cs_example.html#sources-implementations",
    "title": "Module title",
    "section": "",
    "text": "None\n\n\n\n\n\nUP Verteilte Systeme\n\n\n\n\n\nTODO\n\n\n\n\n\nUP Computational Science Master"
  },
  {
    "objectID": "generation/generated/cs_securitycomplexity.html",
    "href": "generation/generated/cs_securitycomplexity.html",
    "title": "Security, Information and Complexity",
    "section": "",
    "text": "This module deals with correctness, security and complexity of algorithms.\n\n\n\n\nMethods for secure and reliable transmission and processing of information, error-correcting coding methods\nFundamentals of cryptographic systems, methods for information analysis, complexity aspects, applications\nNecessary foundations of mathematics and complexity theory are introduced alongside the topics\n\n\n\n\n\nUnderstand the mathematical foundations of secure and reliable information processing and their complexity-theoretical basis.\nAre familiar with the fundamentals of error-protected transmission and storage of data.\nAre capable of analysing the correctness, security, and complexity of methods\n\n\n\n\n\nEither a written exam (90 minutes).\nOr an oral examination (30 minutes).\n\nLecture: Security, Information and Complexity\nSWS: 2 ECTS: 2\nExercise: Security, Information and Complexity Exercise\nSWS: 2 ECTS: 4\n\n\n\n\n\n\nID\nDescription\nDisciplines\nPrerequisites\nEvidence\nAuthor\nSource\n\n\n\n\nsec_complex_1\nexplain the necessity and methods of error-protected transmission and storage of data\nComputer Science\n\ndescribe and apply the taught methods to given examples\nUniversity of Potsdam\nLink\n\n\nsec_complex_2\nanalyse the correctness, security and complexity of algorithms\nComputer Science\n\nSubmit a written analysis for a given algorithm\nUniversity of Potsdam\nLink\n\n\n\n\n\n\n\n\n\nNone\n\n\n\n\n\nUP Sicherheit, Information und Komplexität\n\n\n\n\n\nTODO\n\n\n\n\n\nUP Computational Science Master"
  },
  {
    "objectID": "generation/generated/cs_securitycomplexity.html#introduction",
    "href": "generation/generated/cs_securitycomplexity.html#introduction",
    "title": "Security, Information and Complexity",
    "section": "",
    "text": "This module deals with correctness, security and complexity of algorithms."
  },
  {
    "objectID": "generation/generated/cs_securitycomplexity.html#contents",
    "href": "generation/generated/cs_securitycomplexity.html#contents",
    "title": "Security, Information and Complexity",
    "section": "",
    "text": "Methods for secure and reliable transmission and processing of information, error-correcting coding methods\nFundamentals of cryptographic systems, methods for information analysis, complexity aspects, applications\nNecessary foundations of mathematics and complexity theory are introduced alongside the topics"
  },
  {
    "objectID": "generation/generated/cs_securitycomplexity.html#competences",
    "href": "generation/generated/cs_securitycomplexity.html#competences",
    "title": "Security, Information and Complexity",
    "section": "",
    "text": "Understand the mathematical foundations of secure and reliable information processing and their complexity-theoretical basis.\nAre familiar with the fundamentals of error-protected transmission and storage of data.\nAre capable of analysing the correctness, security, and complexity of methods"
  },
  {
    "objectID": "generation/generated/cs_securitycomplexity.html#examination-methods",
    "href": "generation/generated/cs_securitycomplexity.html#examination-methods",
    "title": "Security, Information and Complexity",
    "section": "",
    "text": "Either a written exam (90 minutes).\nOr an oral examination (30 minutes).\n\nLecture: Security, Information and Complexity\nSWS: 2 ECTS: 2\nExercise: Security, Information and Complexity Exercise\nSWS: 2 ECTS: 4"
  },
  {
    "objectID": "generation/generated/cs_securitycomplexity.html#module-competences",
    "href": "generation/generated/cs_securitycomplexity.html#module-competences",
    "title": "Security, Information and Complexity",
    "section": "",
    "text": "ID\nDescription\nDisciplines\nPrerequisites\nEvidence\nAuthor\nSource\n\n\n\n\nsec_complex_1\nexplain the necessity and methods of error-protected transmission and storage of data\nComputer Science\n\ndescribe and apply the taught methods to given examples\nUniversity of Potsdam\nLink\n\n\nsec_complex_2\nanalyse the correctness, security and complexity of algorithms\nComputer Science\n\nSubmit a written analysis for a given algorithm\nUniversity of Potsdam\nLink"
  },
  {
    "objectID": "generation/generated/cs_securitycomplexity.html#sources-implementations",
    "href": "generation/generated/cs_securitycomplexity.html#sources-implementations",
    "title": "Security, Information and Complexity",
    "section": "",
    "text": "None\n\n\n\n\n\nUP Sicherheit, Information und Komplexität\n\n\n\n\n\nTODO\n\n\n\n\n\nUP Computational Science Master"
  },
  {
    "objectID": "generation/generated/gen_datascience.html",
    "href": "generation/generated/gen_datascience.html",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "",
    "text": "Lecture: Mathematical Foundations of Data Science The module provides mathematical foundations in the field of Data Science. Topics include a selection from the areas of graph analysis, stochastic models, and signal analysis using wavelets. SWS: 4 ECTS: 6"
  },
  {
    "objectID": "generation/generated/gen_datascience.html#statistical-data-analysis",
    "href": "generation/generated/gen_datascience.html#statistical-data-analysis",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "Statistical Data Analysis",
    "text": "Statistical Data Analysis\nThis module focuses on the statistical study and quantitative analysis of the dependence between observed random variables (e.g., yield/production settings; lifespan/treatment type and injury type). Essential foundations for the statistical treatment of such relationships are provided by the linear regression model, which is studied in detail in the first part of the lecture. Within this framework, topics such as estimation, testing, and uncertainty quantification (analysis of variance) are addressed. In the second part, an introduction to advanced methods and approaches for examining relationships is offered, including nonlinear and nonparametric regression models. Additionally, questions of classification and dimensionality reduction are covered.\nLecture: Statistical Data Analysis\nSWS: 4 ECTS: 4\nExercise: Data-oriented Programming\nSWS: 4 ECTS: 6\nExercise: Text2Data\nSWS: 4 ECTS: 4"
  },
  {
    "objectID": "generation/generated/gen_datascience.html#module-competences",
    "href": "generation/generated/gen_datascience.html#module-competences",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "Module Competences",
    "text": "Module Competences\n\n\n\nID\nDescription\nDisciplines\nPrerequisites\nEvidence\nAuthor\nSource\n\n\n\n\ngen_datascience_1\nPossess comprehensive, detailed, and specialized knowledge of selected fundamentals in the field of Data Science\nData Science\n\nDemonstrate knowledge through theoretical exams and practical assignments\nUniversity of Potsdam\nLink\n\n\ngen_datascience_2\nDemonstrate an in-depth understanding of selected Data Science methods\nData Science\ngen_datascience_1\nApply Data Science methods in practical projects and case studies\nUniversity of Potsdam\nLink\n\n\ngen_datascience_3\nAnalyze novel data assimilation and inference problems, develop and implement solutions, and assess solution quality\nData Science\ngen_datascience_2\nSolve complex inference problems and present implemented solutions with evaluation\nUniversity of Potsdam\nLink\n\n\ngen_datascience_4\nDevelop new ideas and methods, weigh alternatives under incomplete information, and evaluate them considering different evaluation criteria\nData Science\ngen_datascience_2\nPresent projects showcasing creative problem-solving and alternative evaluations under uncertainty\nUniversity of Potsdam\nLink\n\n\ngen_statistics_1\nPossess comprehensive, detailed, and specialized understanding of the linear regression model based on the latest research\nData Science, Statistics\n\nApply linear regression models to practical problems and interpret results\nUniversity of Potsdam\nLink\n\n\ngen_statistics_2\nUnderstand fundamental concepts and methods of nonparametric statistics\nData Science, Statistics\ngen_statistics_1\nSolve problems involving nonparametric methods and explain applied techniques\nUniversity of Potsdam\nLink\n\n\ngen_statistics_3\nSolve complex statistical data analysis problems, evaluate alternative modeling approaches according to various criteria, and use statistical software packages for analysis\nData Science, Statistics\ngen_statistics_2\nDevelop solutions for complex data problems using appropriate statistical methods and software\nUniversity of Potsdam\nLink\n\n\ngen_statistics_4\nDemonstrate academic competences including self-organization, planning skills (identifying work steps), scientific thinking and working techniques (developing solutions for complex questions), discussion of methods, verification of hypotheses, application of mathematical and statistical methods, and use of software packages\nData Science, Statistics\ngen_statistics_2\nDocument project workflows demonstrating planning, analysis, evaluation, and use of statistical software tools\nUniversity of Potsdam\nLink"
  },
  {
    "objectID": "generation/generated/gen_datascience.html#sources-implementations",
    "href": "generation/generated/gen_datascience.html#sources-implementations",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "Sources & Implementations:",
    "text": "Sources & Implementations:\n\nCurricula\n\nEmppfehlungen Masterstudiengänge Data Science\n\n\n\nCourses\n\nStatistical Data Analysis\nMathematical Foundations of Data Science\nProgrammieren für Data Scientists Python\n\n\n\nPrograms\n\nUP Data Science"
  },
  {
    "objectID": "generation/generated/gen_softwareengineering.html",
    "href": "generation/generated/gen_softwareengineering.html",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "",
    "text": "To summarise the vast range of the skills a software engineer is typically equipped with, we refer to the Guide to the Software Engineering Body of Knowledge (Bourque, Fairley, and IEEE Computer Society 2014). Because research software engineering is an interface discipline, RSEs are often stronger in topics more commonly encountered in research software contexts (e.g., mathematical and engineering foundations) than in other areas (e.g., software engineering economics). However, they bring a solid level of competence in all software engineering topics. Therefore, RSEs can set and analyse software requirements in the context of open-ended, question-driven research. They can design software so that it can sustainably grow, often in an environment of rapid turnover of contributors. They are competent in implementing solutions themselves in a wide range of technologies fit for different scientific applications. They can formulate and implement various types of tests, they can independently maintain software and automate operations of the integration and release process. They can provide working, scalable, and future-proof solutions in a professional context and with common project and software management techniques, adapted to the needs of the research environment. Finally, as people who have often gained significant research experience in a particular discipline, they combine the necessary foundations from their domain with software engineering skills to develop complex software.(Goth et al. 2024)\nThis module tries to lay the foundations for the advanced RSE software engineering training.\n\n\nBourque, Pierre, Richard E. Fairley, and IEEE Computer Society. 2014. Guide to the Software Engineering Body of Knowledge (SWEBOK(R)): Version 3.0. 3rd ed. Washington, DC, USA: IEEE Computer Society Press.\n\n\nGoth, F, R Alves, M Braun, LJ Castro, G Chourdakis, S Christ, J Cohen, et al. 2024. “Foundational Competencies and Responsibilities of a Research Software Engineer [Version 1; Peer Review: Awaiting Peer Review].” F1000Research 13 (1429). https://doi.org/10.12688/f1000research.157778.1."
  },
  {
    "objectID": "generation/generated/gen_softwareengineering.html#classical-software-engineering",
    "href": "generation/generated/gen_softwareengineering.html#classical-software-engineering",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "",
    "text": "To summarise the vast range of the skills a software engineer is typically equipped with, we refer to the Guide to the Software Engineering Body of Knowledge (Bourque, Fairley, and IEEE Computer Society 2014). Because research software engineering is an interface discipline, RSEs are often stronger in topics more commonly encountered in research software contexts (e.g., mathematical and engineering foundations) than in other areas (e.g., software engineering economics). However, they bring a solid level of competence in all software engineering topics. Therefore, RSEs can set and analyse software requirements in the context of open-ended, question-driven research. They can design software so that it can sustainably grow, often in an environment of rapid turnover of contributors. They are competent in implementing solutions themselves in a wide range of technologies fit for different scientific applications. They can formulate and implement various types of tests, they can independently maintain software and automate operations of the integration and release process. They can provide working, scalable, and future-proof solutions in a professional context and with common project and software management techniques, adapted to the needs of the research environment. Finally, as people who have often gained significant research experience in a particular discipline, they combine the necessary foundations from their domain with software engineering skills to develop complex software.(Goth et al. 2024)\nThis module tries to lay the foundations for the advanced RSE software engineering training.\n\n\nBourque, Pierre, Richard E. Fairley, and IEEE Computer Society. 2014. Guide to the Software Engineering Body of Knowledge (SWEBOK(R)): Version 3.0. 3rd ed. Washington, DC, USA: IEEE Computer Society Press.\n\n\nGoth, F, R Alves, M Braun, LJ Castro, G Chourdakis, S Christ, J Cohen, et al. 2024. “Foundational Competencies and Responsibilities of a Research Software Engineer [Version 1; Peer Review: Awaiting Peer Review].” F1000Research 13 (1429). https://doi.org/10.12688/f1000research.157778.1."
  },
  {
    "objectID": "generation/generated/gen_softwareengineering.html#software-engineering-i",
    "href": "generation/generated/gen_softwareengineering.html#software-engineering-i",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "Software Engineering I",
    "text": "Software Engineering I\nBasic concepts of software engineering, software and product life cycle, process models for the design of large software systems, semantic aspects of domain description, hierarchy, parallelism, real-time and embedded systems as fundamental paradigms, organizational principles of complex software systems, design by contract, patterns in modeling and design methods of quality assurance, evolution and re-engineering, selected languages and tools for process- and object-oriented modeling, methods and languages for object-oriented design, architectures and architectural patterns of software systems, architecture of enterprise applications, design and implementation models in the object-oriented paradigm, e.g., Java 2 SE, design patterns, software testing methods.\nLecture: Software Engineering I\nSWS: 2 ECTS: 4\nExercise: Software Engineering I Exercise\nSWS: 2 ECTS: 2"
  },
  {
    "objectID": "generation/generated/gen_softwareengineering.html#software-engineering-2",
    "href": "generation/generated/gen_softwareengineering.html#software-engineering-2",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "Software Engineering 2",
    "text": "Software Engineering 2\nThe module covers a selection of advanced topics in the field of software engineering, such as software quality assurance, service engineering, virtualization, programming languages and design, and formal methods in system design.\nLecture: Software Engineering II\nSWS: 2 ECTS: 4\nExercise: Software Engineering II Exercise\nSWS: 2 ECTS: 2"
  },
  {
    "objectID": "generation/generated/gen_softwareengineering.html#module-competences",
    "href": "generation/generated/gen_softwareengineering.html#module-competences",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "Module Competences",
    "text": "Module Competences\n\n\n\nID\nDescription\nDisciplines\nPrerequisites\nEvidence\nAuthor\nSource\n\n\n\n\ngen_programming_1\nUnderstand the fundamental concepts of software engineering\nComputer Science\n\nDemonstrate understanding through theoretical assessments and practical examples\nUniversity of Potsdam\nLink\n\n\ngen_programming_2\nApply various approaches of software engineering\nComputer Science\ngen_programming_1\nComplete assignments or projects using different software engineering methods\nUniversity of Potsdam\nLink\n\n\ngen_programming_3\nIdentify and utilize essential technologies and tools for specification, component-based development, and quality assurance of modern software systems\nComputer Science\ngen_programming_1\nWork with selected tools and technologies in practical exercises and case studies\nUniversity of Potsdam\nLink\n\n\ngen_programming_4\nDemonstrate an in-depth understanding and ability to apply various approaches of software engineering\nComputer Science\ngen_programming_1, gen_programming_2\nSuccessfully complete advanced projects employing different software engineering methods\nUniversity of Potsdam\nLink\n\n\ngen_programming_5\nUnderstand the characteristics of a wide range of technologies and tools for specification, component-based development, and quality assurance of modern software systems, and apply them in various contexts\nComputer Science\ngen_programming_3\nApply appropriate technologies and tools in complex case studies and demonstrate their use in different application scenarios\nUniversity of Potsdam\nLink"
  },
  {
    "objectID": "generation/generated/gen_softwareengineering.html#sources-implementations",
    "href": "generation/generated/gen_softwareengineering.html#sources-implementations",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "Sources & Implementations:",
    "text": "Sources & Implementations:\n\nCurricula\n\nComputing Curricula 2020\n\n\n\nCourses\n\nSoftware Engineering I\n\n\n\nPrograms\n\nUP Computational Science Master\n\n\n\nBourque, Pierre, Richard E. Fairley, and IEEE Computer Society. 2014. Guide to the Software Engineering Body of Knowledge (SWEBOK(R)): Version 3.0. 3rd ed. Washington, DC, USA: IEEE Computer Society Press.\n\n\nGoth, F, R Alves, M Braun, LJ Castro, G Chourdakis, S Christ, J Cohen, et al. 2024. “Foundational Competencies and Responsibilities of a Research Software Engineer [Version 1; Peer Review: Awaiting Peer Review].” F1000Research 13 (1429). https://doi.org/10.12688/f1000research.157778.1."
  },
  {
    "objectID": "generation/generated/mnt_project.html",
    "href": "generation/generated/mnt_project.html",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "",
    "text": "Applied Research Software Engineering in MINT Sciences\nThis lab module provides students with a hands-on opportunity to apply research software engineering principles to real-world scientific problems from the MINT disciplines (Mathematics, Informatics, Natural Sciences, and Technology). Students work on projects originating from active research contexts — such as simulations in physics, data analysis in chemistry, modeling in biology, or\nLab: Science Lab\nSWS: 4 ECTS: 6"
  },
  {
    "objectID": "generation/generated/mnt_project.html#science-lab-module",
    "href": "generation/generated/mnt_project.html#science-lab-module",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "",
    "text": "Applied Research Software Engineering in MINT Sciences\nThis lab module provides students with a hands-on opportunity to apply research software engineering principles to real-world scientific problems from the MINT disciplines (Mathematics, Informatics, Natural Sciences, and Technology). Students work on projects originating from active research contexts — such as simulations in physics, data analysis in chemistry, modeling in biology, or\nLab: Science Lab\nSWS: 4 ECTS: 6"
  },
  {
    "objectID": "generation/generated/rse_computing.html",
    "href": "generation/generated/rse_computing.html",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "",
    "text": "RSEs with expertise in HPC and other performance-critical computing domains specialize in optimizing code for efficient execution across various platforms, including clusters, cloud, edge, and embedded systems. They understand parallel programming models, hardware-specific optimizations, profiling tools, and platform constraints such as memory, energy, and latency. Their skills enable them to adapt software to diverse infrastructures, manage complex dependencies, and support researchers in accessing and using advanced computing resources effectively and sustainably.\n\n\n\n\nThis module provides an entry‑level yet rigorous foundation in scientific computing for graduate students and researchers who need to design, implement, and evaluate computational experiments. Learners gain an awareness of the numerical underpinnings of modern simulation and data‑driven research, with an emphasis on writing reproducible, efficient, and trustworthy code.\n\n\n\nBy the end of the module participants will be able to\n\nBenchmark small programs and interpret performance metrics in a research context.\nExplain how approximation theory and floating‑point arithmetic affect numerical accuracy and stability.\nIdentify when to use established simulation libraries (e.g. BLAS/LAPACK, PETSc, Trilinos) instead of custom code.\nWrite simple GPU kernels and describe the core principles of accelerator programming.\nSubmit and monitor batch & array jobs on a mid‑size compute cluster.\nDescribe common HPC challenges—such as I/O bottlenecks, threading, and NUMA—and propose mitigation strategies.\nMaintain research software through continuous benchmarking.\n\n\n\n\n\n\n\n\n\n\n\n\nWeek\nTheme\nTopics\n\n\n\n\n1\nBenchmarking & Profiling\nTiming strategies · micro vs. macro benchmarks · tooling overview\n\n\n2\nPrecision & Approximation\nIEEE‑754 recap · conditioning & stability · error propagation\n\n\n3\nScientific Libraries\nBLAS/LAPACK anatomy · hierarchical I/O libraries · overview of PETSc/Trilinos/Hypre\n\n\n4\nGPU Primer\nKernel model · memory hierarchy · CUDA/OpenCL/PyTorch lightning intro\n\n\n5\nWorking on a Cluster\nSlurm basics · job arrays · job dependencies · simple Bash launchers\n\n\n6\nHPC Pitfalls\nI/O throughput · thread oversubscription · NUMA awareness\n\n\n7\nSoftware Maintenance\nRegression + performance tests · continuous benchmarking pipelines\n\n\n\n\n\n\nShort lectures (30%) are coupled with hands‑on labs (70%). Students complete weekly notebooks and a mini‑project that reproduces and optimises a published computational result.\n\n\n\n\n\n\nComponent\nWeight\nDetails\n\n\n\n\nContinuous labs\n40%\nWeekly graded notebooks\n\n\nFinal mini‑project\n60%\nReport, code, and benchmark suite\n\n\n\n\n\n\n\nBasic programming in Python, C/C++, or Julia\nUndergraduate calculus & linear algebra\n\n\n\n\nChatGPT fantasy\nLecture: Scientific Computing Basics\nSWS: 2 ECTS: 3\nExercise: Scientific Computing Basics Exercise\nSWS: 2 ECTS: 3\nLecture: High Performance Computing\nSWS: 2 ECTS: 3\nExercise: High Performance Computing Exercise\nSWS: 2 ECTS: 3"
  },
  {
    "objectID": "generation/generated/rse_computing.html#rse-computing",
    "href": "generation/generated/rse_computing.html#rse-computing",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "",
    "text": "RSEs with expertise in HPC and other performance-critical computing domains specialize in optimizing code for efficient execution across various platforms, including clusters, cloud, edge, and embedded systems. They understand parallel programming models, hardware-specific optimizations, profiling tools, and platform constraints such as memory, energy, and latency. Their skills enable them to adapt software to diverse infrastructures, manage complex dependencies, and support researchers in accessing and using advanced computing resources effectively and sustainably.\n\n\n\n\nThis module provides an entry‑level yet rigorous foundation in scientific computing for graduate students and researchers who need to design, implement, and evaluate computational experiments. Learners gain an awareness of the numerical underpinnings of modern simulation and data‑driven research, with an emphasis on writing reproducible, efficient, and trustworthy code.\n\n\n\nBy the end of the module participants will be able to\n\nBenchmark small programs and interpret performance metrics in a research context.\nExplain how approximation theory and floating‑point arithmetic affect numerical accuracy and stability.\nIdentify when to use established simulation libraries (e.g. BLAS/LAPACK, PETSc, Trilinos) instead of custom code.\nWrite simple GPU kernels and describe the core principles of accelerator programming.\nSubmit and monitor batch & array jobs on a mid‑size compute cluster.\nDescribe common HPC challenges—such as I/O bottlenecks, threading, and NUMA—and propose mitigation strategies.\nMaintain research software through continuous benchmarking.\n\n\n\n\n\n\n\n\n\n\n\n\nWeek\nTheme\nTopics\n\n\n\n\n1\nBenchmarking & Profiling\nTiming strategies · micro vs. macro benchmarks · tooling overview\n\n\n2\nPrecision & Approximation\nIEEE‑754 recap · conditioning & stability · error propagation\n\n\n3\nScientific Libraries\nBLAS/LAPACK anatomy · hierarchical I/O libraries · overview of PETSc/Trilinos/Hypre\n\n\n4\nGPU Primer\nKernel model · memory hierarchy · CUDA/OpenCL/PyTorch lightning intro\n\n\n5\nWorking on a Cluster\nSlurm basics · job arrays · job dependencies · simple Bash launchers\n\n\n6\nHPC Pitfalls\nI/O throughput · thread oversubscription · NUMA awareness\n\n\n7\nSoftware Maintenance\nRegression + performance tests · continuous benchmarking pipelines\n\n\n\n\n\n\nShort lectures (30%) are coupled with hands‑on labs (70%). Students complete weekly notebooks and a mini‑project that reproduces and optimises a published computational result.\n\n\n\n\n\n\nComponent\nWeight\nDetails\n\n\n\n\nContinuous labs\n40%\nWeekly graded notebooks\n\n\nFinal mini‑project\n60%\nReport, code, and benchmark suite\n\n\n\n\n\n\n\nBasic programming in Python, C/C++, or Julia\nUndergraduate calculus & linear algebra\n\n\n\n\nChatGPT fantasy\nLecture: Scientific Computing Basics\nSWS: 2 ECTS: 3\nExercise: Scientific Computing Basics Exercise\nSWS: 2 ECTS: 3\nLecture: High Performance Computing\nSWS: 2 ECTS: 3\nExercise: High Performance Computing Exercise\nSWS: 2 ECTS: 3"
  },
  {
    "objectID": "generation/generated/rse_computing.html#module-competences",
    "href": "generation/generated/rse_computing.html#module-competences",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "Module Competences",
    "text": "Module Competences\n\n\n\nID\nDescription\nDisciplines\nPrerequisites\nEvidence\nAuthor\nSource\n\n\n\n\ncomp_module_1\nBenchmark and profile computational code to evaluate performance and bottlenecks\nScientific Computing\nrse_tooling_2\nSubmit benchmark reports comparing implementations and justifying trade-offs\nRSE Curriculum Draft\nLink\n\n\ncomp_module_2\nExplain and apply principles of approximation theory and numerical precision in scientific computing\nScientific Computing\n\nAnswer conceptual questions and implement small examples highlighting precision trade-offs\nRSE Curriculum Draft\nLink\n\n\ncomp_module_3\nExplain floating-point arithmetic and its implications for scientific accuracy and performance\nScientific Computing\ncomp_module_2\nProvide examples showing effects of precision loss and propose mitigations\nRSE Curriculum Draft\nLink\n\n\ncomp_module_4\nDescribe common simulation libraries and numerical frameworks (e.g., BLAS, LAPACK, PETSc, Trilinos)\nScientific Computing\n\nList relevant libraries for a task and justify choice or avoidance of custom implementations\nRSE Curriculum Draft\nLink\n\n\ncomp_module_5\nCompare interpreted and compiled languages in terms of performance and suitability for computing tasks\nScientific Computing\n\nWrite code samples in both types of language and explain their performance characteristics\nRSE Curriculum Draft\nLink\n\n\nhpc_module_1\nRun batch and array jobs on a cluster, including job dependencies\nHigh-Performance Computing\nrse_tooling_3\nSubmit job scripts using SLURM or similar systems demonstrating correct use of job arrays and dependencies\nRSE Curriculum Draft\nLink\n\n\nhpc_module_2\nIdentify and manage common challenges in HPC systems (e.g., I/O bottlenecks, threading, NUMA memory)\nHigh-Performance Computing\nhpc_module_1\nProvide performance logs and interpret bottlenecks in a real or simulated HPC task\nRSE Curriculum Draft\nLink\n\n\nhpc_module_3\nUse shell scripting (e.g., Bash) to automate HPC job submission\nHigh-Performance Computing\nrse_tooling_3\nSubmit scripts that automate the execution of HPC jobs and handle job logic\nRSE Curriculum Draft\nLink\n\n\nhpc_module_4\nUnderstand and use the principles of accelerator programming (e.g., GPU kernels and frameworks)\nHigh-Performance Computing\n\nSubmit a small CUDA or OpenCL program with documentation of the principles used\nRSE Curriculum Draft\nLink\n\n\nhpc_module_5\nMaintain scientific computing software including use of continuous benchmarking\nHigh-Performance Computing\ncomp_module_1\nProvide benchmark and performance history for evolving versions of software\nRSE Curriculum Draft\nLink"
  },
  {
    "objectID": "generation/generated/rse_computing.html#sources-implementations",
    "href": "generation/generated/rse_computing.html#sources-implementations",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "Sources & Implementations:",
    "text": "Sources & Implementations:\n\nCurricula\n\nEUMaster4HPC\n\n\n\nCourses\n\nViral Instructions Hardware\nHPC Computing\n\n\n\nRecommended Course Literature\n\nWhat every computer scientist should know about floating-point arithmetic\n\n\n\nPrograms\n\nHPC-carpentry"
  },
  {
    "objectID": "generation/generated/rse_missingsemester.html",
    "href": "generation/generated/rse_missingsemester.html",
    "title": "RSE Nuts and Bolts",
    "section": "",
    "text": "This module, inspired by the MIT Missing Semester, addresses the “nuts and bolts” often missing from traditional academic training in computing. It aims to provide students with practical skills and conceptual understanding for building robust, maintainable, and reproducible research software—key competencies in Research Software Engineering (RSE).\n\n\n\nThe module begins with general-purpose computing tools and techniques that are foundational for any research software engineer:\n\nShell tools and scripting\nCommand-line environments\nEditors and IDEs (e.g., Vim)\nVersion control (Git)\nData wrangling\nDebugging and profiling\nMetaprogramming\nSecurity and cryptography\n\n\n\n\nBuilding on these foundations, the module introduces RSE-specific concepts and good practices:\n\nVersion control and collaboration\n\nGit for code history, collaboration, and issue tracking\n\nVirtualization concepts\n\nContainerization and environment management\n\nThe Data Life Cycle\n\nManaging research data and understanding data provenance\n\nGood coding practices\n\nReproducible and testable code\nMeaningful documentation and error messages\nModular software design\nPerformance-conscious coding\nEasily installable and distributable software\nCoding standards, formatting, and linting\n\nSoftware management planning\n\nWriting Data and Software Management Plans\nSustainable development and community involvement\n\nLow-level programming\n\nIntroduction to a compiled language (e.g., C) to expose hardware-level concerns and efficient memory management\n\nLong-term software maintenance\n\nVersion tracking, bug management, and sustainability strategies\nBuilding and maintaining research software communities\n\n\n\n\n\nFinally, the module touches on practices that support the scholarly nature of research software:\n\nSoftware publication and citation (see SP in (Goth et al. 2024))\nUse of domain-specific repositories and registries (see DOMREP in (Goth et al. 2024))\n\nBy the end of this module, students will be well-equipped to design, develop, document, and maintain research software that meets high standards of quality, sustainability, and reproducibility.\nThe module is made up of two seminars that the students take at different stages in their master’s program: In the first seminar during their first semester, students mainly learn new concepts and get to know essential tools, whereas the second seminar in the third semester focuses on teaching others about research software and the development process of it (see TEACH in (Goth et al. 2024)).\nSeminar: RSE Nuts and Bolts I This is an introductory class to essential techniques an RSE needs in everyday life. SWS: 2 ECTS: 3\nSeminar: RSE Nuts and Bolts II This is an advanced class of RSE techniques that includes a teaching component as part of the preparation for working as an RSE in interdisciplinary teams. SWS: 2 ECTS: 3\n\n\n\n\n\n\nID\nDescription\nDisciplines\nPrerequisites\nEvidence\nAuthor\nSource\n\n\n\n\nrse_tooling_1\nUse literate programming tools (e.g., Quarto, Marimo, Pluto.jl, Jupyter) to combine code, results, and narrative\nResearch Software Engineering\n\nSubmit a literate notebook or document integrating code, visualizations, and explanatory text\nWorkshop Participants\nLink\n\n\nrse_tooling_2\nUse Python for visualization, scripting, templating, and integration tasks\nResearch Software Engineering\n\nSubmit a Python project demonstrating use of libraries for visualisation, web tasks, and templating\nWorkshop Participants\nLink\n\n\nrse_tooling_3\nWrite and use Bash scripts for automation\nResearch Software Engineering\n\nSubmit shell scripts automating file manipulation or computational workflows\nWorkshop Participants\nLink\n\n\nrse_tooling_4\nApply testing, debugging, and logging techniques to ensure software reliability\nResearch Software Engineering\nrse_tooling_2\nSubmit logs, test cases, and debugging documentation for a non-trivial Python or Bash project\nWorkshop Participants\nLink\n\n\nrse_tooling_5\nUse workflow management tools (e.g., CWL, Nextflow) to design scalable, reproducible pipelines\nResearch Software Engineering\nrse_tooling_3, rse_tooling_11\nSubmit a reproducible workflow including metadata and input/output definitions\nWorkshop Participants\nLink\n\n\nrse_tooling_6\nEstimate resource requirements for computational tasks using profiling and benchmarking\nResearch Software Engineering\nrse_tooling_2, rse_tooling_5\nProvide resource usage profiles and discuss optimization implications\nWorkshop Participants\nLink\n\n\nrse_tooling_7\nUse package managers and virtual environments (e.g., conda, nix) to manage software dependencies\nResearch Software Engineering\n\nSubmit environment definitions and reproducible setup instructions for a project\nWorkshop Participants\nLink\n\n\nrse_tooling_8\nDocument and package software for usability and reusability, using generators and modular design\nResearch Software Engineering\nrse_tooling_2\nSubmit user and developer documentation generated with Sphinx or similar, plus a reusable code module\nWorkshop Participants\nLink\n\n\nrse_tooling_9\nCommunicate technical RSE topics effectively with non-technical audiences\nResearch Software Engineering\n\nPrepare and deliver a presentation or write an article explaining RSE concepts to a general audience\nWorkshop Participants\nLink\n\n\nrse_tooling_10\nApply authentication and authorization mechanisms (e.g., LDAP, ACLs, Active Directory)\nResearch Software Engineering\n\nConfigure and demonstrate access control for a multi-user service or application\nWorkshop Participants\nLink\n\n\nrse_tooling_11\nMake informed decisions about tooling and infrastructure (e.g., Jupyter vs scripts, local vs HPC/cloud)\nResearch Software Engineering\nrse_tooling_1, rse_tooling_2, rse_tooling_3\nSubmit a comparative analysis justifying tooling and infrastructure choices for a research project\nWorkshop Participants\nLink\n\n\nrse_tooling_12\nTeach and practice collaborative development, including version control and code review\nResearch Software Engineering\nrse_tooling_2\nSubmit a project with version history and documented code reviews\nWorkshop Participants\nLink\n\n\nrse_tooling_13\nMentor others in research software engineering practices\nResearch Software Engineering\nrse_tooling_12\nDocument a mentoring session, workshop, or support activity\nWorkshop Participants\nLink\n\n\nrse_tooling_14\nDeploy and maintain web servers for research applications\nResearch Software Engineering\nrse_tooling_2\nDeploy a working web application with setup and maintenance documentation\nWorkshop Participants\nLink\n\n\nrse_tooling_15\nUnderstand and manage file systems, including local and network-attached storage\nResearch Software Engineering\n\nDocument storage strategies and access mechanisms in a real-world setup\nWorkshop Participants\nLink\n\n\n\n\n\n\n\n\n\nMIT Missing Semester\nCodeRefinery\nINTERSECT Training Materials\nDigital Research Academy Materials (Git, HPC, Reproducibility, Research Software)\nBuilding Better Research Software (SSI)\nDocker for neuroscience (jupyter book)\n\n\n\nGoth, F, R Alves, M Braun, LJ Castro, G Chourdakis, S Christ, J Cohen, et al. 2024. “Foundational Competencies and Responsibilities of a Research Software Engineer [Version 1; Peer Review: Awaiting Peer Review].” F1000Research 13 (1429). https://doi.org/10.12688/f1000research.157778.1."
  },
  {
    "objectID": "generation/generated/rse_missingsemester.html#introduction",
    "href": "generation/generated/rse_missingsemester.html#introduction",
    "title": "RSE Nuts and Bolts",
    "section": "",
    "text": "This module, inspired by the MIT Missing Semester, addresses the “nuts and bolts” often missing from traditional academic training in computing. It aims to provide students with practical skills and conceptual understanding for building robust, maintainable, and reproducible research software—key competencies in Research Software Engineering (RSE)."
  },
  {
    "objectID": "generation/generated/rse_missingsemester.html#general-competencies",
    "href": "generation/generated/rse_missingsemester.html#general-competencies",
    "title": "RSE Nuts and Bolts",
    "section": "",
    "text": "The module begins with general-purpose computing tools and techniques that are foundational for any research software engineer:\n\nShell tools and scripting\nCommand-line environments\nEditors and IDEs (e.g., Vim)\nVersion control (Git)\nData wrangling\nDebugging and profiling\nMetaprogramming\nSecurity and cryptography"
  },
  {
    "objectID": "generation/generated/rse_missingsemester.html#rse-specific-topics",
    "href": "generation/generated/rse_missingsemester.html#rse-specific-topics",
    "title": "RSE Nuts and Bolts",
    "section": "",
    "text": "Building on these foundations, the module introduces RSE-specific concepts and good practices:\n\nVersion control and collaboration\n\nGit for code history, collaboration, and issue tracking\n\nVirtualization concepts\n\nContainerization and environment management\n\nThe Data Life Cycle\n\nManaging research data and understanding data provenance\n\nGood coding practices\n\nReproducible and testable code\nMeaningful documentation and error messages\nModular software design\nPerformance-conscious coding\nEasily installable and distributable software\nCoding standards, formatting, and linting\n\nSoftware management planning\n\nWriting Data and Software Management Plans\nSustainable development and community involvement\n\nLow-level programming\n\nIntroduction to a compiled language (e.g., C) to expose hardware-level concerns and efficient memory management\n\nLong-term software maintenance\n\nVersion tracking, bug management, and sustainability strategies\nBuilding and maintaining research software communities"
  },
  {
    "objectID": "generation/generated/rse_missingsemester.html#beyond-the-basics",
    "href": "generation/generated/rse_missingsemester.html#beyond-the-basics",
    "title": "RSE Nuts and Bolts",
    "section": "",
    "text": "Finally, the module touches on practices that support the scholarly nature of research software:\n\nSoftware publication and citation (see SP in (Goth et al. 2024))\nUse of domain-specific repositories and registries (see DOMREP in (Goth et al. 2024))\n\nBy the end of this module, students will be well-equipped to design, develop, document, and maintain research software that meets high standards of quality, sustainability, and reproducibility.\nThe module is made up of two seminars that the students take at different stages in their master’s program: In the first seminar during their first semester, students mainly learn new concepts and get to know essential tools, whereas the second seminar in the third semester focuses on teaching others about research software and the development process of it (see TEACH in (Goth et al. 2024)).\nSeminar: RSE Nuts and Bolts I This is an introductory class to essential techniques an RSE needs in everyday life. SWS: 2 ECTS: 3\nSeminar: RSE Nuts and Bolts II This is an advanced class of RSE techniques that includes a teaching component as part of the preparation for working as an RSE in interdisciplinary teams. SWS: 2 ECTS: 3"
  },
  {
    "objectID": "generation/generated/rse_missingsemester.html#module-competences",
    "href": "generation/generated/rse_missingsemester.html#module-competences",
    "title": "RSE Nuts and Bolts",
    "section": "",
    "text": "ID\nDescription\nDisciplines\nPrerequisites\nEvidence\nAuthor\nSource\n\n\n\n\nrse_tooling_1\nUse literate programming tools (e.g., Quarto, Marimo, Pluto.jl, Jupyter) to combine code, results, and narrative\nResearch Software Engineering\n\nSubmit a literate notebook or document integrating code, visualizations, and explanatory text\nWorkshop Participants\nLink\n\n\nrse_tooling_2\nUse Python for visualization, scripting, templating, and integration tasks\nResearch Software Engineering\n\nSubmit a Python project demonstrating use of libraries for visualisation, web tasks, and templating\nWorkshop Participants\nLink\n\n\nrse_tooling_3\nWrite and use Bash scripts for automation\nResearch Software Engineering\n\nSubmit shell scripts automating file manipulation or computational workflows\nWorkshop Participants\nLink\n\n\nrse_tooling_4\nApply testing, debugging, and logging techniques to ensure software reliability\nResearch Software Engineering\nrse_tooling_2\nSubmit logs, test cases, and debugging documentation for a non-trivial Python or Bash project\nWorkshop Participants\nLink\n\n\nrse_tooling_5\nUse workflow management tools (e.g., CWL, Nextflow) to design scalable, reproducible pipelines\nResearch Software Engineering\nrse_tooling_3, rse_tooling_11\nSubmit a reproducible workflow including metadata and input/output definitions\nWorkshop Participants\nLink\n\n\nrse_tooling_6\nEstimate resource requirements for computational tasks using profiling and benchmarking\nResearch Software Engineering\nrse_tooling_2, rse_tooling_5\nProvide resource usage profiles and discuss optimization implications\nWorkshop Participants\nLink\n\n\nrse_tooling_7\nUse package managers and virtual environments (e.g., conda, nix) to manage software dependencies\nResearch Software Engineering\n\nSubmit environment definitions and reproducible setup instructions for a project\nWorkshop Participants\nLink\n\n\nrse_tooling_8\nDocument and package software for usability and reusability, using generators and modular design\nResearch Software Engineering\nrse_tooling_2\nSubmit user and developer documentation generated with Sphinx or similar, plus a reusable code module\nWorkshop Participants\nLink\n\n\nrse_tooling_9\nCommunicate technical RSE topics effectively with non-technical audiences\nResearch Software Engineering\n\nPrepare and deliver a presentation or write an article explaining RSE concepts to a general audience\nWorkshop Participants\nLink\n\n\nrse_tooling_10\nApply authentication and authorization mechanisms (e.g., LDAP, ACLs, Active Directory)\nResearch Software Engineering\n\nConfigure and demonstrate access control for a multi-user service or application\nWorkshop Participants\nLink\n\n\nrse_tooling_11\nMake informed decisions about tooling and infrastructure (e.g., Jupyter vs scripts, local vs HPC/cloud)\nResearch Software Engineering\nrse_tooling_1, rse_tooling_2, rse_tooling_3\nSubmit a comparative analysis justifying tooling and infrastructure choices for a research project\nWorkshop Participants\nLink\n\n\nrse_tooling_12\nTeach and practice collaborative development, including version control and code review\nResearch Software Engineering\nrse_tooling_2\nSubmit a project with version history and documented code reviews\nWorkshop Participants\nLink\n\n\nrse_tooling_13\nMentor others in research software engineering practices\nResearch Software Engineering\nrse_tooling_12\nDocument a mentoring session, workshop, or support activity\nWorkshop Participants\nLink\n\n\nrse_tooling_14\nDeploy and maintain web servers for research applications\nResearch Software Engineering\nrse_tooling_2\nDeploy a working web application with setup and maintenance documentation\nWorkshop Participants\nLink\n\n\nrse_tooling_15\nUnderstand and manage file systems, including local and network-attached storage\nResearch Software Engineering\n\nDocument storage strategies and access mechanisms in a real-world setup\nWorkshop Participants\nLink"
  },
  {
    "objectID": "generation/generated/rse_missingsemester.html#sources-implementations",
    "href": "generation/generated/rse_missingsemester.html#sources-implementations",
    "title": "RSE Nuts and Bolts",
    "section": "",
    "text": "MIT Missing Semester\nCodeRefinery\nINTERSECT Training Materials\nDigital Research Academy Materials (Git, HPC, Reproducibility, Research Software)\nBuilding Better Research Software (SSI)\nDocker for neuroscience (jupyter book)\n\n\n\nGoth, F, R Alves, M Braun, LJ Castro, G Chourdakis, S Christ, J Cohen, et al. 2024. “Foundational Competencies and Responsibilities of a Research Software Engineer [Version 1; Peer Review: Awaiting Peer Review].” F1000Research 13 (1429). https://doi.org/10.12688/f1000research.157778.1."
  },
  {
    "objectID": "generation/generated/rse_theory.html",
    "href": "generation/generated/rse_theory.html",
    "title": "RSE Philosophy",
    "section": "",
    "text": "The RSE master program is more than a computer science specialisation for researchers. People working as RSE are often involved in digitalization projects, institutional development or other non-technical tasks.\n\n\n\nFor a university level study program it is fitting that students learn an abstract high-level understanding of their field so that they can adapt technical models, communication frameworks and policy recommendations to the complex cases. For this they need a solid understanding in some of the more theoretical fields such as …\n\nphilosophy of science\nsociology of technology\nethics and artificial intelligence\nhuman computer interaction\ndigital humanities\n\n\n\n\nThis module conveys competences in areas such as but not limited to …\n\nconducting and leading research (NEW)\nunderstanding the research cycle (RC)\ninteraction with users and stakeholders (USERS)\n\nSeminar: RSE Philosophy This is an introductory class to … SWS: None ECTS: None\n\n\n\n\n\n\nID\nDescription\nDisciplines\nPrerequisites\nEvidence\nAuthor\nSource\n\n\n\n\nrse_theory_1\nTODO\nResearch Software Engineering\n\n…\nRSE Curriculum Draft\nLink\n\n\n\n\n\n\n\n\n\nTODO"
  },
  {
    "objectID": "generation/generated/rse_theory.html#introduction",
    "href": "generation/generated/rse_theory.html#introduction",
    "title": "RSE Philosophy",
    "section": "",
    "text": "The RSE master program is more than a computer science specialisation for researchers. People working as RSE are often involved in digitalization projects, institutional development or other non-technical tasks."
  },
  {
    "objectID": "generation/generated/rse_theory.html#contents",
    "href": "generation/generated/rse_theory.html#contents",
    "title": "RSE Philosophy",
    "section": "",
    "text": "For a university level study program it is fitting that students learn an abstract high-level understanding of their field so that they can adapt technical models, communication frameworks and policy recommendations to the complex cases. For this they need a solid understanding in some of the more theoretical fields such as …\n\nphilosophy of science\nsociology of technology\nethics and artificial intelligence\nhuman computer interaction\ndigital humanities"
  },
  {
    "objectID": "generation/generated/rse_theory.html#general-competences",
    "href": "generation/generated/rse_theory.html#general-competences",
    "title": "RSE Philosophy",
    "section": "",
    "text": "This module conveys competences in areas such as but not limited to …\n\nconducting and leading research (NEW)\nunderstanding the research cycle (RC)\ninteraction with users and stakeholders (USERS)\n\nSeminar: RSE Philosophy This is an introductory class to … SWS: None ECTS: None"
  },
  {
    "objectID": "generation/generated/rse_theory.html#module-competences",
    "href": "generation/generated/rse_theory.html#module-competences",
    "title": "RSE Philosophy",
    "section": "",
    "text": "ID\nDescription\nDisciplines\nPrerequisites\nEvidence\nAuthor\nSource\n\n\n\n\nrse_theory_1\nTODO\nResearch Software Engineering\n\n…\nRSE Curriculum Draft\nLink"
  },
  {
    "objectID": "generation/generated/rse_theory.html#sources-implementations",
    "href": "generation/generated/rse_theory.html#sources-implementations",
    "title": "RSE Philosophy",
    "section": "",
    "text": "TODO"
  },
  {
    "objectID": "index.html#research-skills",
    "href": "index.html#research-skills",
    "title": "WORK IN PROGRESS THIS IS NOT THE OFFICIAL STATEMENT OF THE COMMUNITY BUT THE CURRENT VERSION",
    "section": "Research skills",
    "text": "Research skills\nTODO add text here\nResearch skills are implemented in the following components:\n\nmnt_project (TODO work/elaborate on naming, add cross-reference)\nmnt_wildcard\nrse_thesis\n\nTechnical skills are implemented in:\n\ngen_datascience\ngen_programming\ngen_softwareengineering\nrse_softwareengineering\nrse_programming\n\n(TODO check if technical training assumes too big a role)\ncommunication skills are implemented in:\n\nrse_management\nmnt_project\nrse_theory"
  }
]