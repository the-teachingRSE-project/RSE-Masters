[
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "",
    "text": "References"
  },
  {
    "objectID": "generation/generated/up_curriculum.html",
    "href": "generation/generated/up_curriculum.html",
    "title": "Example for Uni Potsdam",
    "section": "",
    "text": "Research Paradigms and Methodology for RSEs\nScientific Computing\nMathematical Foundations of Data Science\nRSEng, Ethics & Society\nNatural Language Processing\nRSEng Teaching\nSoftware Engineering for RSEs\nHigh-Performance Computing\nData Science\nRSEng Nuts and Bolts\nRSEng Lecture Series\nMaster’s Thesis\nRSEng Management\n\n\n\n\n\n\n\nType\nDescription\nSWS\nSem 1\nSem 2\nSem 3\nSem 4\nExisting Courses\nNew Concept\n\n\n\n\nLecture\nRSEng Lecture Series\n2\n3\n0\n0\n0\n\nyes\n\n\nSeminar\nRSEng Nuts and Bolts\n2\n3\n0\n0\n0\n\nyes\n\n\nLecture\nRSEng Management Lecture\n2\n3\n0\n0\n0\nOrganizational Behavior & Human Resource Management\nyes\n\n\nExercise\nRSEng Management Exercise\n2\n3\n0\n0\n0\nOrganizational Behavior & Human Resource Management\nyes\n\n\nLecture\nStatistical Data Analysis\n4\n6\n0\n0\n0\nStatistical Data Analysis (MATVMD837)\nno\n\n\nExercise\nStatistical Data Analysis Exercise\n2\n3\n0\n0\n0\nStatistical Data Analysis (MATVMD837)\nno\n\n\nLecture\nMathematical Foundations of Data Science\n2\n2\n0\n0\n0\nMathematical Foundations of Data Science (MAT-DSAM8B)\nno\n\n\nExercise\nMathematical Foundations of Data Science Exercise\n2\n4\n0\n0\n0\nMathematical Foundations of Data Science (MAT-DSAM8B)\nno\n\n\nSeminar\nSoftware Engineering for RSEs\n2\n0\n3\n0\n0\nResearch Software Engineering\nyes\n\n\nExercise\nSoftware Engineering Exercise for RSEs\n2\n0\n3\n0\n0\nResearch Software Engineering\nyes\n\n\nSeminar\nResearch Paradigms and Methodology for RSEs\n2\n0\n3\n0\n0\n\nyes\n\n\nSeminar\nRSEng, Ethics & Society\n2\n0\n3\n0\n0\nBasismodul Grundlagen der Theoretischen Philosophie\nyes\n\n\nany\nCompulsory Elective 1\n4\n0\n6\n0\n0\n\nno\n\n\nany\nCompulsory Elective 2\n4\n0\n6\n0\n0\n\nno\n\n\nany\nCompulsory Elective 3\n4\n0\n6\n0\n0\n\nno\n\n\nSeminar\nRSEng Teaching\n2\n0\n0\n3\n0\n\nyes\n\n\nLecture\nNatural Language Processing\n2\n0\n0\n4\n0\n\nno\n\n\nExercise\nNatural Language Processing Exercise\n2\n0\n0\n2\n0\n\nno\n\n\nLecture\nScientific Computing\n2\n0\n0\n3\n0\n\nyes\n\n\nExercise\nScientific Computing Exercise\n2\n0\n0\n3\n0\n\nyes\n\n\nLab\nRSEng Lab Project\n8\n0\n0\n12\n0\nPraktikumInterdisziplinäre Projektarbeit\nyes\n\n\nLecture and Exercise\nCurrent topics in Artificial Intelligence\n4\n0\n0\n6\n0\nAktuelle Themen der Künstlichen Intelligenz\nno\n\n\nThesis\nRSEng Master Thesis\n0\n0\n0\n0\n30\n\nyes\n\n\n\nTotal ECTS per semester\n\n27\n30\n33\n30\n\n\n\n\n\nTotal Curriculum ECTS: 120"
  },
  {
    "objectID": "generation/generated/up_curriculum.html#module-descriptions-linked",
    "href": "generation/generated/up_curriculum.html#module-descriptions-linked",
    "title": "Example for Uni Potsdam",
    "section": "",
    "text": "Research Paradigms and Methodology for RSEs\nScientific Computing\nMathematical Foundations of Data Science\nRSEng, Ethics & Society\nNatural Language Processing\nRSEng Teaching\nSoftware Engineering for RSEs\nHigh-Performance Computing\nData Science\nRSEng Nuts and Bolts\nRSEng Lecture Series\nMaster’s Thesis\nRSEng Management"
  },
  {
    "objectID": "generation/generated/up_curriculum.html#suggested-study-plan",
    "href": "generation/generated/up_curriculum.html#suggested-study-plan",
    "title": "Example for Uni Potsdam",
    "section": "",
    "text": "Type\nDescription\nSWS\nSem 1\nSem 2\nSem 3\nSem 4\nExisting Courses\nNew Concept\n\n\n\n\nLecture\nRSEng Lecture Series\n2\n3\n0\n0\n0\n\nyes\n\n\nSeminar\nRSEng Nuts and Bolts\n2\n3\n0\n0\n0\n\nyes\n\n\nLecture\nRSEng Management Lecture\n2\n3\n0\n0\n0\nOrganizational Behavior & Human Resource Management\nyes\n\n\nExercise\nRSEng Management Exercise\n2\n3\n0\n0\n0\nOrganizational Behavior & Human Resource Management\nyes\n\n\nLecture\nStatistical Data Analysis\n4\n6\n0\n0\n0\nStatistical Data Analysis (MATVMD837)\nno\n\n\nExercise\nStatistical Data Analysis Exercise\n2\n3\n0\n0\n0\nStatistical Data Analysis (MATVMD837)\nno\n\n\nLecture\nMathematical Foundations of Data Science\n2\n2\n0\n0\n0\nMathematical Foundations of Data Science (MAT-DSAM8B)\nno\n\n\nExercise\nMathematical Foundations of Data Science Exercise\n2\n4\n0\n0\n0\nMathematical Foundations of Data Science (MAT-DSAM8B)\nno\n\n\nSeminar\nSoftware Engineering for RSEs\n2\n0\n3\n0\n0\nResearch Software Engineering\nyes\n\n\nExercise\nSoftware Engineering Exercise for RSEs\n2\n0\n3\n0\n0\nResearch Software Engineering\nyes\n\n\nSeminar\nResearch Paradigms and Methodology for RSEs\n2\n0\n3\n0\n0\n\nyes\n\n\nSeminar\nRSEng, Ethics & Society\n2\n0\n3\n0\n0\nBasismodul Grundlagen der Theoretischen Philosophie\nyes\n\n\nany\nCompulsory Elective 1\n4\n0\n6\n0\n0\n\nno\n\n\nany\nCompulsory Elective 2\n4\n0\n6\n0\n0\n\nno\n\n\nany\nCompulsory Elective 3\n4\n0\n6\n0\n0\n\nno\n\n\nSeminar\nRSEng Teaching\n2\n0\n0\n3\n0\n\nyes\n\n\nLecture\nNatural Language Processing\n2\n0\n0\n4\n0\n\nno\n\n\nExercise\nNatural Language Processing Exercise\n2\n0\n0\n2\n0\n\nno\n\n\nLecture\nScientific Computing\n2\n0\n0\n3\n0\n\nyes\n\n\nExercise\nScientific Computing Exercise\n2\n0\n0\n3\n0\n\nyes\n\n\nLab\nRSEng Lab Project\n8\n0\n0\n12\n0\nPraktikumInterdisziplinäre Projektarbeit\nyes\n\n\nLecture and Exercise\nCurrent topics in Artificial Intelligence\n4\n0\n0\n6\n0\nAktuelle Themen der Künstlichen Intelligenz\nno\n\n\nThesis\nRSEng Master Thesis\n0\n0\n0\n0\n30\n\nyes\n\n\n\nTotal ECTS per semester\n\n27\n30\n33\n30\n\n\n\n\n\nTotal Curriculum ECTS: 120"
  },
  {
    "objectID": "generation/generated/rse_teaching.html",
    "href": "generation/generated/rse_teaching.html",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "",
    "text": "This seminar introduces students to possible teaching methods for RSEng in their third semester. As preparation for working as an RSE in interdisciplinary teams, students need some skills in teaching others about research software and the development process of it (see TEACH in (Goth et al. 2024))\nThis includes but is not limited to: - General didactic principles for designing learning units, competence orientation, task design, differentiation, feedback, diagnostics, criteria for good teaching and learning materials and formats (face-to-face, online, integrated or hybrid teaching) - Dealing with diverse learning prerequisites in computer science education, e.g. participation, motivation, self-regulation, subject-specific interest, subject-specific self-concept, self-efficacy expectations, fear of failure and misconceptions - Common approaches and methods for computer science education - PRIMM approach (Predict; Run; Investigate; Modify; Make) - Project-based learning, possibly with external partners - Gamification & game-based learning - Mastery learning - Self-regulated learning - Cooperative learning, team formation and the influence of team composition - Constructionism - (Distributed) pair programming - Live coding - Programming paradigms (especially procedures vs. objects first) - Understanding and improving given code (refactoring) - The twelve principles for practical digital teaching of software engineering - Tools for modern computer science education, in particular programming environments, pair programming with AI, debugging and automated testing - RSE-SE concepts\nSeminar: RSEng Teaching\nSWS: 2 ECTS: 3\n\n\nGoth, F, R Alves, M Braun, LJ Castro, G Chourdakis, S Christ, J Cohen, et al. 2024. “Foundational Competencies and Responsibilities of a Research Software Engineer [Version 1; Peer Review: Awaiting Peer Review].” F1000Research 13 (1429). https://doi.org/10.12688/f1000research.157778.1."
  },
  {
    "objectID": "generation/generated/rse_teaching.html#rseng-teaching",
    "href": "generation/generated/rse_teaching.html#rseng-teaching",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "",
    "text": "This seminar introduces students to possible teaching methods for RSEng in their third semester. As preparation for working as an RSE in interdisciplinary teams, students need some skills in teaching others about research software and the development process of it (see TEACH in (Goth et al. 2024))\nThis includes but is not limited to: - General didactic principles for designing learning units, competence orientation, task design, differentiation, feedback, diagnostics, criteria for good teaching and learning materials and formats (face-to-face, online, integrated or hybrid teaching) - Dealing with diverse learning prerequisites in computer science education, e.g. participation, motivation, self-regulation, subject-specific interest, subject-specific self-concept, self-efficacy expectations, fear of failure and misconceptions - Common approaches and methods for computer science education - PRIMM approach (Predict; Run; Investigate; Modify; Make) - Project-based learning, possibly with external partners - Gamification & game-based learning - Mastery learning - Self-regulated learning - Cooperative learning, team formation and the influence of team composition - Constructionism - (Distributed) pair programming - Live coding - Programming paradigms (especially procedures vs. objects first) - Understanding and improving given code (refactoring) - The twelve principles for practical digital teaching of software engineering - Tools for modern computer science education, in particular programming environments, pair programming with AI, debugging and automated testing - RSE-SE concepts\nSeminar: RSEng Teaching\nSWS: 2 ECTS: 3\n\n\nGoth, F, R Alves, M Braun, LJ Castro, G Chourdakis, S Christ, J Cohen, et al. 2024. “Foundational Competencies and Responsibilities of a Research Software Engineer [Version 1; Peer Review: Awaiting Peer Review].” F1000Research 13 (1429). https://doi.org/10.12688/f1000research.157778.1."
  },
  {
    "objectID": "generation/generated/rse_society_philosophy.html",
    "href": "generation/generated/rse_society_philosophy.html",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "",
    "text": "The RSE master’s program is more than a computer science specialisation for researchers. People working as RSEs are often involved in digitalization projects, institutional development or other non-technical tasks. Also, introducing students to cutting-edge technologies, raises ethical questions. To talk about the impact of RSE on society, is therefore crucial. This module addresses the social context of RSEng. Students examine issues relating to sustainability, ethics, responsibility and the impact of new technologies. The module provides space for student-driven projects that address social challenges such as green tech and artificial intelligence, and encourages reflection on the role of RSEng in science and society. It offers space for engagement with current challenges that are constantly changing but should be part of a curriculum in the age of digitalisation\n\n\n\nFor a university level study program, it is fitting that students learn an abstract high-level understanding of their field so that they can adapt technical models, communication frameworks and policy recommendations to the complex cases. Therefor, they need a solid understanding in some of the more theoretical fields such as … - RSEng in the context of philosophy of science - sociology of technology - ethics and artificial intelligence - human computer interaction - digital humanities - fundamentals and values of RSEng - ethics and responsibility of (research) software engineers - RSEng in the context of Open Science and the common good - dual use dilemma - sustainability and green technology - future of work - gender inequalities - Technology assessment\n\n\n\nThis module conveys competences in areas such as but not limited to: - discussion of ethical questions - awareness of societal consequences - conducting and leading research (NEW) - understanding the research cycle (RC)\nSeminar: RSEng, Ethics & Society\nSWS: 2 ECTS: 3\n\n\n\n\n\n\nID\nDescription\nDisciplines\nPrerequisites\nEvidence\nAuthor\nSource\n\n\n\n\nrse_society_1\nTODO\nResearch Software Engineering\n\n…\n\nLink\n\n\nrse_philosophy_1\nTODO\nResearch Software Engineering\n\n…\n\nLink\n\n\n\n\n\n\n\n\n\nData Ethics Essentials\nPhilosophische Grundlagen der Wissenschaften\nEinführung in die Wissenschaftstheorie\nEthics, technology, and data\nBasismodul Grundlagen der Theoretischen Philosophie\n\n\n\n\n\nValues in Science\n\n\n\n\n\nRWTH Informatik Bachelor"
  },
  {
    "objectID": "generation/generated/rse_society_philosophy.html#rseng-ethics-society",
    "href": "generation/generated/rse_society_philosophy.html#rseng-ethics-society",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "",
    "text": "The RSE master’s program is more than a computer science specialisation for researchers. People working as RSEs are often involved in digitalization projects, institutional development or other non-technical tasks. Also, introducing students to cutting-edge technologies, raises ethical questions. To talk about the impact of RSE on society, is therefore crucial. This module addresses the social context of RSEng. Students examine issues relating to sustainability, ethics, responsibility and the impact of new technologies. The module provides space for student-driven projects that address social challenges such as green tech and artificial intelligence, and encourages reflection on the role of RSEng in science and society. It offers space for engagement with current challenges that are constantly changing but should be part of a curriculum in the age of digitalisation\n\n\n\nFor a university level study program, it is fitting that students learn an abstract high-level understanding of their field so that they can adapt technical models, communication frameworks and policy recommendations to the complex cases. Therefor, they need a solid understanding in some of the more theoretical fields such as … - RSEng in the context of philosophy of science - sociology of technology - ethics and artificial intelligence - human computer interaction - digital humanities - fundamentals and values of RSEng - ethics and responsibility of (research) software engineers - RSEng in the context of Open Science and the common good - dual use dilemma - sustainability and green technology - future of work - gender inequalities - Technology assessment\n\n\n\nThis module conveys competences in areas such as but not limited to: - discussion of ethical questions - awareness of societal consequences - conducting and leading research (NEW) - understanding the research cycle (RC)\nSeminar: RSEng, Ethics & Society\nSWS: 2 ECTS: 3\n\n\n\n\n\n\nID\nDescription\nDisciplines\nPrerequisites\nEvidence\nAuthor\nSource\n\n\n\n\nrse_society_1\nTODO\nResearch Software Engineering\n\n…\n\nLink\n\n\nrse_philosophy_1\nTODO\nResearch Software Engineering\n\n…\n\nLink\n\n\n\n\n\n\n\n\n\nData Ethics Essentials\nPhilosophische Grundlagen der Wissenschaften\nEinführung in die Wissenschaftstheorie\nEthics, technology, and data\nBasismodul Grundlagen der Theoretischen Philosophie\n\n\n\n\n\nValues in Science\n\n\n\n\n\nRWTH Informatik Bachelor"
  },
  {
    "objectID": "generation/generated/rse_researchmethods.html",
    "href": "generation/generated/rse_researchmethods.html",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "",
    "text": "The module addresses the complex field of interaction between software as part of the reproducible research process and as a variable and research result in its own right. Similar to statistics, the use of computer technology leads to an expansion of possible research topics, but also to new sources of error, complexity and associated approaches.\nThis includes but is not limited to:\n\nForms of research and disciplinary culture\nEmpirical research methods (e.g. for software evaluation)\nDesign-based research and design science\nQualitative methods for concept evaluation\nSimulation techniques and mixed methods\n\nSeminar: Research Paradigms and Methodology for RSEs\nSWS: 2 ECTS: 3\n\n\n\n\n\nResearch methods & ethics"
  },
  {
    "objectID": "generation/generated/rse_researchmethods.html#research-paradigms-and-methodology-for-rses",
    "href": "generation/generated/rse_researchmethods.html#research-paradigms-and-methodology-for-rses",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "",
    "text": "The module addresses the complex field of interaction between software as part of the reproducible research process and as a variable and research result in its own right. Similar to statistics, the use of computer technology leads to an expansion of possible research topics, but also to new sources of error, complexity and associated approaches.\nThis includes but is not limited to:\n\nForms of research and disciplinary culture\nEmpirical research methods (e.g. for software evaluation)\nDesign-based research and design science\nQualitative methods for concept evaluation\nSimulation techniques and mixed methods\n\nSeminar: Research Paradigms and Methodology for RSEs\nSWS: 2 ECTS: 3\n\n\n\n\n\nResearch methods & ethics"
  },
  {
    "objectID": "generation/generated/rse_management.html",
    "href": "generation/generated/rse_management.html",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "",
    "text": "This module comprises the communication and management skills that are relevant for working in the interdisciplinary setting of RSE-professionals.\nThis includes but is not limited to:\n\nworking in a team (see TEAM in (Goth et al. 2024))\nteaching RSE-basics (see TEACH in (Goth et al. 2024))\nproject management (see PM in (Goth et al. 2024))\ninteraction with users and other stakeholders (see USERS in (Goth et al. 2024))\n\nThe lecture covers project and team management techniques an RSE needs in everyday life and the taught methods are applied and practiced with case-studys, role-plays etc. in the exercise.\n\n\n\n\nresearch management\n\nresearch cycle\nopen science, FAIR, FAIR4RS\npublication workflow: obstacles and embargoes\nlegal aspects of research data, e.g. GDPR\npseudonymization/anonymization methods for data privacy\npublic databases\n\nquality control\n\nrequirements engineering\ntrying goals with quality: test-driven development\nbehavior-driven development, Gherkin-Style acceptance testing\nproject folder organization\ncode review principles\n\ncommunication and collaboration\n\ncommunication frameworks, e.g. AIDA, RACE, 7 C’s\npersonality traits and their impact on cooperation\ncollaboration frameworks for remote work\nrealisation and benefits of pair programming and mob/ensemble programming\ntechnical English writing skills: writing in issues and merge requests, code review…\nconflict management, e.g. dealing with researchers that do not listen\nhow to address relevant stakeholders (i.e. users and SEs) with different background knowledge, experience and expectations\nequity, diversity and inclusion principles\n\nteam management\n\nchallenges of transient teams (that only exist for 5-15 hours)\neffects of varying team sizes\nmanagement depending on project size/type\nspecialised roles in a software team\nintercultural and interdisciplinary differences\nteam management methodologies\nimportance of shared values in a RSE team\ndual goals: project vs. personal goal\n\ntime and project management\n\ngoal-setting\nproject management methods, their strengths and weaknesses\nagile (not necessarily Scrum)\nLean & Kanban (Small-Batch Philosophies)\ndivision of tasks into sub-tasks and task-dependencies\niterative workflows\ncontinuous delivery\ncommunication with a manager/supervisor\n\n\nLecture: RSEng Management Lecture\nSWS: 2 ECTS: 3\nExercise: RSEng Management Exercise\nSWS: 2 ECTS: 3\n\n\n\n\n\n\nID\nDescription\nDisciplines\nPrerequisites\nEvidence\nAuthor\nSource\n\n\n\n\nrse_practices_8\nBuild and manage sustainable research software communities\nResearch Software Engineering, Community Engagement\nrse_tooling_13\nDocument strategies used for user engagement, feedback, and community growth in a real project\nRSE Curriculum Draft\nLink\n\n\nrse_practices_9\nWork in an agile software development process, including requirement gathering and iteration\nResearch Software Engineering\n\nSubmit a project that uses agile planning (e.g., user stories, sprints, stand-ups) and reflects on iteration outcomes\nRSE Curriculum Draft\nLink\n\n\nrse_practices_10\nDefine project scope, gather requirements, and manage stakeholder expectations\nResearch Software Engineering\n\nProvide a requirements document and stakeholder communication log for a software project\nRSE Curriculum Draft\nLink\n\n\nrse_practices_11\nPlan for software maintenance and long-term sustainability, including archiving strategies\nResearch Software Engineering\nrse_practices_6\nSubmit a sustainability or exit plan describing how the software will be maintained or archived\nRSE Curriculum Draft\nLink\n\n\nrse_management_01\nExplain particular implementation choices in a convincing manner\nResearch Software Engineering\n\nDeliver a defense of chosen implementation decisions in a discussion with a domain expert who has limited technical knowledge (ideally oral examination or project presentation with potential ‘customer/user’ questions)\nRSE Community\nLink\n\n\nrse_management_02\nExemplify and articulate shared team values and their impact on work\nResearch Software Engineering\n\nIdentify core team values and demonstrate how they influence key implementation decisions (e.g., design, communication, and collaboration)\nRSE Community\nLink\n\n\nrse_management_03\nPlan and manage projects using standard methods effectively and efficiently\nResearch Software Engineering\n\nDevelop a comprehensive project plan for a given project, including scope, milestones, risks, resources, and success criteria\nRSE Community\nLink\n\n\nrse_management_04\nDiscuss methods to set up a Diversity, Equity and Inclusion (DEI) framework in an RSE team\nResearch Software Engineering\n\nAnalyse and evaluate a DEI framework for a given project\nRSE Community\nLink\n\n\n\n\n\n\n\n\n\nRSE Leadership Course\nProfessionelles Projektmanagement in der Praxis\nCommunication Psychology\nGrundlagen des Management\nSoftware-Projektmanagement\nProjektmanagement\nOrganizational Behavior & Human Resource Management\n\n\n\n\n\nRemote Mob Programming\nCode with the Wisdom of the Crowd\nCollaboration Explained\nTeam Topologies\nTechnical Agile Coaching with the Samman method\nLean Product and Process Development\nExtreme Programming Explained\n\n\n\n\n\nRWTH Informatik Bachelor\nRWTH Informatik Master\nJMUW Informatik Master\n\n\n\nGoth, F, R Alves, M Braun, LJ Castro, G Chourdakis, S Christ, J Cohen, et al. 2024. “Foundational Competencies and Responsibilities of a Research Software Engineer [Version 1; Peer Review: Awaiting Peer Review].” F1000Research 13 (1429). https://doi.org/10.12688/f1000research.157778.1."
  },
  {
    "objectID": "generation/generated/rse_management.html#rseng-management-and-communication",
    "href": "generation/generated/rse_management.html#rseng-management-and-communication",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "",
    "text": "This module comprises the communication and management skills that are relevant for working in the interdisciplinary setting of RSE-professionals.\nThis includes but is not limited to:\n\nworking in a team (see TEAM in (Goth et al. 2024))\nteaching RSE-basics (see TEACH in (Goth et al. 2024))\nproject management (see PM in (Goth et al. 2024))\ninteraction with users and other stakeholders (see USERS in (Goth et al. 2024))\n\nThe lecture covers project and team management techniques an RSE needs in everyday life and the taught methods are applied and practiced with case-studys, role-plays etc. in the exercise.\n\n\n\n\nresearch management\n\nresearch cycle\nopen science, FAIR, FAIR4RS\npublication workflow: obstacles and embargoes\nlegal aspects of research data, e.g. GDPR\npseudonymization/anonymization methods for data privacy\npublic databases\n\nquality control\n\nrequirements engineering\ntrying goals with quality: test-driven development\nbehavior-driven development, Gherkin-Style acceptance testing\nproject folder organization\ncode review principles\n\ncommunication and collaboration\n\ncommunication frameworks, e.g. AIDA, RACE, 7 C’s\npersonality traits and their impact on cooperation\ncollaboration frameworks for remote work\nrealisation and benefits of pair programming and mob/ensemble programming\ntechnical English writing skills: writing in issues and merge requests, code review…\nconflict management, e.g. dealing with researchers that do not listen\nhow to address relevant stakeholders (i.e. users and SEs) with different background knowledge, experience and expectations\nequity, diversity and inclusion principles\n\nteam management\n\nchallenges of transient teams (that only exist for 5-15 hours)\neffects of varying team sizes\nmanagement depending on project size/type\nspecialised roles in a software team\nintercultural and interdisciplinary differences\nteam management methodologies\nimportance of shared values in a RSE team\ndual goals: project vs. personal goal\n\ntime and project management\n\ngoal-setting\nproject management methods, their strengths and weaknesses\nagile (not necessarily Scrum)\nLean & Kanban (Small-Batch Philosophies)\ndivision of tasks into sub-tasks and task-dependencies\niterative workflows\ncontinuous delivery\ncommunication with a manager/supervisor\n\n\nLecture: RSEng Management Lecture\nSWS: 2 ECTS: 3\nExercise: RSEng Management Exercise\nSWS: 2 ECTS: 3\n\n\n\n\n\n\nID\nDescription\nDisciplines\nPrerequisites\nEvidence\nAuthor\nSource\n\n\n\n\nrse_practices_8\nBuild and manage sustainable research software communities\nResearch Software Engineering, Community Engagement\nrse_tooling_13\nDocument strategies used for user engagement, feedback, and community growth in a real project\nRSE Curriculum Draft\nLink\n\n\nrse_practices_9\nWork in an agile software development process, including requirement gathering and iteration\nResearch Software Engineering\n\nSubmit a project that uses agile planning (e.g., user stories, sprints, stand-ups) and reflects on iteration outcomes\nRSE Curriculum Draft\nLink\n\n\nrse_practices_10\nDefine project scope, gather requirements, and manage stakeholder expectations\nResearch Software Engineering\n\nProvide a requirements document and stakeholder communication log for a software project\nRSE Curriculum Draft\nLink\n\n\nrse_practices_11\nPlan for software maintenance and long-term sustainability, including archiving strategies\nResearch Software Engineering\nrse_practices_6\nSubmit a sustainability or exit plan describing how the software will be maintained or archived\nRSE Curriculum Draft\nLink\n\n\nrse_management_01\nExplain particular implementation choices in a convincing manner\nResearch Software Engineering\n\nDeliver a defense of chosen implementation decisions in a discussion with a domain expert who has limited technical knowledge (ideally oral examination or project presentation with potential ‘customer/user’ questions)\nRSE Community\nLink\n\n\nrse_management_02\nExemplify and articulate shared team values and their impact on work\nResearch Software Engineering\n\nIdentify core team values and demonstrate how they influence key implementation decisions (e.g., design, communication, and collaboration)\nRSE Community\nLink\n\n\nrse_management_03\nPlan and manage projects using standard methods effectively and efficiently\nResearch Software Engineering\n\nDevelop a comprehensive project plan for a given project, including scope, milestones, risks, resources, and success criteria\nRSE Community\nLink\n\n\nrse_management_04\nDiscuss methods to set up a Diversity, Equity and Inclusion (DEI) framework in an RSE team\nResearch Software Engineering\n\nAnalyse and evaluate a DEI framework for a given project\nRSE Community\nLink\n\n\n\n\n\n\n\n\n\nRSE Leadership Course\nProfessionelles Projektmanagement in der Praxis\nCommunication Psychology\nGrundlagen des Management\nSoftware-Projektmanagement\nProjektmanagement\nOrganizational Behavior & Human Resource Management\n\n\n\n\n\nRemote Mob Programming\nCode with the Wisdom of the Crowd\nCollaboration Explained\nTeam Topologies\nTechnical Agile Coaching with the Samman method\nLean Product and Process Development\nExtreme Programming Explained\n\n\n\n\n\nRWTH Informatik Bachelor\nRWTH Informatik Master\nJMUW Informatik Master\n\n\n\nGoth, F, R Alves, M Braun, LJ Castro, G Chourdakis, S Christ, J Cohen, et al. 2024. “Foundational Competencies and Responsibilities of a Research Software Engineer [Version 1; Peer Review: Awaiting Peer Review].” F1000Research 13 (1429). https://doi.org/10.12688/f1000research.157778.1."
  },
  {
    "objectID": "generation/generated/rse_hpc.html",
    "href": "generation/generated/rse_hpc.html",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "",
    "text": "RSEs with expertise in HPC and other performance-critical computing domains specialize in optimizing code for efficient execution across various platforms, including clusters, cloud, edge, and embedded systems. They understand parallel programming models, hardware-specific optimizations, profiling tools, and platform constraints such as memory, energy, and latency. Their skills enable them to adapt software to diverse infrastructures, manage complex dependencies, and support researchers in accessing and using advanced computing resources effectively and sustainably.\n\n\nBuilding on “Basic Scientific Computing”, this module dives deeper into scalable algorithms, architectures, and software engineering techniques required to run large‑scale simulations and data analysis on high‑performance computing (HPC) systems.\n\n\n\nParticipants who successfully complete the module will be able to\n\nClassify scientific problems by their dominant parallel pattern (memory‑parallel, compute‑parallel, task‑parallel).\nMap each class to appropriate numerical libraries and hardware architectures.\nAnalyse floating‑point and algorithmic approximation errors at scale.\nExplain modern HPC hardware features (GPUs, SIMD/AVX, NUMA, high‑speed interconnects) and select relevant optimisation strategies.\nDesign portable, performance‑portable code employing MPI, OpenMP, and accelerator frameworks.\nUse continuous benchmarking to guide sustainable performance evolution of research software.\nPlan for long‑term maintenance, archival, and FAIR publication of large‑scale codes and data.\n\n\n\n\n\n\n\n\n\n\n\n\nWeek\nTheme\nTopics\n\n\n\n\n1\nParallel Problem Taxonomy\nSparse vs. dense linear algebra · embarrassingly parallel workloads\n\n\n2\nDistributed Memory (MPI)\nDomain decomposition · halo exchange · scalability metrics\n\n\n3\nShared Memory & SIMD\nOpenMP · threading pitfalls · AVX intrinsics\n\n\n4\nAccelerator Programming\nMulti‑GPU kernels · unified memory · portability layers (Kokkos, SYCL)\n\n\n5\nAdvanced I/O & Checkpointing\nParallel file systems · burst buffers · HDF5/ADIOS‑based workflows\n\n\n6\nPerformance Engineering\nRoofline model · continuous & comparative benchmarking · autotuning\n\n\n7\nSustainable HPC Software\nRelease engineering · long‑term archiving · community governance\n\n\n\n\n\n\nBlended delivery: interactive lectures (40%), coding workshops on the national cluster (50%), expert seminars (10%).\n\n\n\n\n\n\n\n\n\n\n\nComponent\nWeight\nDetails\n\n\n\n\nCluster labs\n30%\nSubmission of working MPI/OpenMP/GPU exercises\n\n\nPerformance study\n30%\nRoofline + scaling analysis of an existing code\n\n\nCapstone project\n40%\nImplement & optimise a solver or ML pipeline at scale, plus written report\n\n\n\n\n\n\n\nCompletion of - Scientific Computing or equivalent experience\nFamiliarity with Linux command line and version control\n\n\n\n\n\nreplace CHatGPT fantasies\n\nLecture: High Performance Computing\nSWS: 2 ECTS: 3\nExercise: High Performance Computing Exercise\nSWS: 2 ECTS: 3\n\n\n\n\n\n\nID\nDescription\nDisciplines\nPrerequisites\nEvidence\nAuthor\nSource\n\n\n\n\nhpc_module_1\nRun batch and array jobs on a cluster, including job dependencies\nHigh-Performance Computing\nrse_tooling_3\nSubmit job scripts using SLURM or similar systems demonstrating correct use of job arrays and dependencies\nRSE Curriculum Draft\nLink\n\n\nhpc_module_2\nIdentify and manage common challenges in HPC systems (e.g., I/O bottlenecks, threading, NUMA memory)\nHigh-Performance Computing\nhpc_module_1\nProvide performance logs and interpret bottlenecks in a real or simulated HPC task\nRSE Curriculum Draft\nLink\n\n\nhpc_module_3\nUse shell scripting (e.g., Bash) to automate HPC job submission\nHigh-Performance Computing\nrse_tooling_3\nSubmit scripts that automate the execution of HPC jobs and handle job logic\nRSE Curriculum Draft\nLink\n\n\nhpc_module_4\nUnderstand and use the principles of accelerator programming (e.g., GPU kernels and frameworks)\nHigh-Performance Computing\n\nSubmit a small CUDA or OpenCL program with documentation of the principles used\nRSE Curriculum Draft\nLink\n\n\nhpc_module_5\nMaintain scientific computing software including use of continuous benchmarking\nHigh-Performance Computing\ncomp_module_1\nProvide benchmark and performance history for evolving versions of software\nRSE Curriculum Draft\nLink\n\n\n\n\n\n\n\n\n\nEUMaster4HPC\n\n\n\n\n\nHPC Chapel\nHPC Workflow Management with Snakemake\nHPC Workflow Management with Maestro\nParallelisation using Python for HPC\nIntroduction to Containers\nAn Introduction to High Performance Computing\nHPC Python\nUsing the Shell for HPC\nGreen software use on HPC\nIntroduction to the Linux Command Line\nIntroduction to HPC (at Imperial)\nViral Instructions Hardware\nHPC Computing\nHigh-Performance Computing\nIntroduction to Parallel Programming (Python)\n\n\n\n\n\nWhat every computer scientist should know about floating-point arithmetic\n\n\n\n\n\nHPC-carpentry\nRWTH Informatik Bachelor\nRWTH Informatik Master"
  },
  {
    "objectID": "generation/generated/rse_hpc.html#highperformance-computing-for-rse",
    "href": "generation/generated/rse_hpc.html#highperformance-computing-for-rse",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "",
    "text": "RSEs with expertise in HPC and other performance-critical computing domains specialize in optimizing code for efficient execution across various platforms, including clusters, cloud, edge, and embedded systems. They understand parallel programming models, hardware-specific optimizations, profiling tools, and platform constraints such as memory, energy, and latency. Their skills enable them to adapt software to diverse infrastructures, manage complex dependencies, and support researchers in accessing and using advanced computing resources effectively and sustainably.\n\n\nBuilding on “Basic Scientific Computing”, this module dives deeper into scalable algorithms, architectures, and software engineering techniques required to run large‑scale simulations and data analysis on high‑performance computing (HPC) systems.\n\n\n\nParticipants who successfully complete the module will be able to\n\nClassify scientific problems by their dominant parallel pattern (memory‑parallel, compute‑parallel, task‑parallel).\nMap each class to appropriate numerical libraries and hardware architectures.\nAnalyse floating‑point and algorithmic approximation errors at scale.\nExplain modern HPC hardware features (GPUs, SIMD/AVX, NUMA, high‑speed interconnects) and select relevant optimisation strategies.\nDesign portable, performance‑portable code employing MPI, OpenMP, and accelerator frameworks.\nUse continuous benchmarking to guide sustainable performance evolution of research software.\nPlan for long‑term maintenance, archival, and FAIR publication of large‑scale codes and data.\n\n\n\n\n\n\n\n\n\n\n\n\nWeek\nTheme\nTopics\n\n\n\n\n1\nParallel Problem Taxonomy\nSparse vs. dense linear algebra · embarrassingly parallel workloads\n\n\n2\nDistributed Memory (MPI)\nDomain decomposition · halo exchange · scalability metrics\n\n\n3\nShared Memory & SIMD\nOpenMP · threading pitfalls · AVX intrinsics\n\n\n4\nAccelerator Programming\nMulti‑GPU kernels · unified memory · portability layers (Kokkos, SYCL)\n\n\n5\nAdvanced I/O & Checkpointing\nParallel file systems · burst buffers · HDF5/ADIOS‑based workflows\n\n\n6\nPerformance Engineering\nRoofline model · continuous & comparative benchmarking · autotuning\n\n\n7\nSustainable HPC Software\nRelease engineering · long‑term archiving · community governance\n\n\n\n\n\n\nBlended delivery: interactive lectures (40%), coding workshops on the national cluster (50%), expert seminars (10%).\n\n\n\n\n\n\n\n\n\n\n\nComponent\nWeight\nDetails\n\n\n\n\nCluster labs\n30%\nSubmission of working MPI/OpenMP/GPU exercises\n\n\nPerformance study\n30%\nRoofline + scaling analysis of an existing code\n\n\nCapstone project\n40%\nImplement & optimise a solver or ML pipeline at scale, plus written report\n\n\n\n\n\n\n\nCompletion of - Scientific Computing or equivalent experience\nFamiliarity with Linux command line and version control\n\n\n\n\n\nreplace CHatGPT fantasies\n\nLecture: High Performance Computing\nSWS: 2 ECTS: 3\nExercise: High Performance Computing Exercise\nSWS: 2 ECTS: 3\n\n\n\n\n\n\nID\nDescription\nDisciplines\nPrerequisites\nEvidence\nAuthor\nSource\n\n\n\n\nhpc_module_1\nRun batch and array jobs on a cluster, including job dependencies\nHigh-Performance Computing\nrse_tooling_3\nSubmit job scripts using SLURM or similar systems demonstrating correct use of job arrays and dependencies\nRSE Curriculum Draft\nLink\n\n\nhpc_module_2\nIdentify and manage common challenges in HPC systems (e.g., I/O bottlenecks, threading, NUMA memory)\nHigh-Performance Computing\nhpc_module_1\nProvide performance logs and interpret bottlenecks in a real or simulated HPC task\nRSE Curriculum Draft\nLink\n\n\nhpc_module_3\nUse shell scripting (e.g., Bash) to automate HPC job submission\nHigh-Performance Computing\nrse_tooling_3\nSubmit scripts that automate the execution of HPC jobs and handle job logic\nRSE Curriculum Draft\nLink\n\n\nhpc_module_4\nUnderstand and use the principles of accelerator programming (e.g., GPU kernels and frameworks)\nHigh-Performance Computing\n\nSubmit a small CUDA or OpenCL program with documentation of the principles used\nRSE Curriculum Draft\nLink\n\n\nhpc_module_5\nMaintain scientific computing software including use of continuous benchmarking\nHigh-Performance Computing\ncomp_module_1\nProvide benchmark and performance history for evolving versions of software\nRSE Curriculum Draft\nLink\n\n\n\n\n\n\n\n\n\nEUMaster4HPC\n\n\n\n\n\nHPC Chapel\nHPC Workflow Management with Snakemake\nHPC Workflow Management with Maestro\nParallelisation using Python for HPC\nIntroduction to Containers\nAn Introduction to High Performance Computing\nHPC Python\nUsing the Shell for HPC\nGreen software use on HPC\nIntroduction to the Linux Command Line\nIntroduction to HPC (at Imperial)\nViral Instructions Hardware\nHPC Computing\nHigh-Performance Computing\nIntroduction to Parallel Programming (Python)\n\n\n\n\n\nWhat every computer scientist should know about floating-point arithmetic\n\n\n\n\n\nHPC-carpentry\nRWTH Informatik Bachelor\nRWTH Informatik Master"
  },
  {
    "objectID": "generation/generated/mnt_project.html",
    "href": "generation/generated/mnt_project.html",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "",
    "text": "Applied Research Software Engineering in STEM sciences\nThis lab module provides students with a hands-on opportunity to apply research software engineering principles to real-world scientific problems from the MINT disciplines (Mathematics, Informatics, Natural Sciences, and Technology). Students work on projects originating from active research contexts — such as simulations in physics, data analysis in chemistry, modeling in biology, or\nLab: Science Lab Project\nSWS: 4 ECTS: 6\n\n\n\n\n\nID\nDescription\nDisciplines\nPrerequisites\nEvidence\nAuthor\nSource\n\n\n\n\nNone\n\nWildcard Domain Science\n\n\n\nLink\n\n\n\n\n\n\n\n\n\nUP Master Bioinformatik"
  },
  {
    "objectID": "generation/generated/mnt_project.html#science-lab-module",
    "href": "generation/generated/mnt_project.html#science-lab-module",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "",
    "text": "Applied Research Software Engineering in STEM sciences\nThis lab module provides students with a hands-on opportunity to apply research software engineering principles to real-world scientific problems from the MINT disciplines (Mathematics, Informatics, Natural Sciences, and Technology). Students work on projects originating from active research contexts — such as simulations in physics, data analysis in chemistry, modeling in biology, or\nLab: Science Lab Project\nSWS: 4 ECTS: 6\n\n\n\n\n\nID\nDescription\nDisciplines\nPrerequisites\nEvidence\nAuthor\nSource\n\n\n\n\nNone\n\nWildcard Domain Science\n\n\n\nLink\n\n\n\n\n\n\n\n\n\nUP Master Bioinformatik"
  },
  {
    "objectID": "generation/generated/mnt_compwildcard.html",
    "href": "generation/generated/mnt_compwildcard.html",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "",
    "text": "This module offers RSE students the opportunity to deepen their understanding of computational methods specific to a science discipline. Students choose a science module — such as physics, chemistry, biology, or earth sciences — and engage with its computational practices, core questions, and data/software challenges.\nThe goal is to apply the general competences acquired in the general programming and software engineering courses to the practices and special needs of the chosen discipline. Computational Physics might face different algorithmic or conceptual challenges than computational chemistry. This module is intended for the case that the institution offers such a specialized computational course.\nLecture: Computational Wildcard Science\nSWS: 2 ECTS: 3\nLab: Computational Wildcard Science Lab\nSWS: 2 ECTS: 3\n\n\n\n\n\nID\nDescription\nDisciplines\nPrerequisites\nEvidence\nAuthor\nSource\n\n\n\n\nNone\n\nWildcard Domain Science\n\n\n\nLink\n\n\n\n\n\n\n\n\n\nComputational Chemistry\nComputational Physics\nComputeranwendungen in der Chemie\n\n\n\n\n\nUP Master Bioinformatik\nUP Computational Science Master\nRWTH Informatik Bachelor\nRWTH Informatik Master"
  },
  {
    "objectID": "generation/generated/mnt_compwildcard.html#wildcard-computational-science",
    "href": "generation/generated/mnt_compwildcard.html#wildcard-computational-science",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "",
    "text": "This module offers RSE students the opportunity to deepen their understanding of computational methods specific to a science discipline. Students choose a science module — such as physics, chemistry, biology, or earth sciences — and engage with its computational practices, core questions, and data/software challenges.\nThe goal is to apply the general competences acquired in the general programming and software engineering courses to the practices and special needs of the chosen discipline. Computational Physics might face different algorithmic or conceptual challenges than computational chemistry. This module is intended for the case that the institution offers such a specialized computational course.\nLecture: Computational Wildcard Science\nSWS: 2 ECTS: 3\nLab: Computational Wildcard Science Lab\nSWS: 2 ECTS: 3\n\n\n\n\n\nID\nDescription\nDisciplines\nPrerequisites\nEvidence\nAuthor\nSource\n\n\n\n\nNone\n\nWildcard Domain Science\n\n\n\nLink\n\n\n\n\n\n\n\n\n\nComputational Chemistry\nComputational Physics\nComputeranwendungen in der Chemie\n\n\n\n\n\nUP Master Bioinformatik\nUP Computational Science Master\nRWTH Informatik Bachelor\nRWTH Informatik Master"
  },
  {
    "objectID": "generation/generated/gen_softwareeng1.html",
    "href": "generation/generated/gen_softwareeng1.html",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "",
    "text": "To summarise the vast range of the skills a software engineer is typically equipped with, we refer to the Guide to the Software Engineering Body of Knowledge (Bourque, Fairley, and IEEE Computer Society 2014). Because research software engineering is an interface discipline, RSEs are often stronger in topics more commonly encountered in research software contexts (e.g., mathematical and engineering foundations) than in other areas (e.g., software engineering economics). However, they bring a solid level of competence in all software engineering topics. Therefore, RSEs can set and analyse software requirements in the context of open-ended, question-driven research. They can design software so that it can sustainably grow, often in an environment of rapid turnover of contributors. They are competent in implementing solutions themselves in a wide range of technologies fit for different scientific applications. They can formulate and implement various types of tests, they can independently maintain software and automate operations of the integration and release process. They can provide working, scalable, and future-proof solutions in a professional context and with common project and software management techniques, adapted to the needs of the research environment. Finally, as people who have often gained significant research experience in a particular discipline, they combine the necessary foundations from their domain with software engineering skills to develop complex software.(Goth et al. 2024)\nThis module tries to lay the foundations for the advanced RSE software engineering training.\n\n\nBourque, Pierre, Richard E. Fairley, and IEEE Computer Society. 2014. Guide to the Software Engineering Body of Knowledge (SWEBOK(R)): Version 3.0. 3rd ed. Washington, DC, USA: IEEE Computer Society Press.\n\n\nGoth, F, R Alves, M Braun, LJ Castro, G Chourdakis, S Christ, J Cohen, et al. 2024. “Foundational Competencies and Responsibilities of a Research Software Engineer [Version 1; Peer Review: Awaiting Peer Review].” F1000Research 13 (1429). https://doi.org/10.12688/f1000research.157778.1.\n\n\n\n\n\nBasic concepts of software engineering,\nsoftware and product life cycle,\nprocess models for the design of large software systems,\nsemantic aspects of domain description, hierarchy, parallelism, real-time and embedded systems as fundamental paradigms,\norganizational principles of complex software systems, design by contract,\npatterns in modeling and design methods of quality assurance, evolution and re-engineering,\nselected languages and tools for process- and object-oriented modeling,\nmethods and languages for object-oriented design, architectures and architectural patterns of software systems,\narchitecture of enterprise applications,\ndesign and implementation models in the object-oriented paradigm, e.g., Java 2 SE, design patterns, software testing methods\na selection of advanced topics such as software quality assurance, service engineering, virtualization, and formal methods in system design\n\nLecture: Software Engineering I\nSWS: 2 ECTS: 4\nExercise: Software Engineering I Exercise\nSWS: 2 ECTS: 2\n\n\n\n\n\n\nID\nDescription\nDisciplines\nPrerequisites\nEvidence\nAuthor\nSource\n\n\n\n\ngen_programming_1\nUnderstand the fundamental concepts of software engineering\nComputer Science\n\nDemonstrate understanding through theoretical assessments and practical examples\nUniversity of Potsdam\nLink\n\n\ngen_programming_2\nApply various approaches of software engineering\nComputer Science\ngen_programming_1\nComplete assignments or projects using different software engineering methods\nUniversity of Potsdam\nLink\n\n\ngen_programming_3\nIdentify and utilize essential technologies and tools for specification, component-based development, and quality assurance of modern software systems\nComputer Science\ngen_programming_1\nWork with selected tools and technologies in practical exercises and case studies\nUniversity of Potsdam\nLink\n\n\ngen_programming_4\nDemonstrate an in-depth understanding and ability to apply various approaches of software engineering\nComputer Science\ngen_programming_1, gen_programming_2\nSuccessfully complete advanced projects employing different software engineering methods\nUniversity of Potsdam\nLink\n\n\ngen_programming_5\nUnderstand the characteristics of a wide range of technologies and tools for specification, component-based development, and quality assurance of modern software systems, and apply them in various contexts\nComputer Science\ngen_programming_3\nApply appropriate technologies and tools in complex case studies and demonstrate their use in different application scenarios\nUniversity of Potsdam\nLink\n\n\n\n\n\n\n\n\n\nComputing Curricula 2020\n\n\n\n\n\nEssential Software Engineering\nSoftware Engineering I\nSoftware Engineering\nSoftwaretechnik\nSoftware Engineering\n\n\n\n\n\nUP Informatik/Computational Science Bachelor\nJMUW Informatik Bachelor\nRWTH Informatik Bachelor\nUdS Informatik Bachelor\n\n\n\nBourque, Pierre, Richard E. Fairley, and IEEE Computer Society. 2014. Guide to the Software Engineering Body of Knowledge (SWEBOK(R)): Version 3.0. 3rd ed. Washington, DC, USA: IEEE Computer Society Press.\n\n\nGoth, F, R Alves, M Braun, LJ Castro, G Chourdakis, S Christ, J Cohen, et al. 2024. “Foundational Competencies and Responsibilities of a Research Software Engineer [Version 1; Peer Review: Awaiting Peer Review].” F1000Research 13 (1429). https://doi.org/10.12688/f1000research.157778.1."
  },
  {
    "objectID": "generation/generated/gen_softwareeng1.html#classical-software-engineering-i",
    "href": "generation/generated/gen_softwareeng1.html#classical-software-engineering-i",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "",
    "text": "To summarise the vast range of the skills a software engineer is typically equipped with, we refer to the Guide to the Software Engineering Body of Knowledge (Bourque, Fairley, and IEEE Computer Society 2014). Because research software engineering is an interface discipline, RSEs are often stronger in topics more commonly encountered in research software contexts (e.g., mathematical and engineering foundations) than in other areas (e.g., software engineering economics). However, they bring a solid level of competence in all software engineering topics. Therefore, RSEs can set and analyse software requirements in the context of open-ended, question-driven research. They can design software so that it can sustainably grow, often in an environment of rapid turnover of contributors. They are competent in implementing solutions themselves in a wide range of technologies fit for different scientific applications. They can formulate and implement various types of tests, they can independently maintain software and automate operations of the integration and release process. They can provide working, scalable, and future-proof solutions in a professional context and with common project and software management techniques, adapted to the needs of the research environment. Finally, as people who have often gained significant research experience in a particular discipline, they combine the necessary foundations from their domain with software engineering skills to develop complex software.(Goth et al. 2024)\nThis module tries to lay the foundations for the advanced RSE software engineering training.\n\n\nBourque, Pierre, Richard E. Fairley, and IEEE Computer Society. 2014. Guide to the Software Engineering Body of Knowledge (SWEBOK(R)): Version 3.0. 3rd ed. Washington, DC, USA: IEEE Computer Society Press.\n\n\nGoth, F, R Alves, M Braun, LJ Castro, G Chourdakis, S Christ, J Cohen, et al. 2024. “Foundational Competencies and Responsibilities of a Research Software Engineer [Version 1; Peer Review: Awaiting Peer Review].” F1000Research 13 (1429). https://doi.org/10.12688/f1000research.157778.1.\n\n\n\n\n\nBasic concepts of software engineering,\nsoftware and product life cycle,\nprocess models for the design of large software systems,\nsemantic aspects of domain description, hierarchy, parallelism, real-time and embedded systems as fundamental paradigms,\norganizational principles of complex software systems, design by contract,\npatterns in modeling and design methods of quality assurance, evolution and re-engineering,\nselected languages and tools for process- and object-oriented modeling,\nmethods and languages for object-oriented design, architectures and architectural patterns of software systems,\narchitecture of enterprise applications,\ndesign and implementation models in the object-oriented paradigm, e.g., Java 2 SE, design patterns, software testing methods\na selection of advanced topics such as software quality assurance, service engineering, virtualization, and formal methods in system design\n\nLecture: Software Engineering I\nSWS: 2 ECTS: 4\nExercise: Software Engineering I Exercise\nSWS: 2 ECTS: 2\n\n\n\n\n\n\nID\nDescription\nDisciplines\nPrerequisites\nEvidence\nAuthor\nSource\n\n\n\n\ngen_programming_1\nUnderstand the fundamental concepts of software engineering\nComputer Science\n\nDemonstrate understanding through theoretical assessments and practical examples\nUniversity of Potsdam\nLink\n\n\ngen_programming_2\nApply various approaches of software engineering\nComputer Science\ngen_programming_1\nComplete assignments or projects using different software engineering methods\nUniversity of Potsdam\nLink\n\n\ngen_programming_3\nIdentify and utilize essential technologies and tools for specification, component-based development, and quality assurance of modern software systems\nComputer Science\ngen_programming_1\nWork with selected tools and technologies in practical exercises and case studies\nUniversity of Potsdam\nLink\n\n\ngen_programming_4\nDemonstrate an in-depth understanding and ability to apply various approaches of software engineering\nComputer Science\ngen_programming_1, gen_programming_2\nSuccessfully complete advanced projects employing different software engineering methods\nUniversity of Potsdam\nLink\n\n\ngen_programming_5\nUnderstand the characteristics of a wide range of technologies and tools for specification, component-based development, and quality assurance of modern software systems, and apply them in various contexts\nComputer Science\ngen_programming_3\nApply appropriate technologies and tools in complex case studies and demonstrate their use in different application scenarios\nUniversity of Potsdam\nLink\n\n\n\n\n\n\n\n\n\nComputing Curricula 2020\n\n\n\n\n\nEssential Software Engineering\nSoftware Engineering I\nSoftware Engineering\nSoftwaretechnik\nSoftware Engineering\n\n\n\n\n\nUP Informatik/Computational Science Bachelor\nJMUW Informatik Bachelor\nRWTH Informatik Bachelor\nUdS Informatik Bachelor\n\n\n\nBourque, Pierre, Richard E. Fairley, and IEEE Computer Society. 2014. Guide to the Software Engineering Body of Knowledge (SWEBOK(R)): Version 3.0. 3rd ed. Washington, DC, USA: IEEE Computer Society Press.\n\n\nGoth, F, R Alves, M Braun, LJ Castro, G Chourdakis, S Christ, J Cohen, et al. 2024. “Foundational Competencies and Responsibilities of a Research Software Engineer [Version 1; Peer Review: Awaiting Peer Review].” F1000Research 13 (1429). https://doi.org/10.12688/f1000research.157778.1."
  },
  {
    "objectID": "generation/generated/gen_datatext.html",
    "href": "generation/generated/gen_datatext.html",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "",
    "text": "This module introduces the students to text processing and information retrieval.\n\n\n\nIntroduction to textual data and Natural Language Processing (NLP): key concepts and use cases\nText acquisition and preprocessing: tokenisation, stemming/lemmatisation, stopwords, named entity recognition, text cleaning\nText representations: bag-of-words, TF-IDF, word embeddings (Word2Vec, GloVe), contextualised embeddings (BERT, RoBERTa, GPT variants)\nText mining and information extraction: key terms, topics, sentiment analysis, relation extraction\nInformation Retrieval and Web Search Engines\nData-to-insight pipelines: from raw text to structured data (CSV/SQL), feature engineering for text data\nModelling and evaluation: classification, regression, sequence models, transformers; evaluation metrics (accuracy, F1, MCC, AUC)\nPrototyping and reproducibility: experiment tracking, versioning, reproducible pipelines (Docker/Kubernetes, MLflow, DVC)\nRisk management and ethics: bias, fairness, data protection (GDPR), transparency, interpretability (LIME, SHAP)\nDeployment and practical applications: API-based models, batch vs real-time processing, monitoring\nProject work: from a research question to data collection, modelling, evaluation and documentation\n\n\n\n\n\nUnderstand how text data is collected, preprocessed, and transformed into usable formats\nBe able to select and justify different text representations\nApply NLP methods to extract relevant information from text\nDevelop, train and evaluate text-based models with attention to reproducibility and ethics\nAssess model limitations, interpretability, and risk of errors\nBuild a reproducible, scalable text-data pipeline\nCommunicate results clearly in reports, presentations, and prototype designs\n\n\n\n\nproject report (X pages) and presentation (15 minutes)\nLecture: Natural Language Processing\nSWS: 2 ECTS: 4\nExercise: Natural Language Processing Exercise\nSWS: 2 ECTS: 2\n\n\n\n\n\n\nEmpfehlungen Masterstudiengänge Data Science\n\n\n\n\n\nStatistische Methoden zur Verarbeitung natürlicher Sprache\nAdvanced Topics in Language and Text Processing\nMachine Learning for Natural Language Processing\n\n\n\n\n\nJMUW Informatik Bachelor\nJMUW Informatik Master\nRWTH Informatik Bachelor\nRWTH Informatik Master"
  },
  {
    "objectID": "generation/generated/gen_datatext.html#text-to-data-natural-language-processing",
    "href": "generation/generated/gen_datatext.html#text-to-data-natural-language-processing",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "",
    "text": "This module introduces the students to text processing and information retrieval.\n\n\n\nIntroduction to textual data and Natural Language Processing (NLP): key concepts and use cases\nText acquisition and preprocessing: tokenisation, stemming/lemmatisation, stopwords, named entity recognition, text cleaning\nText representations: bag-of-words, TF-IDF, word embeddings (Word2Vec, GloVe), contextualised embeddings (BERT, RoBERTa, GPT variants)\nText mining and information extraction: key terms, topics, sentiment analysis, relation extraction\nInformation Retrieval and Web Search Engines\nData-to-insight pipelines: from raw text to structured data (CSV/SQL), feature engineering for text data\nModelling and evaluation: classification, regression, sequence models, transformers; evaluation metrics (accuracy, F1, MCC, AUC)\nPrototyping and reproducibility: experiment tracking, versioning, reproducible pipelines (Docker/Kubernetes, MLflow, DVC)\nRisk management and ethics: bias, fairness, data protection (GDPR), transparency, interpretability (LIME, SHAP)\nDeployment and practical applications: API-based models, batch vs real-time processing, monitoring\nProject work: from a research question to data collection, modelling, evaluation and documentation\n\n\n\n\n\nUnderstand how text data is collected, preprocessed, and transformed into usable formats\nBe able to select and justify different text representations\nApply NLP methods to extract relevant information from text\nDevelop, train and evaluate text-based models with attention to reproducibility and ethics\nAssess model limitations, interpretability, and risk of errors\nBuild a reproducible, scalable text-data pipeline\nCommunicate results clearly in reports, presentations, and prototype designs\n\n\n\n\nproject report (X pages) and presentation (15 minutes)\nLecture: Natural Language Processing\nSWS: 2 ECTS: 4\nExercise: Natural Language Processing Exercise\nSWS: 2 ECTS: 2\n\n\n\n\n\n\nEmpfehlungen Masterstudiengänge Data Science\n\n\n\n\n\nStatistische Methoden zur Verarbeitung natürlicher Sprache\nAdvanced Topics in Language and Text Processing\nMachine Learning for Natural Language Processing\n\n\n\n\n\nJMUW Informatik Bachelor\nJMUW Informatik Master\nRWTH Informatik Bachelor\nRWTH Informatik Master"
  },
  {
    "objectID": "generation/generated/gen_datamaths.html",
    "href": "generation/generated/gen_datamaths.html",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "",
    "text": "This module covers the mathematical foundations of data science.\n\n\nThe module teaches the mathematical fundamentals of data science. Topics include a selection from the areas of graph analysis, stochastic models and signal analysis with wavelets.\n\n\n\nStudents will acquire comprehensive, detailed and specialised knowledge of the latest findings in selected fundamentals of data science. Students will have an in-depth understanding of selected data science methods. They will be able to analyse novel data assimilation and inference problems, develop and implement solutions, and determine the quality of the solutions. They will be able to develop new ideas and procedures, weigh up alternatives when information is incomplete, and evaluate them taking into account different assessment criteria.\n\n\n\nwritten exam (120 minutes) or oral exam (30 minutes)\nLecture: Mathematical Foundations of Data Science\nSWS: 2 ECTS: 2\nExercise: Mathematical Foundations of Data Science Exercise\nSWS: 2 ECTS: 4\n\n\n\n\n\n\nEmpfehlungen Masterstudiengänge Data Science\n\n\n\n\n\nMathematical Foundations of Data Science (MAT-DSAM8B)\nMathematical Foundations of Data Science\nAlgorithmic Foundations of Datascience\n\n\n\n\n\nUP Data Science Master\nJMUW Informatik Bachelor\nRWTH Informatik Bachelor\nRWTH Informatik Master"
  },
  {
    "objectID": "generation/generated/gen_datamaths.html#mathematical-foundations-of-data-science",
    "href": "generation/generated/gen_datamaths.html#mathematical-foundations-of-data-science",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "",
    "text": "This module covers the mathematical foundations of data science.\n\n\nThe module teaches the mathematical fundamentals of data science. Topics include a selection from the areas of graph analysis, stochastic models and signal analysis with wavelets.\n\n\n\nStudents will acquire comprehensive, detailed and specialised knowledge of the latest findings in selected fundamentals of data science. Students will have an in-depth understanding of selected data science methods. They will be able to analyse novel data assimilation and inference problems, develop and implement solutions, and determine the quality of the solutions. They will be able to develop new ideas and procedures, weigh up alternatives when information is incomplete, and evaluate them taking into account different assessment criteria.\n\n\n\nwritten exam (120 minutes) or oral exam (30 minutes)\nLecture: Mathematical Foundations of Data Science\nSWS: 2 ECTS: 2\nExercise: Mathematical Foundations of Data Science Exercise\nSWS: 2 ECTS: 4\n\n\n\n\n\n\nEmpfehlungen Masterstudiengänge Data Science\n\n\n\n\n\nMathematical Foundations of Data Science (MAT-DSAM8B)\nMathematical Foundations of Data Science\nAlgorithmic Foundations of Datascience\n\n\n\n\n\nUP Data Science Master\nJMUW Informatik Bachelor\nRWTH Informatik Bachelor\nRWTH Informatik Master"
  },
  {
    "objectID": "generation/generated/cs_securitycrypto.html",
    "href": "generation/generated/cs_securitycrypto.html",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "",
    "text": "This module deals with IT-security and cryptography.\n\n\n\nThe course offers a broad overview of concepts and technologies relevant to IT security: - Theoretical aspects: security in information theory and computability, introduction to cryptography (historical and modern ciphers, hash functions, pseudo-random number generators, message authentication codes, public-key cryptography) - Network security: security of protocols and TCP/IP, public key infrastructure, user authentication, Kerberos, IPsec, TLS protocol, SSH, DNS Security, Email Security, and Phishing Attacks. - Software security: security vulnerabilities, common programming errors and techniques for exploiting them, reverse engineering and obfuscation, malware and anti-malware - Platform security: access control models, security policies, operating system security, virtualisation, security mechanisms with hardware support - Methods for secure and reliable transmission and processing of information, error-correcting coding methods - Fundamentals of cryptographic systems, methods for information analysis, complexity aspects, applications - Necessary foundations of mathematics and complexity theory are introduced alongside the topics - Private key cryptosystems, Vernam one-time pad, AES, perfect security, public key cryptosystems, RSA, Diffie-Hellman, Elgamal, Goldwasser-Micali, digital signature, challenge-response procedure, secret sharing, millionaire problem, secure circuit evaluation, homomorphic encryption - Symmetric Encryption, Integrity protection, Asymmetric Encryption, Digital Signatures, Certificates and Public Key Infrastructures, and Authentication and Key Agreement\n\n\n\nStudents are able to - understand the mathematical foundations of secure and reliable information processing and their complexity-theoretical basis - are capable of analysing thesecurity of methods - model threats and evaluate the security of systems critically from the attacker’s perspective - understand the purpose and functioning of some security technologies and be aware of their limitations - select and apply appropriate cryptographic primitives in different application scenarios - select suitable security protocols for a given scenario and configure the relevant options for the cryptographic building blocks used within these protocols - identify security requirements and adequate security mechanisms in various application domains - identify potential weaknesses in security protocols not covered in detail during the course and propose appropriate fixes - assess the severity of novel attacks against security protocols and cryptographic primitives\n\n\n\n\nEither a written exam (90 minutes).\nOr an oral examination (30 minutes).\n\nLecture: Security and Cryptography\nSWS: 2 ECTS: 2\nExercise: Security and Cryptography Exercise\nSWS: 2 ECTS: 4\n\n\n\n\n\n\nID\nDescription\nDisciplines\nPrerequisites\nEvidence\nAuthor\nSource\n\n\n\n\nsec_complex_1\nexplain the necessity and methods of error-protected transmission and storage of data\nComputer Science\n\ndescribe and apply the taught methods to given examples\nUniversity of Potsdam\nLink\n\n\nsec_complex_2\nanalyse the correctness, security and complexity of algorithms\nComputer Science\n\nSubmit a written analysis for a given algorithm\nUniversity of Potsdam\nLink\n\n\n\n\n\n\n\n\n\nNone\n\n\n\n\n\nSicherheit, Information und Komplexität\nResiliente Systeme\nIT-Sicherheit I\nAlgorithmische Kryptographie\nEinführung in die IT-Sicherheit\nKryptographie und Datensicherheit\n\n\n\n\n\nNone\n\n\n\n\n\nUP Computational Science Master\nJMUW Informatik Bachelor\nJMUW Informatik Master\nRWTH Informatik Master"
  },
  {
    "objectID": "generation/generated/cs_securitycrypto.html#it-security-and-cryptography",
    "href": "generation/generated/cs_securitycrypto.html#it-security-and-cryptography",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "",
    "text": "This module deals with IT-security and cryptography.\n\n\n\nThe course offers a broad overview of concepts and technologies relevant to IT security: - Theoretical aspects: security in information theory and computability, introduction to cryptography (historical and modern ciphers, hash functions, pseudo-random number generators, message authentication codes, public-key cryptography) - Network security: security of protocols and TCP/IP, public key infrastructure, user authentication, Kerberos, IPsec, TLS protocol, SSH, DNS Security, Email Security, and Phishing Attacks. - Software security: security vulnerabilities, common programming errors and techniques for exploiting them, reverse engineering and obfuscation, malware and anti-malware - Platform security: access control models, security policies, operating system security, virtualisation, security mechanisms with hardware support - Methods for secure and reliable transmission and processing of information, error-correcting coding methods - Fundamentals of cryptographic systems, methods for information analysis, complexity aspects, applications - Necessary foundations of mathematics and complexity theory are introduced alongside the topics - Private key cryptosystems, Vernam one-time pad, AES, perfect security, public key cryptosystems, RSA, Diffie-Hellman, Elgamal, Goldwasser-Micali, digital signature, challenge-response procedure, secret sharing, millionaire problem, secure circuit evaluation, homomorphic encryption - Symmetric Encryption, Integrity protection, Asymmetric Encryption, Digital Signatures, Certificates and Public Key Infrastructures, and Authentication and Key Agreement\n\n\n\nStudents are able to - understand the mathematical foundations of secure and reliable information processing and their complexity-theoretical basis - are capable of analysing thesecurity of methods - model threats and evaluate the security of systems critically from the attacker’s perspective - understand the purpose and functioning of some security technologies and be aware of their limitations - select and apply appropriate cryptographic primitives in different application scenarios - select suitable security protocols for a given scenario and configure the relevant options for the cryptographic building blocks used within these protocols - identify security requirements and adequate security mechanisms in various application domains - identify potential weaknesses in security protocols not covered in detail during the course and propose appropriate fixes - assess the severity of novel attacks against security protocols and cryptographic primitives\n\n\n\n\nEither a written exam (90 minutes).\nOr an oral examination (30 minutes).\n\nLecture: Security and Cryptography\nSWS: 2 ECTS: 2\nExercise: Security and Cryptography Exercise\nSWS: 2 ECTS: 4\n\n\n\n\n\n\nID\nDescription\nDisciplines\nPrerequisites\nEvidence\nAuthor\nSource\n\n\n\n\nsec_complex_1\nexplain the necessity and methods of error-protected transmission and storage of data\nComputer Science\n\ndescribe and apply the taught methods to given examples\nUniversity of Potsdam\nLink\n\n\nsec_complex_2\nanalyse the correctness, security and complexity of algorithms\nComputer Science\n\nSubmit a written analysis for a given algorithm\nUniversity of Potsdam\nLink\n\n\n\n\n\n\n\n\n\nNone\n\n\n\n\n\nSicherheit, Information und Komplexität\nResiliente Systeme\nIT-Sicherheit I\nAlgorithmische Kryptographie\nEinführung in die IT-Sicherheit\nKryptographie und Datensicherheit\n\n\n\n\n\nNone\n\n\n\n\n\nUP Computational Science Master\nJMUW Informatik Bachelor\nJMUW Informatik Master\nRWTH Informatik Master"
  },
  {
    "objectID": "generation/generated/cs_embeddedsystems.html",
    "href": "generation/generated/cs_embeddedsystems.html",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "",
    "text": "Embedded systems control many things in our daily lives. Energy-efficient refrigerators, lift controls and advanced driver assistance systems are just a few examples. Embedded systems also control processes in industrial environments and are used to detect and prevent system failures. This lecture provides a general introduction to the topic of embedded systems and their performance. It presents basic concepts and highlights important differences to “normal” computer systems.\n\n\n\nThe module covers a selection of the following topics: - security, reliability, formal methods and dynamic systems. - microcontrollers - programmable logic controllers (PLCs) - PLC programming languages - real-time requirements - real-time operating systems - characteristics of embedded software design - intra-vehicle communication (e.g. CAN bus)\n\n\n\nStudents - can understand the solution to complex problems in embedded systems and apply those to related issues. - describe modern software techniques for embedded systems - apply a model-based, quality-oriented approach to the design of embedded software - recognise special quality requirements for the design of embedded software and take them into account appropriately\n\n\n\n\neither 120 min written exam\nor 20-30 min oral examination\n\nLecture: Embedded Systems\nSWS: 2 ECTS: 2\nExercise: Embedded Systems Exercise\nSWS: 2 ECTS: 4\n\n\n\n\n\n\nID\nDescription\nDisciplines\nPrerequisites\nEvidence\nAuthor\nSource\n\n\n\n\nemb_systems_1\nevalua\nComputer Science\n\nSub\n\nLink\n\n\n\n\n\n\n\n\n\nNone\n\n\n\n\n\nEingebettete Systeme\nAusgewählte Kapitel der Embedded Systems\n\n\n\n\n\nNone\n\n\n\n\n\nRWTH Informatik Master\nJMUW Informatik Master"
  },
  {
    "objectID": "generation/generated/cs_embeddedsystems.html#embedded-systems",
    "href": "generation/generated/cs_embeddedsystems.html#embedded-systems",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "",
    "text": "Embedded systems control many things in our daily lives. Energy-efficient refrigerators, lift controls and advanced driver assistance systems are just a few examples. Embedded systems also control processes in industrial environments and are used to detect and prevent system failures. This lecture provides a general introduction to the topic of embedded systems and their performance. It presents basic concepts and highlights important differences to “normal” computer systems.\n\n\n\nThe module covers a selection of the following topics: - security, reliability, formal methods and dynamic systems. - microcontrollers - programmable logic controllers (PLCs) - PLC programming languages - real-time requirements - real-time operating systems - characteristics of embedded software design - intra-vehicle communication (e.g. CAN bus)\n\n\n\nStudents - can understand the solution to complex problems in embedded systems and apply those to related issues. - describe modern software techniques for embedded systems - apply a model-based, quality-oriented approach to the design of embedded software - recognise special quality requirements for the design of embedded software and take them into account appropriately\n\n\n\n\neither 120 min written exam\nor 20-30 min oral examination\n\nLecture: Embedded Systems\nSWS: 2 ECTS: 2\nExercise: Embedded Systems Exercise\nSWS: 2 ECTS: 4\n\n\n\n\n\n\nID\nDescription\nDisciplines\nPrerequisites\nEvidence\nAuthor\nSource\n\n\n\n\nemb_systems_1\nevalua\nComputer Science\n\nSub\n\nLink\n\n\n\n\n\n\n\n\n\nNone\n\n\n\n\n\nEingebettete Systeme\nAusgewählte Kapitel der Embedded Systems\n\n\n\n\n\nNone\n\n\n\n\n\nRWTH Informatik Master\nJMUW Informatik Master"
  },
  {
    "objectID": "generation/generated/cs_efficientalgorithms.html",
    "href": "generation/generated/cs_efficientalgorithms.html",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "",
    "text": "This module deals with efficient algorithms, optimisation, and approximation algorithms.\n\n\n\nArchitecture and implementation of formal systems for the design of efficient algorithms, correctness-preserving optimisation, programme verification and synthesis. Design and analysis of approximation algorithms.\n\n\n\nStudents will be familiar with and understand basic techniques of formal programme development and its implementation. Students will be able to anticipate efficiency problems when designing algorithms and respond accordingly. Students will write better programmes that are highly optimised in their runtime-critical areas. Students will be able to analyse simple approximation methods in terms of their quality. They understand basic design techniques such as greedy, local search, scaling and methods based on linear programming and can also apply these to new problems.\n\n\n\n\nEither a 90-minute written exam.\nOr a 30 minute oral examination.\n\nLecture: Efficient Algorithms\nSWS: 2 ECTS: 2\nExercise: Efficient Algorithms Exercise\nSWS: 2 ECTS: 4\n\n\n\n\n\n\nID\nDescription\nDisciplines\nPrerequisites\nEvidence\nAuthor\nSource\n\n\n\n\neff_algorithms_1\ndescribe formal systems for the development of efficient algorithms and correctness-preserving optimisation\nComputer Science\n\nexemplary application of those formal methods\nUniversity of Potsdam\nLink\n\n\n\n\n\n\n\n\n\nNone\n\n\n\n\n\nEntwurf effizienter Algorithmen\nAnalyse von Algorithmen\nApproximationsalgorithmen\n\n\n\n\n\nNone\n\n\n\n\n\nUP Computational Science Master\nRWTH Informatik Master\nJMUW Informatik Master"
  },
  {
    "objectID": "generation/generated/cs_efficientalgorithms.html#design-of-efficient-algorithms",
    "href": "generation/generated/cs_efficientalgorithms.html#design-of-efficient-algorithms",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "",
    "text": "This module deals with efficient algorithms, optimisation, and approximation algorithms.\n\n\n\nArchitecture and implementation of formal systems for the design of efficient algorithms, correctness-preserving optimisation, programme verification and synthesis. Design and analysis of approximation algorithms.\n\n\n\nStudents will be familiar with and understand basic techniques of formal programme development and its implementation. Students will be able to anticipate efficiency problems when designing algorithms and respond accordingly. Students will write better programmes that are highly optimised in their runtime-critical areas. Students will be able to analyse simple approximation methods in terms of their quality. They understand basic design techniques such as greedy, local search, scaling and methods based on linear programming and can also apply these to new problems.\n\n\n\n\nEither a 90-minute written exam.\nOr a 30 minute oral examination.\n\nLecture: Efficient Algorithms\nSWS: 2 ECTS: 2\nExercise: Efficient Algorithms Exercise\nSWS: 2 ECTS: 4\n\n\n\n\n\n\nID\nDescription\nDisciplines\nPrerequisites\nEvidence\nAuthor\nSource\n\n\n\n\neff_algorithms_1\ndescribe formal systems for the development of efficient algorithms and correctness-preserving optimisation\nComputer Science\n\nexemplary application of those formal methods\nUniversity of Potsdam\nLink\n\n\n\n\n\n\n\n\n\nNone\n\n\n\n\n\nEntwurf effizienter Algorithmen\nAnalyse von Algorithmen\nApproximationsalgorithmen\n\n\n\n\n\nNone\n\n\n\n\n\nUP Computational Science Master\nRWTH Informatik Master\nJMUW Informatik Master"
  },
  {
    "objectID": "generation/generated/cs_declarativeprogramming.html",
    "href": "generation/generated/cs_declarativeprogramming.html",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "",
    "text": "This module deals with delarative modelling, problem-solving and programming. It can focus on the functional or logial programming paradigm.\n\n\n\n\nLogical-relational programming paradigm, top-down evaluation with SLD(NF) resolution. Introduction to the logical programming language Prolog: recursion, predicate-oriented programming, backtracking and cut, side effects, aggregations. Connection to (deductive) databases. Comparison with Datalog and brief introduction to advanced concepts such as constraint logic programming.\nPredicate logic fundamentals: Unification, Resolution, Horn clauses and SLD resolution\nLogic programmes: Operational and denotational semantics, Evaluation strategies\nThe Prolog programming language: Negation as failure, Non-logical components of Prolog, Programming techniques\nApplications and extensions of logic programming OR\nIntroduction to the Haskell programming language: Syntax of the various language constructs, Higher-order functions, Programming with lazy evaluation\nDenotational semantics of functional programmes: Complete orders and fixed points, Denotational semantics of Haskell\nLambda calculus: Syntax and operational semantics of lambda calculus, Reduction of Haskell to lambda calculus\nType checking and type inference\n\n\n\n\nStudents - have a broad, detailed and critical understanding of the latest knowledge in selected specialist areas in the field of declarative modelling - can implement compact and declarative programmes in Prolog and distinguish this approach from classical imperative programming - formally define the semantics of logical programming languages - targeted use of logical programming languages in various areas of application OR Students - explain the concepts underlying functional programming languages - learn and apply programming techniques in functional languages - formally define the semantics of functional programming languages - implement functional languages - design type checking procedures for functional languages - use functional languages in a targeted manner in various areas of application\n\n\n\n60-120 min written exam or 30 minute oral examination.\nLecture: Declarative Programming\nSWS: 2 ECTS: 2\nExercise: Declarative Modelling Exercise\nSWS: 2 ECTS: 4\n\n\n\n\n\n\nID\nDescription\nDisciplines\nPrerequisites\nEvidence\nAuthor\nSource\n\n\n\n\ndeclarative_mod_1\ndefine and interpret the special features, limitations, terminology and doctrines in the field of declarative modelling\nComputer Science\n\ndevelop declarative models for new problems\nUniversity of Potsdam\nLink\n\n\n\n\n\n\n\n\n\nNone\n\n\n\n\n\nDeklarative Modellierung\nDeklarative Problemlösung und Optimierung\nLogische Programmierung\nFoundations of Functional Programming\nFoundations of Logic Programming\n\n\n\n\n\nNone\n\n\n\n\n\nUP Computational Science Master\nJMUW Informatik Master\nRWTH Informatik Master"
  },
  {
    "objectID": "generation/generated/cs_declarativeprogramming.html#declarative-programming",
    "href": "generation/generated/cs_declarativeprogramming.html#declarative-programming",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "",
    "text": "This module deals with delarative modelling, problem-solving and programming. It can focus on the functional or logial programming paradigm.\n\n\n\n\nLogical-relational programming paradigm, top-down evaluation with SLD(NF) resolution. Introduction to the logical programming language Prolog: recursion, predicate-oriented programming, backtracking and cut, side effects, aggregations. Connection to (deductive) databases. Comparison with Datalog and brief introduction to advanced concepts such as constraint logic programming.\nPredicate logic fundamentals: Unification, Resolution, Horn clauses and SLD resolution\nLogic programmes: Operational and denotational semantics, Evaluation strategies\nThe Prolog programming language: Negation as failure, Non-logical components of Prolog, Programming techniques\nApplications and extensions of logic programming OR\nIntroduction to the Haskell programming language: Syntax of the various language constructs, Higher-order functions, Programming with lazy evaluation\nDenotational semantics of functional programmes: Complete orders and fixed points, Denotational semantics of Haskell\nLambda calculus: Syntax and operational semantics of lambda calculus, Reduction of Haskell to lambda calculus\nType checking and type inference\n\n\n\n\nStudents - have a broad, detailed and critical understanding of the latest knowledge in selected specialist areas in the field of declarative modelling - can implement compact and declarative programmes in Prolog and distinguish this approach from classical imperative programming - formally define the semantics of logical programming languages - targeted use of logical programming languages in various areas of application OR Students - explain the concepts underlying functional programming languages - learn and apply programming techniques in functional languages - formally define the semantics of functional programming languages - implement functional languages - design type checking procedures for functional languages - use functional languages in a targeted manner in various areas of application\n\n\n\n60-120 min written exam or 30 minute oral examination.\nLecture: Declarative Programming\nSWS: 2 ECTS: 2\nExercise: Declarative Modelling Exercise\nSWS: 2 ECTS: 4\n\n\n\n\n\n\nID\nDescription\nDisciplines\nPrerequisites\nEvidence\nAuthor\nSource\n\n\n\n\ndeclarative_mod_1\ndefine and interpret the special features, limitations, terminology and doctrines in the field of declarative modelling\nComputer Science\n\ndevelop declarative models for new problems\nUniversity of Potsdam\nLink\n\n\n\n\n\n\n\n\n\nNone\n\n\n\n\n\nDeklarative Modellierung\nDeklarative Problemlösung und Optimierung\nLogische Programmierung\nFoundations of Functional Programming\nFoundations of Logic Programming\n\n\n\n\n\nNone\n\n\n\n\n\nUP Computational Science Master\nJMUW Informatik Master\nRWTH Informatik Master"
  },
  {
    "objectID": "generation/generated/cs_computervision.html",
    "href": "generation/generated/cs_computervision.html",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "",
    "text": "The course imparts knowledge about current methods and algorithms in the field of computer vision. Important fundamentals and the latest approaches to image representation, image processing and image analysis are taught. Current models and methods of machine learning and their technical background are presented, and their respective applications in image processing are demonstrated.\n\n\n\n\nfundamental methods and techniques that enable a machine to analyse images and videos and understand their content\nfundamentals of image generation, linear filters, image segmentation, object recognition, object categorisation, 3D reconstructio\napplication of current methods of machine learning for the topics described above\n\n\n\n\n\nStudents describe current research trends and developments in the field of computer vision\nStudents name relevant techniques necessary for image and video analysis tasks\nStudents will be able to derive and explain methods and techniques that enable a machine to analyse images and videos and understand their content\nStudents select basic computer vision techniques that are necessary for these analysis tasks\nStudents independently apply the methods covered to real-world problems\nStudents implement the algorithms presented themselves and translate them into a programming language of their choice\n\n\n\n\n\neither a written exam (90-100 minutes)\nor an oral examination (20-30 minutes)\nor a project report (20-30 pages)\n\nLecture: Computer Vision\nSWS: 2 ECTS: 2\nExercise: Computer Vision Exercise\nSWS: 2 ECTS: 4\n\n\n\n\n\n\nID\nDescription\nDisciplines\nPrerequisites\nEvidence\nAuthor\nSource\n\n\n\n\ncompiler_tech_1\napply modelling techniques\nComputer Science\n\ndevelop solutions through technical methods\nUniversity of Potsdam\nLink\n\n\ncompiler_tech_2\nanalyse problems in given software systems\nComputer Science\n\ndiscuss problems in a team\nUniversity of Potsdam\nLink\n\n\n\n\n\n\n\n\n\nNone\n\n\n\n\n\nImage Processing and Phenotyping in Bioinformatics\nComputer Vision\nComputer Vision\nComputer Vision 2\n\n\n\n\n\nNone\n\n\n\n\n\nUP Computational Science Master\nRWTH Informatik Master\nJMUW Informatik Master"
  },
  {
    "objectID": "generation/generated/cs_computervision.html#computer-vision-and-image-processing",
    "href": "generation/generated/cs_computervision.html#computer-vision-and-image-processing",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "",
    "text": "The course imparts knowledge about current methods and algorithms in the field of computer vision. Important fundamentals and the latest approaches to image representation, image processing and image analysis are taught. Current models and methods of machine learning and their technical background are presented, and their respective applications in image processing are demonstrated.\n\n\n\n\nfundamental methods and techniques that enable a machine to analyse images and videos and understand their content\nfundamentals of image generation, linear filters, image segmentation, object recognition, object categorisation, 3D reconstructio\napplication of current methods of machine learning for the topics described above\n\n\n\n\n\nStudents describe current research trends and developments in the field of computer vision\nStudents name relevant techniques necessary for image and video analysis tasks\nStudents will be able to derive and explain methods and techniques that enable a machine to analyse images and videos and understand their content\nStudents select basic computer vision techniques that are necessary for these analysis tasks\nStudents independently apply the methods covered to real-world problems\nStudents implement the algorithms presented themselves and translate them into a programming language of their choice\n\n\n\n\n\neither a written exam (90-100 minutes)\nor an oral examination (20-30 minutes)\nor a project report (20-30 pages)\n\nLecture: Computer Vision\nSWS: 2 ECTS: 2\nExercise: Computer Vision Exercise\nSWS: 2 ECTS: 4\n\n\n\n\n\n\nID\nDescription\nDisciplines\nPrerequisites\nEvidence\nAuthor\nSource\n\n\n\n\ncompiler_tech_1\napply modelling techniques\nComputer Science\n\ndevelop solutions through technical methods\nUniversity of Potsdam\nLink\n\n\ncompiler_tech_2\nanalyse problems in given software systems\nComputer Science\n\ndiscuss problems in a team\nUniversity of Potsdam\nLink\n\n\n\n\n\n\n\n\n\nNone\n\n\n\n\n\nImage Processing and Phenotyping in Bioinformatics\nComputer Vision\nComputer Vision\nComputer Vision 2\n\n\n\n\n\nNone\n\n\n\n\n\nUP Computational Science Master\nRWTH Informatik Master\nJMUW Informatik Master"
  },
  {
    "objectID": "generation/generated/cs_ai.html",
    "href": "generation/generated/cs_ai.html",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "",
    "text": "This module deals with recent research in artificial intelligence.\n\n\n\nThe seminar addresses current research questions in the field of artificial intelligence.\n\n\n\nStudents - are able to define and interpret the special features, limitations, terminology and doctrines in the field of artificial intelligence. The knowledge and understanding gained by students forms the basis for the development and/or application of independent ideas in the field of artificial intelligence in a research-oriented context - have a broad, detailed and critical understanding of the latest state of knowledge in selected specialist areas in the field of artificial intelligence - are able to apply their knowledge, understanding and problem-solving skills in new and unfamiliar situations that are related to the field of artificial intelligence in a broader or multidisciplinary context.\n\n\n\n\n30 minute presentation with discussion\n\nLecture and Exercise: Current topics in Artificial Intelligence\nSWS: 4 ECTS: 6\n\n\n\n\n\n\nID\nDescription\nDisciplines\nPrerequisites\nEvidence\nAuthor\nSource\n\n\n\n\nai_1\ndescribe and differentiate current research topics in AI\nComputer Science\n\nanswer questions about those research topics\nUniversity of Potsdam\nLink\n\n\n\n\n\n\n\n\n\nNone\n\n\n\n\n\nAktuelle Themen der Künstlichen Intelligenz\nAktuelle Themen der Informatik\n\n\n\n\n\nNone\n\n\n\n\n\nUP Computational Science Master\nJMUW Informatik Master"
  },
  {
    "objectID": "generation/generated/cs_ai.html#current-topics-in-artificial-intelligence",
    "href": "generation/generated/cs_ai.html#current-topics-in-artificial-intelligence",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "",
    "text": "This module deals with recent research in artificial intelligence.\n\n\n\nThe seminar addresses current research questions in the field of artificial intelligence.\n\n\n\nStudents - are able to define and interpret the special features, limitations, terminology and doctrines in the field of artificial intelligence. The knowledge and understanding gained by students forms the basis for the development and/or application of independent ideas in the field of artificial intelligence in a research-oriented context - have a broad, detailed and critical understanding of the latest state of knowledge in selected specialist areas in the field of artificial intelligence - are able to apply their knowledge, understanding and problem-solving skills in new and unfamiliar situations that are related to the field of artificial intelligence in a broader or multidisciplinary context.\n\n\n\n\n30 minute presentation with discussion\n\nLecture and Exercise: Current topics in Artificial Intelligence\nSWS: 4 ECTS: 6\n\n\n\n\n\n\nID\nDescription\nDisciplines\nPrerequisites\nEvidence\nAuthor\nSource\n\n\n\n\nai_1\ndescribe and differentiate current research topics in AI\nComputer Science\n\nanswer questions about those research topics\nUniversity of Potsdam\nLink\n\n\n\n\n\n\n\n\n\nNone\n\n\n\n\n\nAktuelle Themen der Künstlichen Intelligenz\nAktuelle Themen der Informatik\n\n\n\n\n\nNone\n\n\n\n\n\nUP Computational Science Master\nJMUW Informatik Master"
  },
  {
    "objectID": "general/job_roles.html",
    "href": "general/job_roles.html",
    "title": "Possible Job Roles for an RSE",
    "section": "",
    "text": "Open science and FAIRness of data and software are increasingly important topics in research, as exemplified by the demand of an increasing amount of research funding agencies requiring openness. Hence, an Open Science RSE is required to have a deeper knowledge in Research Culture (RC) and how to distribute software publicly (Software Reusability (SRU), Software Publication (SP)). Open Science RSEs can help researchers navigate the technical questions that come up when practising Open Science, such as:\n\n“How do I make my code presentable?”\n“How do I make my code citable?”\n“What do I need to do to make my software FAIR?”\n“How do I sustainably work with an (international) team on a large code base?”\n\nLike the Data-focused RSE, they have a deep understanding of Research Data Management (RDM) topics.\n\n\n\nWhen research software projects become larger, they need someone who manages processes and people. In practice, this concerns change management for code and documentation, and community work to safeguard usability and adaptability, but also handling project governance and scalable decision-making processes. This gap can be filled by people who invest in the Project Management (PM), User Support (USERS), and Team Management (TEAM) skills.\nBuilding a community around a research project is an important building block in building sustainable software (Segal 2009), so these RSEs play an important role, even if they do not necessarily touch much of the code themselves.\n\n\n\nRSEs interested in developing their Teaching (TEACH) skill can focus on teaching the next generation of researchers and/or RSEs and will play a vital role in improving the quality of research software. They need to have a good understanding of all RSE competencies relevant to their domain and additionally should have experience or training in the educational field.\n\n\n\nScientific software is a complex product that often needs to be refined in order to be usable even by other scientists. To facilitate this, there are people required that specialise in the Documentation & Best Practices (DOCBB) and probably the Distribution (DIST) competency with a focus on making end-user-facing software really reusable and hence FAIR. This task is supported by strong Modelling (MOD) skills to reason about the behaviour of potential users of the software."
  },
  {
    "objectID": "general/job_roles.html#open-science-rse",
    "href": "general/job_roles.html#open-science-rse",
    "title": "Possible Job Roles for an RSE",
    "section": "",
    "text": "Open science and FAIRness of data and software are increasingly important topics in research, as exemplified by the demand of an increasing amount of research funding agencies requiring openness. Hence, an Open Science RSE is required to have a deeper knowledge in Research Culture (RC) and how to distribute software publicly (Software Reusability (SRU), Software Publication (SP)). Open Science RSEs can help researchers navigate the technical questions that come up when practising Open Science, such as:\n\n“How do I make my code presentable?”\n“How do I make my code citable?”\n“What do I need to do to make my software FAIR?”\n“How do I sustainably work with an (international) team on a large code base?”\n\nLike the Data-focused RSE, they have a deep understanding of Research Data Management (RDM) topics."
  },
  {
    "objectID": "general/job_roles.html#projectcommunity-manager-rses",
    "href": "general/job_roles.html#projectcommunity-manager-rses",
    "title": "Possible Job Roles for an RSE",
    "section": "",
    "text": "When research software projects become larger, they need someone who manages processes and people. In practice, this concerns change management for code and documentation, and community work to safeguard usability and adaptability, but also handling project governance and scalable decision-making processes. This gap can be filled by people who invest in the Project Management (PM), User Support (USERS), and Team Management (TEAM) skills.\nBuilding a community around a research project is an important building block in building sustainable software (Segal 2009), so these RSEs play an important role, even if they do not necessarily touch much of the code themselves."
  },
  {
    "objectID": "general/job_roles.html#teaching-rses",
    "href": "general/job_roles.html#teaching-rses",
    "title": "Possible Job Roles for an RSE",
    "section": "",
    "text": "RSEs interested in developing their Teaching (TEACH) skill can focus on teaching the next generation of researchers and/or RSEs and will play a vital role in improving the quality of research software. They need to have a good understanding of all RSE competencies relevant to their domain and additionally should have experience or training in the educational field."
  },
  {
    "objectID": "general/job_roles.html#user-interfaceuser-experience-designers-for-research-software",
    "href": "general/job_roles.html#user-interfaceuser-experience-designers-for-research-software",
    "title": "Possible Job Roles for an RSE",
    "section": "",
    "text": "Scientific software is a complex product that often needs to be refined in order to be usable even by other scientists. To facilitate this, there are people required that specialise in the Documentation & Best Practices (DOCBB) and probably the Distribution (DIST) competency with a focus on making end-user-facing software really reusable and hence FAIR. This task is supported by strong Modelling (MOD) skills to reason about the behaviour of potential users of the software."
  },
  {
    "objectID": "general/glossary.html",
    "href": "general/glossary.html",
    "title": "Glossary",
    "section": "",
    "text": "Glossary\nC A general-purpose programming language often used for system-level development.\nCpp C++ — an extension of C that supports object-oriented programming.\nDIST Software distribution — the practice of packaging and delivering software and its dependencies.\nDOCBB Documentation and best practices — ensuring code is understandable and maintainable.\nDOMREP Domain repositories — platforms that store and share domain-specific research data.\nHPC High-Performance Computing — using supercomputers and parallel processing for complex tasks.\nMOD Modularity — the design principle of separating software into interchangeable, functional components.\nNEW Novel research — work that contributes original insights to a scientific domain.\nPM Project Management — planning, executing, and overseeing projects effectively.\nPython A high-level programming language widely used in data science and scripting.\nR A programming language and environment for statistical computing and graphics.\nRSE Research Software Engineer — someone who applies software engineering skills to scientific research.\nSP Software publication — the process of preparing and disseminating software artifacts.\nSRU Software reuse — the practice of using existing software components in new projects.\nSTEM Science, Technology, Engineering, and Mathematics.\nSWREPOS Software repositories — systems for storing and managing software code and versions.\nTEAM Teamwork — the ability to collaborate effectively in a group setting.\nTEACH Teaching — the skill of communicating knowledge and helping others learn.\nUSERS End users — the scientists or researchers who rely on software tools."
  },
  {
    "objectID": "event/kickoff-workshops/schedule.html",
    "href": "event/kickoff-workshops/schedule.html",
    "title": "Preliminary Schedule for RSE Community Workshops",
    "section": "",
    "text": "Preliminary Schedule for RSE Community Workshops\nAll times are in Berlin time (CEST).\nSign in here for the workshops.\nAll the workshops will take place in the regular deRSE zoom. Contact julian.dehne@gi.de for the access details."
  },
  {
    "objectID": "components/rse_thesis/description.html",
    "href": "components/rse_thesis/description.html",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "",
    "text": "The master’s thesis is the culminating component of the RSE programme. In this module, students apply the full spectrum of Research Software Engineering skills in a real-world research setting, demonstrating their ability to independently design, implement, and document a computational research contribution.\nThe thesis must address a research question in collaboration with a scientific or applied domain, but its core should include a substantial computational component. This may involve software development, data-intensive research, reproducibility infrastructure, or performance engineering — depending on the chosen topic and specialization.\nEach thesis must be supervised jointly by:\n\nA domain expert (e.g., in physics, life sciences, or humanities)\nAn RSE mentor (who ensures the quality and relevance of the computational contribution)\n\nStudents are expected to follow best practices in software engineering, version control, testing, and documentation. The final submission must include:\n\nA written thesis describing both the scientific and software contributions\nA structured, reproducible code repository\nA presentation and defense in a thesis colloquium\n\nThe colloquium serves as both a public communication exercise and a final evaluation, where students present their project and reflect on challenges and insights gained during the thesis."
  },
  {
    "objectID": "components/rse_thesis/description.html#masters-thesis-module-research-software-engineering-thesis",
    "href": "components/rse_thesis/description.html#masters-thesis-module-research-software-engineering-thesis",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "",
    "text": "The master’s thesis is the culminating component of the RSE programme. In this module, students apply the full spectrum of Research Software Engineering skills in a real-world research setting, demonstrating their ability to independently design, implement, and document a computational research contribution.\nThe thesis must address a research question in collaboration with a scientific or applied domain, but its core should include a substantial computational component. This may involve software development, data-intensive research, reproducibility infrastructure, or performance engineering — depending on the chosen topic and specialization.\nEach thesis must be supervised jointly by:\n\nA domain expert (e.g., in physics, life sciences, or humanities)\nAn RSE mentor (who ensures the quality and relevance of the computational contribution)\n\nStudents are expected to follow best practices in software engineering, version control, testing, and documentation. The final submission must include:\n\nA written thesis describing both the scientific and software contributions\nA structured, reproducible code repository\nA presentation and defense in a thesis colloquium\n\nThe colloquium serves as both a public communication exercise and a final evaluation, where students present their project and reflect on challenges and insights gained during the thesis."
  },
  {
    "objectID": "components/rse_softwareengineering/description.html",
    "href": "components/rse_softwareengineering/description.html",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "",
    "text": "This module extends the Classical Software Engineering Module with research specific learnings. This includes but is not limited to\n\nsoftware re-use (see SRU in (Goth et al. 2024))\ncreating documented code building blocks (see DOCBB in (Goth et al. 2024))\nbuilding distributable software (see DIST in (Goth et al. 2024))\nresearch specific programming languages\nresearch specific code requirements (scalability, functional programming, …)\nAdapting the software life cycle to research (see SWLC in (Goth et al. 2024))\nSoftware behaviour awareness and analysis (see MOD in (Goth et al. 2024))\nResearch specific Engineering Patterns\n\nAlso, the seminar provides room for reflection and discussions of SE lab experiences."
  },
  {
    "objectID": "components/rse_softwareengineering/description.html#software-engineering-for-rses",
    "href": "components/rse_softwareengineering/description.html#software-engineering-for-rses",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "",
    "text": "This module extends the Classical Software Engineering Module with research specific learnings. This includes but is not limited to\n\nsoftware re-use (see SRU in (Goth et al. 2024))\ncreating documented code building blocks (see DOCBB in (Goth et al. 2024))\nbuilding distributable software (see DIST in (Goth et al. 2024))\nresearch specific programming languages\nresearch specific code requirements (scalability, functional programming, …)\nAdapting the software life cycle to research (see SWLC in (Goth et al. 2024))\nSoftware behaviour awareness and analysis (see MOD in (Goth et al. 2024))\nResearch specific Engineering Patterns\n\nAlso, the seminar provides room for reflection and discussions of SE lab experiences."
  },
  {
    "objectID": "components/rse_scientificcomputing/description.html",
    "href": "components/rse_scientificcomputing/description.html",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "",
    "text": "RSEs with expertise in HPC and other performance-critical computing domains specialize in optimizing code for efficient execution across various platforms, including clusters, cloud, edge, and embedded systems. They understand parallel programming models, hardware-specific optimizations, profiling tools, and platform constraints such as memory, energy, and latency. Their skills enable them to adapt software to diverse infrastructures, manage complex dependencies, and support researchers in accessing and using advanced computing resources effectively and sustainably.\n\n\nThis module provides an entry‑level yet rigorous foundation in scientific computing for graduate students and researchers who need to design, implement, and evaluate computational experiments. Learners gain an awareness of the numerical underpinnings of modern simulation and data‑driven research, with an emphasis on writing reproducible, efficient, and trustworthy code.\n\n\n\nBy the end of the module participants will be able to\n\nBenchmark small programs and interpret performance metrics in a research context.\nExplain how approximation theory and floating‑point arithmetic affect numerical accuracy and stability.\nIdentify when to use established simulation libraries (e.g. BLAS/LAPACK, PETSc, Trilinos) instead of custom code.\nWrite simple GPU kernels and describe the core principles of accelerator programming.\nSubmit and monitor batch & array jobs on a mid‑size compute cluster.\nDescribe common HPC challenges—such as I/O bottlenecks, threading, and NUMA—and propose mitigation strategies.\nMaintain research software through continuous benchmarking.\n\nThe module qualifies for the more advanced module Scientific (High-Performance) Computing.\n\n\n\n\n\n\n\n\n\n\n\nWeek\nTheme\nTopics\n\n\n\n\n1\nBenchmarking & Profiling\nTiming strategies · micro vs. macro benchmarks · tooling overview\n\n\n2\nPrecision & Approximation\nIEEE‑754 recap · conditioning & stability · error propagation\n\n\n3\nScientific Libraries\nBLAS/LAPACK anatomy · hierarchical I/O libraries · overview of PETSc/Trilinos/Hypre\n\n\n4\nGPU Primer\nKernel model · memory hierarchy · CUDA/OpenCL/PyTorch lightning intro\n\n\n5\nWorking on a Cluster\nSlurm basics · job arrays · job dependencies · simple Bash launchers\n\n\n6\nHPC Pitfalls\nI/O throughput · thread oversubscription · NUMA awareness\n\n\n7\nSoftware Maintenance\nRegression + performance tests · continuous benchmarking pipelines\n\n\n\n\n\n\nShort lectures (30%) are coupled with hands‑on labs (70%). Students complete weekly notebooks and a mini‑project that reproduces and optimises a published computational result.\n\n\n\n\n\n\nComponent\nWeight\nDetails\n\n\n\n\nContinuous labs\n40%\nWeekly graded notebooks\n\n\nFinal mini‑project\n60%\nReport, code, and benchmark suite\n\n\n\n\n\n\n\nBasic programming in Python, C/C++, or Julia\nUndergraduate calculus & linear algebra\n\n\n\n\nChatGPT fantasy"
  },
  {
    "objectID": "components/rse_scientificcomputing/description.html#scientific-computing-for-rse",
    "href": "components/rse_scientificcomputing/description.html#scientific-computing-for-rse",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "",
    "text": "RSEs with expertise in HPC and other performance-critical computing domains specialize in optimizing code for efficient execution across various platforms, including clusters, cloud, edge, and embedded systems. They understand parallel programming models, hardware-specific optimizations, profiling tools, and platform constraints such as memory, energy, and latency. Their skills enable them to adapt software to diverse infrastructures, manage complex dependencies, and support researchers in accessing and using advanced computing resources effectively and sustainably.\n\n\nThis module provides an entry‑level yet rigorous foundation in scientific computing for graduate students and researchers who need to design, implement, and evaluate computational experiments. Learners gain an awareness of the numerical underpinnings of modern simulation and data‑driven research, with an emphasis on writing reproducible, efficient, and trustworthy code.\n\n\n\nBy the end of the module participants will be able to\n\nBenchmark small programs and interpret performance metrics in a research context.\nExplain how approximation theory and floating‑point arithmetic affect numerical accuracy and stability.\nIdentify when to use established simulation libraries (e.g. BLAS/LAPACK, PETSc, Trilinos) instead of custom code.\nWrite simple GPU kernels and describe the core principles of accelerator programming.\nSubmit and monitor batch & array jobs on a mid‑size compute cluster.\nDescribe common HPC challenges—such as I/O bottlenecks, threading, and NUMA—and propose mitigation strategies.\nMaintain research software through continuous benchmarking.\n\nThe module qualifies for the more advanced module Scientific (High-Performance) Computing.\n\n\n\n\n\n\n\n\n\n\n\nWeek\nTheme\nTopics\n\n\n\n\n1\nBenchmarking & Profiling\nTiming strategies · micro vs. macro benchmarks · tooling overview\n\n\n2\nPrecision & Approximation\nIEEE‑754 recap · conditioning & stability · error propagation\n\n\n3\nScientific Libraries\nBLAS/LAPACK anatomy · hierarchical I/O libraries · overview of PETSc/Trilinos/Hypre\n\n\n4\nGPU Primer\nKernel model · memory hierarchy · CUDA/OpenCL/PyTorch lightning intro\n\n\n5\nWorking on a Cluster\nSlurm basics · job arrays · job dependencies · simple Bash launchers\n\n\n6\nHPC Pitfalls\nI/O throughput · thread oversubscription · NUMA awareness\n\n\n7\nSoftware Maintenance\nRegression + performance tests · continuous benchmarking pipelines\n\n\n\n\n\n\nShort lectures (30%) are coupled with hands‑on labs (70%). Students complete weekly notebooks and a mini‑project that reproduces and optimises a published computational result.\n\n\n\n\n\n\nComponent\nWeight\nDetails\n\n\n\n\nContinuous labs\n40%\nWeekly graded notebooks\n\n\nFinal mini‑project\n60%\nReport, code, and benchmark suite\n\n\n\n\n\n\n\nBasic programming in Python, C/C++, or Julia\nUndergraduate calculus & linear algebra\n\n\n\n\nChatGPT fantasy"
  },
  {
    "objectID": "components/rse_nuts_bolts/description.html",
    "href": "components/rse_nuts_bolts/description.html",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "",
    "text": "This module, inspired by the MIT Missing Semester, addresses the “nuts and bolts” often missing from traditional academic training in computing. It aims to provide students with practical skills and conceptual understanding for building robust, maintainable, and reproducible research software—key competencies in Research Software Engineering (RSEng).\n\n\n\nThe module begins with general-purpose computing tools and techniques that are foundational for any research software engineer:\n\nShell tools and scripting\nCommand-line environments\nEditors and IDEs (e.g., Vim)\nVersion control (Git)\nData wrangling\nDebugging and profiling\nMetaprogramming\nSecurity and cryptography\n\n\n\n\nBuilding on these foundations, the module introduces RSE-specific concepts and good practices:\n\nVersion control and collaboration\n\nGit for code history, collaboration, and issue tracking\n\nVirtualization concepts\n\nContainerization and environment management\n\nThe Data Life Cycle\n\nManaging research data and understanding data provenance\n\nGood coding practices\n\nReproducible and testable code\nMeaningful documentation and error messages\nModular software design\nPerformance-conscious coding\nEasily installable and distributable software\nCoding standards, formatting, and linting\n\nSoftware management planning\n\nWriting Data and Software Management Plans\nSustainable development and community involvement\n\nLow-level programming\n\nIntroduction to a compiled language (e.g., C) to expose hardware-level concerns and efficient memory management\n\nLong-term software maintenance\n\nVersion tracking, bug management, and sustainability strategies\nBuilding and maintaining research software communities\n\n\n\n\n\nFinally, the module touches on practices that support the scholarly nature of research software:\n\nSoftware publication and citation (see SP in (Goth et al. 2024))\nUse of domain-specific repositories and registries (see DOMREP in (Goth et al. 2024))\n\nBy the end of this module, students will be well-equipped to design, develop, document, and maintain research software that meets high standards of quality, sustainability, and reproducibility."
  },
  {
    "objectID": "components/rse_nuts_bolts/description.html#rseng-nuts-and-bolts",
    "href": "components/rse_nuts_bolts/description.html#rseng-nuts-and-bolts",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "",
    "text": "This module, inspired by the MIT Missing Semester, addresses the “nuts and bolts” often missing from traditional academic training in computing. It aims to provide students with practical skills and conceptual understanding for building robust, maintainable, and reproducible research software—key competencies in Research Software Engineering (RSEng).\n\n\n\nThe module begins with general-purpose computing tools and techniques that are foundational for any research software engineer:\n\nShell tools and scripting\nCommand-line environments\nEditors and IDEs (e.g., Vim)\nVersion control (Git)\nData wrangling\nDebugging and profiling\nMetaprogramming\nSecurity and cryptography\n\n\n\n\nBuilding on these foundations, the module introduces RSE-specific concepts and good practices:\n\nVersion control and collaboration\n\nGit for code history, collaboration, and issue tracking\n\nVirtualization concepts\n\nContainerization and environment management\n\nThe Data Life Cycle\n\nManaging research data and understanding data provenance\n\nGood coding practices\n\nReproducible and testable code\nMeaningful documentation and error messages\nModular software design\nPerformance-conscious coding\nEasily installable and distributable software\nCoding standards, formatting, and linting\n\nSoftware management planning\n\nWriting Data and Software Management Plans\nSustainable development and community involvement\n\nLow-level programming\n\nIntroduction to a compiled language (e.g., C) to expose hardware-level concerns and efficient memory management\n\nLong-term software maintenance\n\nVersion tracking, bug management, and sustainability strategies\nBuilding and maintaining research software communities\n\n\n\n\n\nFinally, the module touches on practices that support the scholarly nature of research software:\n\nSoftware publication and citation (see SP in (Goth et al. 2024))\nUse of domain-specific repositories and registries (see DOMREP in (Goth et al. 2024))\n\nBy the end of this module, students will be well-equipped to design, develop, document, and maintain research software that meets high standards of quality, sustainability, and reproducibility."
  },
  {
    "objectID": "components/rse_lectureseries/description.html",
    "href": "components/rse_lectureseries/description.html",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "",
    "text": "This lecture series covers current RSEng research and provides room for guest lectures and varying focus topics.\n\n\n\nvary between semesters and weeks, but are all related to RSEng\n\n\n\n\nstudents get a broad image of RSEng in the wild\n\n\n\n\nnone?"
  },
  {
    "objectID": "components/rse_lectureseries/description.html#rseng-lecture-series",
    "href": "components/rse_lectureseries/description.html#rseng-lecture-series",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "",
    "text": "This lecture series covers current RSEng research and provides room for guest lectures and varying focus topics.\n\n\n\nvary between semesters and weeks, but are all related to RSEng\n\n\n\n\nstudents get a broad image of RSEng in the wild\n\n\n\n\nnone?"
  },
  {
    "objectID": "components/mnt_wildcard/description.html",
    "href": "components/mnt_wildcard/description.html",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "",
    "text": "This module offers RSE students the opportunity to deepen their understanding of a scientific discipline outside of their home domain. Students choose a science module — such as physics, chemistry, biology, or earth sciences — and engage with its research practices, core questions, and data/software challenges.\nThe goal is to help students become better collaborators by gaining first-hand exposure to the terminology, logic, and needs of another scientific domain. This broadens the student’s ability to apply RSE skills in interdisciplinary teams and unfamiliar environments.\nThe module may consist of lectures, lab sessions, and domain-specific mini-projects. RSEs are encouraged to reflect on how software engineering, data handling, reproducibility, and tooling intersect with the chosen discipline.\nThis module is deliberately flexible to accommodate institutional offerings and student interests as well as providing the option to stay attached to the identity of the chosen discipline."
  },
  {
    "objectID": "components/mnt_wildcard/description.html#wildcard-science-module",
    "href": "components/mnt_wildcard/description.html#wildcard-science-module",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "",
    "text": "This module offers RSE students the opportunity to deepen their understanding of a scientific discipline outside of their home domain. Students choose a science module — such as physics, chemistry, biology, or earth sciences — and engage with its research practices, core questions, and data/software challenges.\nThe goal is to help students become better collaborators by gaining first-hand exposure to the terminology, logic, and needs of another scientific domain. This broadens the student’s ability to apply RSE skills in interdisciplinary teams and unfamiliar environments.\nThe module may consist of lectures, lab sessions, and domain-specific mini-projects. RSEs are encouraged to reflect on how software engineering, data handling, reproducibility, and tooling intersect with the chosen discipline.\nThis module is deliberately flexible to accommodate institutional offerings and student interests as well as providing the option to stay attached to the identity of the chosen discipline."
  },
  {
    "objectID": "components/mnt_compwildcard/description.html",
    "href": "components/mnt_compwildcard/description.html",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "",
    "text": "This module offers RSE students the opportunity to deepen their understanding of computational methods specific to a science discipline. Students choose a science module — such as physics, chemistry, biology, or earth sciences — and engage with its computational practices, core questions, and data/software challenges.\nThe goal is to apply the general competences acquired in the general programming and software engineering courses to the practices and special needs of the chosen discipline. Computational Physics might face different algorithmic or conceptual challenges than computational chemistry. This module is intended for the case that the institution offers such a specialized computational course."
  },
  {
    "objectID": "components/mnt_compwildcard/description.html#wildcard-computational-science",
    "href": "components/mnt_compwildcard/description.html#wildcard-computational-science",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "",
    "text": "This module offers RSE students the opportunity to deepen their understanding of computational methods specific to a science discipline. Students choose a science module — such as physics, chemistry, biology, or earth sciences — and engage with its computational practices, core questions, and data/software challenges.\nThe goal is to apply the general competences acquired in the general programming and software engineering courses to the practices and special needs of the chosen discipline. Computational Physics might face different algorithmic or conceptual challenges than computational chemistry. This module is intended for the case that the institution offers such a specialized computational course."
  },
  {
    "objectID": "components/gen_softwareeng1/description.html",
    "href": "components/gen_softwareeng1/description.html",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "",
    "text": "To summarise the vast range of the skills a software engineer is typically equipped with, we refer to the Guide to the Software Engineering Body of Knowledge (Bourque, Fairley, and IEEE Computer Society 2014). Because research software engineering is an interface discipline, RSEs are often stronger in topics more commonly encountered in research software contexts (e.g., mathematical and engineering foundations) than in other areas (e.g., software engineering economics). However, they bring a solid level of competence in all software engineering topics. Therefore, RSEs can set and analyse software requirements in the context of open-ended, question-driven research. They can design software so that it can sustainably grow, often in an environment of rapid turnover of contributors. They are competent in implementing solutions themselves in a wide range of technologies fit for different scientific applications. They can formulate and implement various types of tests, they can independently maintain software and automate operations of the integration and release process. They can provide working, scalable, and future-proof solutions in a professional context and with common project and software management techniques, adapted to the needs of the research environment. Finally, as people who have often gained significant research experience in a particular discipline, they combine the necessary foundations from their domain with software engineering skills to develop complex software.(Goth et al. 2024)\nThis module tries to lay the foundations for the advanced RSE software engineering training.\n\n\nBourque, Pierre, Richard E. Fairley, and IEEE Computer Society. 2014. Guide to the Software Engineering Body of Knowledge (SWEBOK(R)): Version 3.0. 3rd ed. Washington, DC, USA: IEEE Computer Society Press.\n\n\nGoth, F, R Alves, M Braun, LJ Castro, G Chourdakis, S Christ, J Cohen, et al. 2024. “Foundational Competencies and Responsibilities of a Research Software Engineer [Version 1; Peer Review: Awaiting Peer Review].” F1000Research 13 (1429). https://doi.org/10.12688/f1000research.157778.1.\n\n\n\n\n\nBasic concepts of software engineering,\nsoftware and product life cycle,\nprocess models for the design of large software systems,\nsemantic aspects of domain description, hierarchy, parallelism, real-time and embedded systems as fundamental paradigms,\norganizational principles of complex software systems, design by contract,\npatterns in modeling and design methods of quality assurance, evolution and re-engineering,\nselected languages and tools for process- and object-oriented modeling,\nmethods and languages for object-oriented design, architectures and architectural patterns of software systems,\narchitecture of enterprise applications,\ndesign and implementation models in the object-oriented paradigm, e.g., Java 2 SE, design patterns, software testing methods\na selection of advanced topics such as software quality assurance, service engineering, virtualization, and formal methods in system design"
  },
  {
    "objectID": "components/gen_softwareeng1/description.html#classical-software-engineering-i",
    "href": "components/gen_softwareeng1/description.html#classical-software-engineering-i",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "",
    "text": "To summarise the vast range of the skills a software engineer is typically equipped with, we refer to the Guide to the Software Engineering Body of Knowledge (Bourque, Fairley, and IEEE Computer Society 2014). Because research software engineering is an interface discipline, RSEs are often stronger in topics more commonly encountered in research software contexts (e.g., mathematical and engineering foundations) than in other areas (e.g., software engineering economics). However, they bring a solid level of competence in all software engineering topics. Therefore, RSEs can set and analyse software requirements in the context of open-ended, question-driven research. They can design software so that it can sustainably grow, often in an environment of rapid turnover of contributors. They are competent in implementing solutions themselves in a wide range of technologies fit for different scientific applications. They can formulate and implement various types of tests, they can independently maintain software and automate operations of the integration and release process. They can provide working, scalable, and future-proof solutions in a professional context and with common project and software management techniques, adapted to the needs of the research environment. Finally, as people who have often gained significant research experience in a particular discipline, they combine the necessary foundations from their domain with software engineering skills to develop complex software.(Goth et al. 2024)\nThis module tries to lay the foundations for the advanced RSE software engineering training.\n\n\nBourque, Pierre, Richard E. Fairley, and IEEE Computer Society. 2014. Guide to the Software Engineering Body of Knowledge (SWEBOK(R)): Version 3.0. 3rd ed. Washington, DC, USA: IEEE Computer Society Press.\n\n\nGoth, F, R Alves, M Braun, LJ Castro, G Chourdakis, S Christ, J Cohen, et al. 2024. “Foundational Competencies and Responsibilities of a Research Software Engineer [Version 1; Peer Review: Awaiting Peer Review].” F1000Research 13 (1429). https://doi.org/10.12688/f1000research.157778.1.\n\n\n\n\n\nBasic concepts of software engineering,\nsoftware and product life cycle,\nprocess models for the design of large software systems,\nsemantic aspects of domain description, hierarchy, parallelism, real-time and embedded systems as fundamental paradigms,\norganizational principles of complex software systems, design by contract,\npatterns in modeling and design methods of quality assurance, evolution and re-engineering,\nselected languages and tools for process- and object-oriented modeling,\nmethods and languages for object-oriented design, architectures and architectural patterns of software systems,\narchitecture of enterprise applications,\ndesign and implementation models in the object-oriented paradigm, e.g., Java 2 SE, design patterns, software testing methods\na selection of advanced topics such as software quality assurance, service engineering, virtualization, and formal methods in system design"
  },
  {
    "objectID": "components/gen_datatext/description.html",
    "href": "components/gen_datatext/description.html",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "",
    "text": "This module introduces the students to text processing and information retrieval.\n\n\n\nIntroduction to textual data and Natural Language Processing (NLP): key concepts and use cases\nText acquisition and preprocessing: tokenisation, stemming/lemmatisation, stopwords, named entity recognition, text cleaning\nText representations: bag-of-words, TF-IDF, word embeddings (Word2Vec, GloVe), contextualised embeddings (BERT, RoBERTa, GPT variants)\nText mining and information extraction: key terms, topics, sentiment analysis, relation extraction\nInformation Retrieval and Web Search Engines\nData-to-insight pipelines: from raw text to structured data (CSV/SQL), feature engineering for text data\nModelling and evaluation: classification, regression, sequence models, transformers; evaluation metrics (accuracy, F1, MCC, AUC)\nPrototyping and reproducibility: experiment tracking, versioning, reproducible pipelines (Docker/Kubernetes, MLflow, DVC)\nRisk management and ethics: bias, fairness, data protection (GDPR), transparency, interpretability (LIME, SHAP)\nDeployment and practical applications: API-based models, batch vs real-time processing, monitoring\nProject work: from a research question to data collection, modelling, evaluation and documentation\n\n\n\n\n\nUnderstand how text data is collected, preprocessed, and transformed into usable formats\nBe able to select and justify different text representations\nApply NLP methods to extract relevant information from text\nDevelop, train and evaluate text-based models with attention to reproducibility and ethics\nAssess model limitations, interpretability, and risk of errors\nBuild a reproducible, scalable text-data pipeline\nCommunicate results clearly in reports, presentations, and prototype designs\n\n\n\n\nproject report (X pages) and presentation (15 minutes)"
  },
  {
    "objectID": "components/gen_datatext/description.html#text-to-data-natural-language-processing",
    "href": "components/gen_datatext/description.html#text-to-data-natural-language-processing",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "",
    "text": "This module introduces the students to text processing and information retrieval.\n\n\n\nIntroduction to textual data and Natural Language Processing (NLP): key concepts and use cases\nText acquisition and preprocessing: tokenisation, stemming/lemmatisation, stopwords, named entity recognition, text cleaning\nText representations: bag-of-words, TF-IDF, word embeddings (Word2Vec, GloVe), contextualised embeddings (BERT, RoBERTa, GPT variants)\nText mining and information extraction: key terms, topics, sentiment analysis, relation extraction\nInformation Retrieval and Web Search Engines\nData-to-insight pipelines: from raw text to structured data (CSV/SQL), feature engineering for text data\nModelling and evaluation: classification, regression, sequence models, transformers; evaluation metrics (accuracy, F1, MCC, AUC)\nPrototyping and reproducibility: experiment tracking, versioning, reproducible pipelines (Docker/Kubernetes, MLflow, DVC)\nRisk management and ethics: bias, fairness, data protection (GDPR), transparency, interpretability (LIME, SHAP)\nDeployment and practical applications: API-based models, batch vs real-time processing, monitoring\nProject work: from a research question to data collection, modelling, evaluation and documentation\n\n\n\n\n\nUnderstand how text data is collected, preprocessed, and transformed into usable formats\nBe able to select and justify different text representations\nApply NLP methods to extract relevant information from text\nDevelop, train and evaluate text-based models with attention to reproducibility and ethics\nAssess model limitations, interpretability, and risk of errors\nBuild a reproducible, scalable text-data pipeline\nCommunicate results clearly in reports, presentations, and prototype designs\n\n\n\n\nproject report (X pages) and presentation (15 minutes)"
  },
  {
    "objectID": "components/gen_datamaths/description.html",
    "href": "components/gen_datamaths/description.html",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "",
    "text": "This module covers the mathematical foundations of data science.\n\n\nThe module teaches the mathematical fundamentals of data science. Topics include a selection from the areas of graph analysis, stochastic models and signal analysis with wavelets.\n\n\n\nStudents will acquire comprehensive, detailed and specialised knowledge of the latest findings in selected fundamentals of data science. Students will have an in-depth understanding of selected data science methods. They will be able to analyse novel data assimilation and inference problems, develop and implement solutions, and determine the quality of the solutions. They will be able to develop new ideas and procedures, weigh up alternatives when information is incomplete, and evaluate them taking into account different assessment criteria.\n\n\n\nwritten exam (120 minutes) or oral exam (30 minutes)"
  },
  {
    "objectID": "components/gen_datamaths/description.html#mathematical-foundations-of-data-science",
    "href": "components/gen_datamaths/description.html#mathematical-foundations-of-data-science",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "",
    "text": "This module covers the mathematical foundations of data science.\n\n\nThe module teaches the mathematical fundamentals of data science. Topics include a selection from the areas of graph analysis, stochastic models and signal analysis with wavelets.\n\n\n\nStudents will acquire comprehensive, detailed and specialised knowledge of the latest findings in selected fundamentals of data science. Students will have an in-depth understanding of selected data science methods. They will be able to analyse novel data assimilation and inference problems, develop and implement solutions, and determine the quality of the solutions. They will be able to develop new ideas and procedures, weigh up alternatives when information is incomplete, and evaluate them taking into account different assessment criteria.\n\n\n\nwritten exam (120 minutes) or oral exam (30 minutes)"
  },
  {
    "objectID": "components/cs_securitycrypto/description.html",
    "href": "components/cs_securitycrypto/description.html",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "",
    "text": "This module deals with IT-security and cryptography.\n\n\n\nThe course offers a broad overview of concepts and technologies relevant to IT security: - Theoretical aspects: security in information theory and computability, introduction to cryptography (historical and modern ciphers, hash functions, pseudo-random number generators, message authentication codes, public-key cryptography) - Network security: security of protocols and TCP/IP, public key infrastructure, user authentication, Kerberos, IPsec, TLS protocol, SSH, DNS Security, Email Security, and Phishing Attacks. - Software security: security vulnerabilities, common programming errors and techniques for exploiting them, reverse engineering and obfuscation, malware and anti-malware - Platform security: access control models, security policies, operating system security, virtualisation, security mechanisms with hardware support - Methods for secure and reliable transmission and processing of information, error-correcting coding methods - Fundamentals of cryptographic systems, methods for information analysis, complexity aspects, applications - Necessary foundations of mathematics and complexity theory are introduced alongside the topics - Private key cryptosystems, Vernam one-time pad, AES, perfect security, public key cryptosystems, RSA, Diffie-Hellman, Elgamal, Goldwasser-Micali, digital signature, challenge-response procedure, secret sharing, millionaire problem, secure circuit evaluation, homomorphic encryption - Symmetric Encryption, Integrity protection, Asymmetric Encryption, Digital Signatures, Certificates and Public Key Infrastructures, and Authentication and Key Agreement\n\n\n\nStudents are able to - understand the mathematical foundations of secure and reliable information processing and their complexity-theoretical basis - are capable of analysing thesecurity of methods - model threats and evaluate the security of systems critically from the attacker’s perspective - understand the purpose and functioning of some security technologies and be aware of their limitations - select and apply appropriate cryptographic primitives in different application scenarios - select suitable security protocols for a given scenario and configure the relevant options for the cryptographic building blocks used within these protocols - identify security requirements and adequate security mechanisms in various application domains - identify potential weaknesses in security protocols not covered in detail during the course and propose appropriate fixes - assess the severity of novel attacks against security protocols and cryptographic primitives\n\n\n\n\nEither a written exam (90 minutes).\nOr an oral examination (30 minutes)."
  },
  {
    "objectID": "components/cs_securitycrypto/description.html#it-security-and-cryptography",
    "href": "components/cs_securitycrypto/description.html#it-security-and-cryptography",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "",
    "text": "This module deals with IT-security and cryptography.\n\n\n\nThe course offers a broad overview of concepts and technologies relevant to IT security: - Theoretical aspects: security in information theory and computability, introduction to cryptography (historical and modern ciphers, hash functions, pseudo-random number generators, message authentication codes, public-key cryptography) - Network security: security of protocols and TCP/IP, public key infrastructure, user authentication, Kerberos, IPsec, TLS protocol, SSH, DNS Security, Email Security, and Phishing Attacks. - Software security: security vulnerabilities, common programming errors and techniques for exploiting them, reverse engineering and obfuscation, malware and anti-malware - Platform security: access control models, security policies, operating system security, virtualisation, security mechanisms with hardware support - Methods for secure and reliable transmission and processing of information, error-correcting coding methods - Fundamentals of cryptographic systems, methods for information analysis, complexity aspects, applications - Necessary foundations of mathematics and complexity theory are introduced alongside the topics - Private key cryptosystems, Vernam one-time pad, AES, perfect security, public key cryptosystems, RSA, Diffie-Hellman, Elgamal, Goldwasser-Micali, digital signature, challenge-response procedure, secret sharing, millionaire problem, secure circuit evaluation, homomorphic encryption - Symmetric Encryption, Integrity protection, Asymmetric Encryption, Digital Signatures, Certificates and Public Key Infrastructures, and Authentication and Key Agreement\n\n\n\nStudents are able to - understand the mathematical foundations of secure and reliable information processing and their complexity-theoretical basis - are capable of analysing thesecurity of methods - model threats and evaluate the security of systems critically from the attacker’s perspective - understand the purpose and functioning of some security technologies and be aware of their limitations - select and apply appropriate cryptographic primitives in different application scenarios - select suitable security protocols for a given scenario and configure the relevant options for the cryptographic building blocks used within these protocols - identify security requirements and adequate security mechanisms in various application domains - identify potential weaknesses in security protocols not covered in detail during the course and propose appropriate fixes - assess the severity of novel attacks against security protocols and cryptographic primitives\n\n\n\n\nEither a written exam (90 minutes).\nOr an oral examination (30 minutes)."
  },
  {
    "objectID": "components/cs_embeddedsystems/description.html",
    "href": "components/cs_embeddedsystems/description.html",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "",
    "text": "Embedded systems control many things in our daily lives. Energy-efficient refrigerators, lift controls and advanced driver assistance systems are just a few examples. Embedded systems also control processes in industrial environments and are used to detect and prevent system failures. This lecture provides a general introduction to the topic of embedded systems and their performance. It presents basic concepts and highlights important differences to “normal” computer systems.\n\n\n\nThe module covers a selection of the following topics: - security, reliability, formal methods and dynamic systems. - microcontrollers - programmable logic controllers (PLCs) - PLC programming languages - real-time requirements - real-time operating systems - characteristics of embedded software design - intra-vehicle communication (e.g. CAN bus)\n\n\n\nStudents - can understand the solution to complex problems in embedded systems and apply those to related issues. - describe modern software techniques for embedded systems - apply a model-based, quality-oriented approach to the design of embedded software - recognise special quality requirements for the design of embedded software and take them into account appropriately\n\n\n\n\neither 120 min written exam\nor 20-30 min oral examination"
  },
  {
    "objectID": "components/cs_embeddedsystems/description.html#embedded-systems",
    "href": "components/cs_embeddedsystems/description.html#embedded-systems",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "",
    "text": "Embedded systems control many things in our daily lives. Energy-efficient refrigerators, lift controls and advanced driver assistance systems are just a few examples. Embedded systems also control processes in industrial environments and are used to detect and prevent system failures. This lecture provides a general introduction to the topic of embedded systems and their performance. It presents basic concepts and highlights important differences to “normal” computer systems.\n\n\n\nThe module covers a selection of the following topics: - security, reliability, formal methods and dynamic systems. - microcontrollers - programmable logic controllers (PLCs) - PLC programming languages - real-time requirements - real-time operating systems - characteristics of embedded software design - intra-vehicle communication (e.g. CAN bus)\n\n\n\nStudents - can understand the solution to complex problems in embedded systems and apply those to related issues. - describe modern software techniques for embedded systems - apply a model-based, quality-oriented approach to the design of embedded software - recognise special quality requirements for the design of embedded software and take them into account appropriately\n\n\n\n\neither 120 min written exam\nor 20-30 min oral examination"
  },
  {
    "objectID": "components/cs_efficientalgorithms/description.html",
    "href": "components/cs_efficientalgorithms/description.html",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "",
    "text": "This module deals with efficient algorithms, optimisation, and approximation algorithms.\n\n\n\nArchitecture and implementation of formal systems for the design of efficient algorithms, correctness-preserving optimisation, programme verification and synthesis. Design and analysis of approximation algorithms.\n\n\n\nStudents will be familiar with and understand basic techniques of formal programme development and its implementation. Students will be able to anticipate efficiency problems when designing algorithms and respond accordingly. Students will write better programmes that are highly optimised in their runtime-critical areas. Students will be able to analyse simple approximation methods in terms of their quality. They understand basic design techniques such as greedy, local search, scaling and methods based on linear programming and can also apply these to new problems.\n\n\n\n\nEither a 90-minute written exam.\nOr a 30 minute oral examination."
  },
  {
    "objectID": "components/cs_efficientalgorithms/description.html#design-of-efficient-algorithms",
    "href": "components/cs_efficientalgorithms/description.html#design-of-efficient-algorithms",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "",
    "text": "This module deals with efficient algorithms, optimisation, and approximation algorithms.\n\n\n\nArchitecture and implementation of formal systems for the design of efficient algorithms, correctness-preserving optimisation, programme verification and synthesis. Design and analysis of approximation algorithms.\n\n\n\nStudents will be familiar with and understand basic techniques of formal programme development and its implementation. Students will be able to anticipate efficiency problems when designing algorithms and respond accordingly. Students will write better programmes that are highly optimised in their runtime-critical areas. Students will be able to analyse simple approximation methods in terms of their quality. They understand basic design techniques such as greedy, local search, scaling and methods based on linear programming and can also apply these to new problems.\n\n\n\n\nEither a 90-minute written exam.\nOr a 30 minute oral examination."
  },
  {
    "objectID": "components/cs_declarativeprogramming/description.html",
    "href": "components/cs_declarativeprogramming/description.html",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "",
    "text": "This module deals with delarative modelling, problem-solving and programming. It can focus on the functional or logial programming paradigm.\n\n\n\n\nLogical-relational programming paradigm, top-down evaluation with SLD(NF) resolution. Introduction to the logical programming language Prolog: recursion, predicate-oriented programming, backtracking and cut, side effects, aggregations. Connection to (deductive) databases. Comparison with Datalog and brief introduction to advanced concepts such as constraint logic programming.\nPredicate logic fundamentals: Unification, Resolution, Horn clauses and SLD resolution\nLogic programmes: Operational and denotational semantics, Evaluation strategies\nThe Prolog programming language: Negation as failure, Non-logical components of Prolog, Programming techniques\nApplications and extensions of logic programming OR\nIntroduction to the Haskell programming language: Syntax of the various language constructs, Higher-order functions, Programming with lazy evaluation\nDenotational semantics of functional programmes: Complete orders and fixed points, Denotational semantics of Haskell\nLambda calculus: Syntax and operational semantics of lambda calculus, Reduction of Haskell to lambda calculus\nType checking and type inference\n\n\n\n\nStudents - have a broad, detailed and critical understanding of the latest knowledge in selected specialist areas in the field of declarative modelling - can implement compact and declarative programmes in Prolog and distinguish this approach from classical imperative programming - formally define the semantics of logical programming languages - targeted use of logical programming languages in various areas of application OR Students - explain the concepts underlying functional programming languages - learn and apply programming techniques in functional languages - formally define the semantics of functional programming languages - implement functional languages - design type checking procedures for functional languages - use functional languages in a targeted manner in various areas of application\n\n\n\n60-120 min written exam or 30 minute oral examination."
  },
  {
    "objectID": "components/cs_declarativeprogramming/description.html#declarative-programming",
    "href": "components/cs_declarativeprogramming/description.html#declarative-programming",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "",
    "text": "This module deals with delarative modelling, problem-solving and programming. It can focus on the functional or logial programming paradigm.\n\n\n\n\nLogical-relational programming paradigm, top-down evaluation with SLD(NF) resolution. Introduction to the logical programming language Prolog: recursion, predicate-oriented programming, backtracking and cut, side effects, aggregations. Connection to (deductive) databases. Comparison with Datalog and brief introduction to advanced concepts such as constraint logic programming.\nPredicate logic fundamentals: Unification, Resolution, Horn clauses and SLD resolution\nLogic programmes: Operational and denotational semantics, Evaluation strategies\nThe Prolog programming language: Negation as failure, Non-logical components of Prolog, Programming techniques\nApplications and extensions of logic programming OR\nIntroduction to the Haskell programming language: Syntax of the various language constructs, Higher-order functions, Programming with lazy evaluation\nDenotational semantics of functional programmes: Complete orders and fixed points, Denotational semantics of Haskell\nLambda calculus: Syntax and operational semantics of lambda calculus, Reduction of Haskell to lambda calculus\nType checking and type inference\n\n\n\n\nStudents - have a broad, detailed and critical understanding of the latest knowledge in selected specialist areas in the field of declarative modelling - can implement compact and declarative programmes in Prolog and distinguish this approach from classical imperative programming - formally define the semantics of logical programming languages - targeted use of logical programming languages in various areas of application OR Students - explain the concepts underlying functional programming languages - learn and apply programming techniques in functional languages - formally define the semantics of functional programming languages - implement functional languages - design type checking procedures for functional languages - use functional languages in a targeted manner in various areas of application\n\n\n\n60-120 min written exam or 30 minute oral examination."
  },
  {
    "objectID": "components/cs_complexitytheory/description.html",
    "href": "components/cs_complexitytheory/description.html",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "",
    "text": "This module covers advanced complexity theory.\n\n\n\nThe module includes the following topics:\n\nDeterministic, non-deterministic, probabilistic and parallel computational models\nComplexity classes; reductions\nComplexity of approximation problems\nSelection of advanced topics such as interactive proofs, derandomisation, circuit complexity, communication complexity, parametric complexity\nProperties of NP-complete sets, autoreducibility, polynomial time hierarchy\ncomplexity of probabilistic algorithms.\n\n\n\n\nStudents are able to analyse the correctness, security and complexity of processes. Students will be able to classify algorithmic problems according to their complexity. Students will be able to analyse the relationship between different complexity classes.\n\n\n\n\nEither a 90-minute written exam.\nOr a 20-30 minute oral examination."
  },
  {
    "objectID": "components/cs_complexitytheory/description.html#complexity-theory",
    "href": "components/cs_complexitytheory/description.html#complexity-theory",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "",
    "text": "This module covers advanced complexity theory.\n\n\n\nThe module includes the following topics:\n\nDeterministic, non-deterministic, probabilistic and parallel computational models\nComplexity classes; reductions\nComplexity of approximation problems\nSelection of advanced topics such as interactive proofs, derandomisation, circuit complexity, communication complexity, parametric complexity\nProperties of NP-complete sets, autoreducibility, polynomial time hierarchy\ncomplexity of probabilistic algorithms.\n\n\n\n\nStudents are able to analyse the correctness, security and complexity of processes. Students will be able to classify algorithmic problems according to their complexity. Students will be able to analyse the relationship between different complexity classes.\n\n\n\n\nEither a 90-minute written exam.\nOr a 20-30 minute oral examination."
  },
  {
    "objectID": "components/cs_ai/description.html",
    "href": "components/cs_ai/description.html",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "",
    "text": "This module deals with recent research in artificial intelligence.\n\n\n\nThe seminar addresses current research questions in the field of artificial intelligence.\n\n\n\nStudents - are able to define and interpret the special features, limitations, terminology and doctrines in the field of artificial intelligence. The knowledge and understanding gained by students forms the basis for the development and/or application of independent ideas in the field of artificial intelligence in a research-oriented context - have a broad, detailed and critical understanding of the latest state of knowledge in selected specialist areas in the field of artificial intelligence - are able to apply their knowledge, understanding and problem-solving skills in new and unfamiliar situations that are related to the field of artificial intelligence in a broader or multidisciplinary context.\n\n\n\n\n30 minute presentation with discussion"
  },
  {
    "objectID": "components/cs_ai/description.html#current-topics-in-artificial-intelligence",
    "href": "components/cs_ai/description.html#current-topics-in-artificial-intelligence",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "",
    "text": "This module deals with recent research in artificial intelligence.\n\n\n\nThe seminar addresses current research questions in the field of artificial intelligence.\n\n\n\nStudents - are able to define and interpret the special features, limitations, terminology and doctrines in the field of artificial intelligence. The knowledge and understanding gained by students forms the basis for the development and/or application of independent ideas in the field of artificial intelligence in a research-oriented context - have a broad, detailed and critical understanding of the latest state of knowledge in selected specialist areas in the field of artificial intelligence - are able to apply their knowledge, understanding and problem-solving skills in new and unfamiliar situations that are related to the field of artificial intelligence in a broader or multidisciplinary context.\n\n\n\n\n30 minute presentation with discussion"
  },
  {
    "objectID": "components/cs_computervision/description.html",
    "href": "components/cs_computervision/description.html",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "",
    "text": "The course imparts knowledge about current methods and algorithms in the field of computer vision. Important fundamentals and the latest approaches to image representation, image processing and image analysis are taught. Current models and methods of machine learning and their technical background are presented, and their respective applications in image processing are demonstrated.\n\n\n\n\nfundamental methods and techniques that enable a machine to analyse images and videos and understand their content\nfundamentals of image generation, linear filters, image segmentation, object recognition, object categorisation, 3D reconstructio\napplication of current methods of machine learning for the topics described above\n\n\n\n\n\nStudents describe current research trends and developments in the field of computer vision\nStudents name relevant techniques necessary for image and video analysis tasks\nStudents will be able to derive and explain methods and techniques that enable a machine to analyse images and videos and understand their content\nStudents select basic computer vision techniques that are necessary for these analysis tasks\nStudents independently apply the methods covered to real-world problems\nStudents implement the algorithms presented themselves and translate them into a programming language of their choice\n\n\n\n\n\neither a written exam (90-100 minutes)\nor an oral examination (20-30 minutes)\nor a project report (20-30 pages)"
  },
  {
    "objectID": "components/cs_computervision/description.html#computer-vision-and-image-processing",
    "href": "components/cs_computervision/description.html#computer-vision-and-image-processing",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "",
    "text": "The course imparts knowledge about current methods and algorithms in the field of computer vision. Important fundamentals and the latest approaches to image representation, image processing and image analysis are taught. Current models and methods of machine learning and their technical background are presented, and their respective applications in image processing are demonstrated.\n\n\n\n\nfundamental methods and techniques that enable a machine to analyse images and videos and understand their content\nfundamentals of image generation, linear filters, image segmentation, object recognition, object categorisation, 3D reconstructio\napplication of current methods of machine learning for the topics described above\n\n\n\n\n\nStudents describe current research trends and developments in the field of computer vision\nStudents name relevant techniques necessary for image and video analysis tasks\nStudents will be able to derive and explain methods and techniques that enable a machine to analyse images and videos and understand their content\nStudents select basic computer vision techniques that are necessary for these analysis tasks\nStudents independently apply the methods covered to real-world problems\nStudents implement the algorithms presented themselves and translate them into a programming language of their choice\n\n\n\n\n\neither a written exam (90-100 minutes)\nor an oral examination (20-30 minutes)\nor a project report (20-30 pages)"
  },
  {
    "objectID": "components/cs_distributedsystems/description.html",
    "href": "components/cs_distributedsystems/description.html",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "",
    "text": "This module deals with distributed IT systems and their performance.\n\n\n\nThe module covers a selection of the following topics:\n\nReliability of distributed systems: Concepts of distributed file systems, synchronization techniques for reliable distributed applications, concepts of load balancing in high-availability clusters,\nExample: Sensor networks: Routing in sensor networks, operating systems for sensor networks, security in sensor networks,\nSecure internet protocols (IP security (IPsec), Pretty Good Privacy (PGP), Secure Socket Layer (SSL), Transport Layer Security (TLS), Secure Shell (SSH), DNS security (DNSsec)), secure IPv6 networks.\nexample: internet of things\nTraffic theory models, basic concepts of probability theory, transformation methods, stochastic processes, methodology for performance analysis of technical systems, queueing and traffic theory discrete-time and continuous-time Markov chains, analysis of Markov and non-Markov systems, application examples for performance analysis of current computer systems and networks: service quality and other characteristics\nAlgorithms in message-passing systems\nLeader election and consensus\nRouting in networks: centralized and distributed approaches\nRandomized methods for contention resolution and congestion avoidance\nContagion and Distributed Network Dynamics\n\n\n\n\nStudents - can evaluate existing distributed systems in terms of reliability and security and identify vulnerabilities. - can correctly identify reliability and security requirements when designing new distributed systems and consider them early in the development process. - have the methodological knowledge and practical skills to model technical systems using probability theory and mathematical statistics. - describe foundational problems arising in distributed systems and explain algorithmic solutions for these problems. - apply general algorithmic design principles like randomized contention resolution and congestion avoidance and to use techniques like load balancing and randomization to solve problems arising in network contexts. - model distributed systems in a formal way and to develop algorithmic solutions enabling the efficient usage of computer networks and other distributed systems\n\n\n\n\neither 120 min written exam\nor 20-30 min oral examination"
  },
  {
    "objectID": "components/cs_distributedsystems/description.html#distributed-systems",
    "href": "components/cs_distributedsystems/description.html#distributed-systems",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "",
    "text": "This module deals with distributed IT systems and their performance.\n\n\n\nThe module covers a selection of the following topics:\n\nReliability of distributed systems: Concepts of distributed file systems, synchronization techniques for reliable distributed applications, concepts of load balancing in high-availability clusters,\nExample: Sensor networks: Routing in sensor networks, operating systems for sensor networks, security in sensor networks,\nSecure internet protocols (IP security (IPsec), Pretty Good Privacy (PGP), Secure Socket Layer (SSL), Transport Layer Security (TLS), Secure Shell (SSH), DNS security (DNSsec)), secure IPv6 networks.\nexample: internet of things\nTraffic theory models, basic concepts of probability theory, transformation methods, stochastic processes, methodology for performance analysis of technical systems, queueing and traffic theory discrete-time and continuous-time Markov chains, analysis of Markov and non-Markov systems, application examples for performance analysis of current computer systems and networks: service quality and other characteristics\nAlgorithms in message-passing systems\nLeader election and consensus\nRouting in networks: centralized and distributed approaches\nRandomized methods for contention resolution and congestion avoidance\nContagion and Distributed Network Dynamics\n\n\n\n\nStudents - can evaluate existing distributed systems in terms of reliability and security and identify vulnerabilities. - can correctly identify reliability and security requirements when designing new distributed systems and consider them early in the development process. - have the methodological knowledge and practical skills to model technical systems using probability theory and mathematical statistics. - describe foundational problems arising in distributed systems and explain algorithmic solutions for these problems. - apply general algorithmic design principles like randomized contention resolution and congestion avoidance and to use techniques like load balancing and randomization to solve problems arising in network contexts. - model distributed systems in a formal way and to develop algorithmic solutions enabling the efficient usage of computer networks and other distributed systems\n\n\n\n\neither 120 min written exam\nor 20-30 min oral examination"
  },
  {
    "objectID": "components/cs_elective/description.html",
    "href": "components/cs_elective/description.html",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "",
    "text": "Students in the cs-track have to choose a few advanced computer science modules. These can include: - Complexity Theory - Computer Vision - Declarative Programming - Distributed Systems - Efficient Algorithms - Embedded Systems - Security and Cryptography - High Performance Computing - Software Engineering II\nContents, competences and examination methods depend on the chosen modules. Obviously, every module can be completed only once."
  },
  {
    "objectID": "components/cs_elective/description.html#compulsory-electives",
    "href": "components/cs_elective/description.html#compulsory-electives",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "",
    "text": "Students in the cs-track have to choose a few advanced computer science modules. These can include: - Complexity Theory - Computer Vision - Declarative Programming - Distributed Systems - Efficient Algorithms - Embedded Systems - Security and Cryptography - High Performance Computing - Software Engineering II\nContents, competences and examination methods depend on the chosen modules. Obviously, every module can be completed only once."
  },
  {
    "objectID": "components/cs_project/description.html",
    "href": "components/cs_project/description.html",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "",
    "text": "Applied Research Software Engineering in scientific institutions\nThis lab module provides students with a hands-on opportunity to apply research software engineering principles to real-world scientific problems from the MINT disciplines (Mathematics, Informatics, Natural Sciences, and Technology). Students work in teams on projects originating from active research contexts — such as simulations in physics, data analysis in chemistry, modeling in biology, or …"
  },
  {
    "objectID": "components/cs_project/description.html#rseng-lab-module",
    "href": "components/cs_project/description.html#rseng-lab-module",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "",
    "text": "Applied Research Software Engineering in scientific institutions\nThis lab module provides students with a hands-on opportunity to apply research software engineering principles to real-world scientific problems from the MINT disciplines (Mathematics, Informatics, Natural Sciences, and Technology). Students work in teams on projects originating from active research contexts — such as simulations in physics, data analysis in chemistry, modeling in biology, or …"
  },
  {
    "objectID": "components/gen_cs/description.html",
    "href": "components/gen_cs/description.html",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "",
    "text": "This module covers the basics of computer science and introduces the students from domain sciences to programming.\n\n\n\nIntroduction to computer science, basic concepts of operating systems using UNIX/Linux as an example\nFrom problem to algorithm: concept of an algorithm, design of algorithms, pseudocode, refinement, brute-force algorithms, models and modeling, graphs and their representation, simple algorithms on graphs, analysis of algorithms (correctness, termination, runtime)\nImplementation of algorithms (e.g., using Python)\nProgramming paradigms: procedural, object-oriented, and functional programming; recursion versus iteration\nFrom program to process: assembly languages, assembler, compiler, interpreter, syntax and semantics of programming languages\nLimits of algorithms: computability, decidability, undecidability"
  },
  {
    "objectID": "components/gen_cs/description.html#fundamentals-of-computer-science",
    "href": "components/gen_cs/description.html#fundamentals-of-computer-science",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "",
    "text": "This module covers the basics of computer science and introduces the students from domain sciences to programming.\n\n\n\nIntroduction to computer science, basic concepts of operating systems using UNIX/Linux as an example\nFrom problem to algorithm: concept of an algorithm, design of algorithms, pseudocode, refinement, brute-force algorithms, models and modeling, graphs and their representation, simple algorithms on graphs, analysis of algorithms (correctness, termination, runtime)\nImplementation of algorithms (e.g., using Python)\nProgramming paradigms: procedural, object-oriented, and functional programming; recursion versus iteration\nFrom program to process: assembly languages, assembler, compiler, interpreter, syntax and semantics of programming languages\nLimits of algorithms: computability, decidability, undecidability"
  },
  {
    "objectID": "components/gen_datascience/description.html",
    "href": "components/gen_datascience/description.html",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "",
    "text": "This module introduces the students to statistical data analysis.\n\n\nThis module focuses on the statistical study and quantitative analysis of the dependence between observed random variables (e.g., yield/production settings; lifespan/treatment type and injury type). Essential foundations for the statistical treatment of such relationships are provided by the linear regression model, which is studied in detail in the first part of the lecture. Within this framework, topics such as estimation, testing, and uncertainty quantification (analysis of variance) are addressed. In the second part, an introduction to advanced methods and approaches for examining relationships is offered, including nonlinear and nonparametric regression models. Additionally, questions of classification and dimensionality reduction are covered.\n\n\n\nStudents will acquire a comprehensive, detailed and specialised understanding of the linear regression model based on the latest findings. They will learn basic concepts and methods of non-parametric statistics. They will also be able to solve complex statistical data analysis problems, weigh up alternative modelling approaches and evaluate them according to different criteria. They will be able to use functions from statistical software packages for this purpose.\n\n\n\nexam (120-180 minutes) or oral exam (30 minutes)"
  },
  {
    "objectID": "components/gen_datascience/description.html#statistical-data-analysis",
    "href": "components/gen_datascience/description.html#statistical-data-analysis",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "",
    "text": "This module introduces the students to statistical data analysis.\n\n\nThis module focuses on the statistical study and quantitative analysis of the dependence between observed random variables (e.g., yield/production settings; lifespan/treatment type and injury type). Essential foundations for the statistical treatment of such relationships are provided by the linear regression model, which is studied in detail in the first part of the lecture. Within this framework, topics such as estimation, testing, and uncertainty quantification (analysis of variance) are addressed. In the second part, an introduction to advanced methods and approaches for examining relationships is offered, including nonlinear and nonparametric regression models. Additionally, questions of classification and dimensionality reduction are covered.\n\n\n\nStudents will acquire a comprehensive, detailed and specialised understanding of the linear regression model based on the latest findings. They will learn basic concepts and methods of non-parametric statistics. They will also be able to solve complex statistical data analysis problems, weigh up alternative modelling approaches and evaluate them according to different criteria. They will be able to use functions from statistical software packages for this purpose.\n\n\n\nexam (120-180 minutes) or oral exam (30 minutes)"
  },
  {
    "objectID": "components/gen_programming/description.html",
    "href": "components/gen_programming/description.html",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "",
    "text": "This module builds on the basics of computer science and introduces the students to more advanced programming concepts like programming paradigms, algorithms and data structures.\n\n\nProgramming with an imperative-procedural language (such as C):\n\nData types, type casting, control structures, functions and procedures, parameter passing paradigms, call stack\nPointers, arrays, strings, structured types\nErrors and their handling\nDynamic memory management\nProgram libraries\n\n\n\n\n\nClasses, objects, constructors\nInheritance, polymorphism, abstract classes/interfaces\nExceptions and exception handling\nNamespaces (packages)\nGeneric classes and types\nProgram libraries"
  },
  {
    "objectID": "components/gen_programming/description.html#applied-programming",
    "href": "components/gen_programming/description.html#applied-programming",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "",
    "text": "This module builds on the basics of computer science and introduces the students to more advanced programming concepts like programming paradigms, algorithms and data structures.\n\n\nProgramming with an imperative-procedural language (such as C):\n\nData types, type casting, control structures, functions and procedures, parameter passing paradigms, call stack\nPointers, arrays, strings, structured types\nErrors and their handling\nDynamic memory management\nProgram libraries\n\n\n\n\n\nClasses, objects, constructors\nInheritance, polymorphism, abstract classes/interfaces\nExceptions and exception handling\nNamespaces (packages)\nGeneric classes and types\nProgram libraries"
  },
  {
    "objectID": "components/gen_softwareeng2/description.html",
    "href": "components/gen_softwareeng2/description.html",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "",
    "text": "The module covers a selection of advanced topics in the field of software engineering, for example in the areas of software quality assurance, service engineering, virtualisation, programming languages and design, and formal methods in system design. It builds on knowledge and competencies from Software Engineering I.\n\n\nStudents - have an in-depth understanding of and the ability to use various approaches to software engineering - are familiar with the characteristics of numerous technologies and tools for specification, component-based development and quality assurance of modern software systems, as well as their application in various contexts.\n\n\n\n\nwritten exam (100 min)\nexercise sheets or group project"
  },
  {
    "objectID": "components/gen_softwareeng2/description.html#classical-software-engineering-ii",
    "href": "components/gen_softwareeng2/description.html#classical-software-engineering-ii",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "",
    "text": "The module covers a selection of advanced topics in the field of software engineering, for example in the areas of software quality assurance, service engineering, virtualisation, programming languages and design, and formal methods in system design. It builds on knowledge and competencies from Software Engineering I.\n\n\nStudents - have an in-depth understanding of and the ability to use various approaches to software engineering - are familiar with the characteristics of numerous technologies and tools for specification, component-based development and quality assurance of modern software systems, as well as their application in various contexts.\n\n\n\n\nwritten exam (100 min)\nexercise sheets or group project"
  },
  {
    "objectID": "components/mnt_project/description.html",
    "href": "components/mnt_project/description.html",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "",
    "text": "Applied Research Software Engineering in STEM sciences\nThis lab module provides students with a hands-on opportunity to apply research software engineering principles to real-world scientific problems from the MINT disciplines (Mathematics, Informatics, Natural Sciences, and Technology). Students work on projects originating from active research contexts — such as simulations in physics, data analysis in chemistry, modeling in biology, or"
  },
  {
    "objectID": "components/mnt_project/description.html#science-lab-module",
    "href": "components/mnt_project/description.html#science-lab-module",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "",
    "text": "Applied Research Software Engineering in STEM sciences\nThis lab module provides students with a hands-on opportunity to apply research software engineering principles to real-world scientific problems from the MINT disciplines (Mathematics, Informatics, Natural Sciences, and Technology). Students work on projects originating from active research contexts — such as simulations in physics, data analysis in chemistry, modeling in biology, or"
  },
  {
    "objectID": "components/rse_hpc/description.html",
    "href": "components/rse_hpc/description.html",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "",
    "text": "RSEs with expertise in HPC and other performance-critical computing domains specialize in optimizing code for efficient execution across various platforms, including clusters, cloud, edge, and embedded systems. They understand parallel programming models, hardware-specific optimizations, profiling tools, and platform constraints such as memory, energy, and latency. Their skills enable them to adapt software to diverse infrastructures, manage complex dependencies, and support researchers in accessing and using advanced computing resources effectively and sustainably.\n\n\nBuilding on “Basic Scientific Computing”, this module dives deeper into scalable algorithms, architectures, and software engineering techniques required to run large‑scale simulations and data analysis on high‑performance computing (HPC) systems.\n\n\n\nParticipants who successfully complete the module will be able to\n\nClassify scientific problems by their dominant parallel pattern (memory‑parallel, compute‑parallel, task‑parallel).\nMap each class to appropriate numerical libraries and hardware architectures.\nAnalyse floating‑point and algorithmic approximation errors at scale.\nExplain modern HPC hardware features (GPUs, SIMD/AVX, NUMA, high‑speed interconnects) and select relevant optimisation strategies.\nDesign portable, performance‑portable code employing MPI, OpenMP, and accelerator frameworks.\nUse continuous benchmarking to guide sustainable performance evolution of research software.\nPlan for long‑term maintenance, archival, and FAIR publication of large‑scale codes and data.\n\n\n\n\n\n\n\n\n\n\n\n\nWeek\nTheme\nTopics\n\n\n\n\n1\nParallel Problem Taxonomy\nSparse vs. dense linear algebra · embarrassingly parallel workloads\n\n\n2\nDistributed Memory (MPI)\nDomain decomposition · halo exchange · scalability metrics\n\n\n3\nShared Memory & SIMD\nOpenMP · threading pitfalls · AVX intrinsics\n\n\n4\nAccelerator Programming\nMulti‑GPU kernels · unified memory · portability layers (Kokkos, SYCL)\n\n\n5\nAdvanced I/O & Checkpointing\nParallel file systems · burst buffers · HDF5/ADIOS‑based workflows\n\n\n6\nPerformance Engineering\nRoofline model · continuous & comparative benchmarking · autotuning\n\n\n7\nSustainable HPC Software\nRelease engineering · long‑term archiving · community governance\n\n\n\n\n\n\nBlended delivery: interactive lectures (40%), coding workshops on the national cluster (50%), expert seminars (10%).\n\n\n\n\n\n\n\n\n\n\n\nComponent\nWeight\nDetails\n\n\n\n\nCluster labs\n30%\nSubmission of working MPI/OpenMP/GPU exercises\n\n\nPerformance study\n30%\nRoofline + scaling analysis of an existing code\n\n\nCapstone project\n40%\nImplement & optimise a solver or ML pipeline at scale, plus written report\n\n\n\n\n\n\n\nCompletion of - Scientific Computing or equivalent experience\nFamiliarity with Linux command line and version control\n\n\n\n\n\nreplace CHatGPT fantasies"
  },
  {
    "objectID": "components/rse_hpc/description.html#highperformance-computing-for-rse",
    "href": "components/rse_hpc/description.html#highperformance-computing-for-rse",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "",
    "text": "RSEs with expertise in HPC and other performance-critical computing domains specialize in optimizing code for efficient execution across various platforms, including clusters, cloud, edge, and embedded systems. They understand parallel programming models, hardware-specific optimizations, profiling tools, and platform constraints such as memory, energy, and latency. Their skills enable them to adapt software to diverse infrastructures, manage complex dependencies, and support researchers in accessing and using advanced computing resources effectively and sustainably.\n\n\nBuilding on “Basic Scientific Computing”, this module dives deeper into scalable algorithms, architectures, and software engineering techniques required to run large‑scale simulations and data analysis on high‑performance computing (HPC) systems.\n\n\n\nParticipants who successfully complete the module will be able to\n\nClassify scientific problems by their dominant parallel pattern (memory‑parallel, compute‑parallel, task‑parallel).\nMap each class to appropriate numerical libraries and hardware architectures.\nAnalyse floating‑point and algorithmic approximation errors at scale.\nExplain modern HPC hardware features (GPUs, SIMD/AVX, NUMA, high‑speed interconnects) and select relevant optimisation strategies.\nDesign portable, performance‑portable code employing MPI, OpenMP, and accelerator frameworks.\nUse continuous benchmarking to guide sustainable performance evolution of research software.\nPlan for long‑term maintenance, archival, and FAIR publication of large‑scale codes and data.\n\n\n\n\n\n\n\n\n\n\n\n\nWeek\nTheme\nTopics\n\n\n\n\n1\nParallel Problem Taxonomy\nSparse vs. dense linear algebra · embarrassingly parallel workloads\n\n\n2\nDistributed Memory (MPI)\nDomain decomposition · halo exchange · scalability metrics\n\n\n3\nShared Memory & SIMD\nOpenMP · threading pitfalls · AVX intrinsics\n\n\n4\nAccelerator Programming\nMulti‑GPU kernels · unified memory · portability layers (Kokkos, SYCL)\n\n\n5\nAdvanced I/O & Checkpointing\nParallel file systems · burst buffers · HDF5/ADIOS‑based workflows\n\n\n6\nPerformance Engineering\nRoofline model · continuous & comparative benchmarking · autotuning\n\n\n7\nSustainable HPC Software\nRelease engineering · long‑term archiving · community governance\n\n\n\n\n\n\nBlended delivery: interactive lectures (40%), coding workshops on the national cluster (50%), expert seminars (10%).\n\n\n\n\n\n\n\n\n\n\n\nComponent\nWeight\nDetails\n\n\n\n\nCluster labs\n30%\nSubmission of working MPI/OpenMP/GPU exercises\n\n\nPerformance study\n30%\nRoofline + scaling analysis of an existing code\n\n\nCapstone project\n40%\nImplement & optimise a solver or ML pipeline at scale, plus written report\n\n\n\n\n\n\n\nCompletion of - Scientific Computing or equivalent experience\nFamiliarity with Linux command line and version control\n\n\n\n\n\nreplace CHatGPT fantasies"
  },
  {
    "objectID": "components/rse_management/description.html",
    "href": "components/rse_management/description.html",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "",
    "text": "This module comprises the communication and management skills that are relevant for working in the interdisciplinary setting of RSE-professionals.\nThis includes but is not limited to:\n\nworking in a team (see TEAM in (Goth et al. 2024))\nteaching RSE-basics (see TEACH in (Goth et al. 2024))\nproject management (see PM in (Goth et al. 2024))\ninteraction with users and other stakeholders (see USERS in (Goth et al. 2024))\n\nThe lecture covers project and team management techniques an RSE needs in everyday life and the taught methods are applied and practiced with case-studys, role-plays etc. in the exercise.\n\n\n\n\nresearch management\n\nresearch cycle\nopen science, FAIR, FAIR4RS\npublication workflow: obstacles and embargoes\nlegal aspects of research data, e.g. GDPR\npseudonymization/anonymization methods for data privacy\npublic databases\n\nquality control\n\nrequirements engineering\ntrying goals with quality: test-driven development\nbehavior-driven development, Gherkin-Style acceptance testing\nproject folder organization\ncode review principles\n\ncommunication and collaboration\n\ncommunication frameworks, e.g. AIDA, RACE, 7 C’s\npersonality traits and their impact on cooperation\ncollaboration frameworks for remote work\nrealisation and benefits of pair programming and mob/ensemble programming\ntechnical English writing skills: writing in issues and merge requests, code review…\nconflict management, e.g. dealing with researchers that do not listen\nhow to address relevant stakeholders (i.e. users and SEs) with different background knowledge, experience and expectations\nequity, diversity and inclusion principles\n\nteam management\n\nchallenges of transient teams (that only exist for 5-15 hours)\neffects of varying team sizes\nmanagement depending on project size/type\nspecialised roles in a software team\nintercultural and interdisciplinary differences\nteam management methodologies\nimportance of shared values in a RSE team\ndual goals: project vs. personal goal\n\ntime and project management\n\ngoal-setting\nproject management methods, their strengths and weaknesses\nagile (not necessarily Scrum)\nLean & Kanban (Small-Batch Philosophies)\ndivision of tasks into sub-tasks and task-dependencies\niterative workflows\ncontinuous delivery\ncommunication with a manager/supervisor"
  },
  {
    "objectID": "components/rse_management/description.html#rseng-management-and-communication",
    "href": "components/rse_management/description.html#rseng-management-and-communication",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "",
    "text": "This module comprises the communication and management skills that are relevant for working in the interdisciplinary setting of RSE-professionals.\nThis includes but is not limited to:\n\nworking in a team (see TEAM in (Goth et al. 2024))\nteaching RSE-basics (see TEACH in (Goth et al. 2024))\nproject management (see PM in (Goth et al. 2024))\ninteraction with users and other stakeholders (see USERS in (Goth et al. 2024))\n\nThe lecture covers project and team management techniques an RSE needs in everyday life and the taught methods are applied and practiced with case-studys, role-plays etc. in the exercise.\n\n\n\n\nresearch management\n\nresearch cycle\nopen science, FAIR, FAIR4RS\npublication workflow: obstacles and embargoes\nlegal aspects of research data, e.g. GDPR\npseudonymization/anonymization methods for data privacy\npublic databases\n\nquality control\n\nrequirements engineering\ntrying goals with quality: test-driven development\nbehavior-driven development, Gherkin-Style acceptance testing\nproject folder organization\ncode review principles\n\ncommunication and collaboration\n\ncommunication frameworks, e.g. AIDA, RACE, 7 C’s\npersonality traits and their impact on cooperation\ncollaboration frameworks for remote work\nrealisation and benefits of pair programming and mob/ensemble programming\ntechnical English writing skills: writing in issues and merge requests, code review…\nconflict management, e.g. dealing with researchers that do not listen\nhow to address relevant stakeholders (i.e. users and SEs) with different background knowledge, experience and expectations\nequity, diversity and inclusion principles\n\nteam management\n\nchallenges of transient teams (that only exist for 5-15 hours)\neffects of varying team sizes\nmanagement depending on project size/type\nspecialised roles in a software team\nintercultural and interdisciplinary differences\nteam management methodologies\nimportance of shared values in a RSE team\ndual goals: project vs. personal goal\n\ntime and project management\n\ngoal-setting\nproject management methods, their strengths and weaknesses\nagile (not necessarily Scrum)\nLean & Kanban (Small-Batch Philosophies)\ndivision of tasks into sub-tasks and task-dependencies\niterative workflows\ncontinuous delivery\ncommunication with a manager/supervisor"
  },
  {
    "objectID": "components/rse_researchmethods/description.html",
    "href": "components/rse_researchmethods/description.html",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "",
    "text": "The module addresses the complex field of interaction between software as part of the reproducible research process and as a variable and research result in its own right. Similar to statistics, the use of computer technology leads to an expansion of possible research topics, but also to new sources of error, complexity and associated approaches.\nThis includes but is not limited to:\n\nForms of research and disciplinary culture\nEmpirical research methods (e.g. for software evaluation)\nDesign-based research and design science\nQualitative methods for concept evaluation\nSimulation techniques and mixed methods"
  },
  {
    "objectID": "components/rse_researchmethods/description.html#research-paradigms-and-methodology-for-rses",
    "href": "components/rse_researchmethods/description.html#research-paradigms-and-methodology-for-rses",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "",
    "text": "The module addresses the complex field of interaction between software as part of the reproducible research process and as a variable and research result in its own right. Similar to statistics, the use of computer technology leads to an expansion of possible research topics, but also to new sources of error, complexity and associated approaches.\nThis includes but is not limited to:\n\nForms of research and disciplinary culture\nEmpirical research methods (e.g. for software evaluation)\nDesign-based research and design science\nQualitative methods for concept evaluation\nSimulation techniques and mixed methods"
  },
  {
    "objectID": "components/rse_society_philosophy/description.html",
    "href": "components/rse_society_philosophy/description.html",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "",
    "text": "The RSE master’s program is more than a computer science specialisation for researchers. People working as RSEs are often involved in digitalization projects, institutional development or other non-technical tasks. Also, introducing students to cutting-edge technologies, raises ethical questions. To talk about the impact of RSE on society, is therefore crucial. This module addresses the social context of RSEng. Students examine issues relating to sustainability, ethics, responsibility and the impact of new technologies. The module provides space for student-driven projects that address social challenges such as green tech and artificial intelligence, and encourages reflection on the role of RSEng in science and society. It offers space for engagement with current challenges that are constantly changing but should be part of a curriculum in the age of digitalisation\n\n\n\nFor a university level study program, it is fitting that students learn an abstract high-level understanding of their field so that they can adapt technical models, communication frameworks and policy recommendations to the complex cases. Therefor, they need a solid understanding in some of the more theoretical fields such as … - RSEng in the context of philosophy of science - sociology of technology - ethics and artificial intelligence - human computer interaction - digital humanities - fundamentals and values of RSEng - ethics and responsibility of (research) software engineers - RSEng in the context of Open Science and the common good - dual use dilemma - sustainability and green technology - future of work - gender inequalities - Technology assessment\n\n\n\nThis module conveys competences in areas such as but not limited to: - discussion of ethical questions - awareness of societal consequences - conducting and leading research (NEW) - understanding the research cycle (RC)"
  },
  {
    "objectID": "components/rse_society_philosophy/description.html#rseng-ethics-society",
    "href": "components/rse_society_philosophy/description.html#rseng-ethics-society",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "",
    "text": "The RSE master’s program is more than a computer science specialisation for researchers. People working as RSEs are often involved in digitalization projects, institutional development or other non-technical tasks. Also, introducing students to cutting-edge technologies, raises ethical questions. To talk about the impact of RSE on society, is therefore crucial. This module addresses the social context of RSEng. Students examine issues relating to sustainability, ethics, responsibility and the impact of new technologies. The module provides space for student-driven projects that address social challenges such as green tech and artificial intelligence, and encourages reflection on the role of RSEng in science and society. It offers space for engagement with current challenges that are constantly changing but should be part of a curriculum in the age of digitalisation\n\n\n\nFor a university level study program, it is fitting that students learn an abstract high-level understanding of their field so that they can adapt technical models, communication frameworks and policy recommendations to the complex cases. Therefor, they need a solid understanding in some of the more theoretical fields such as … - RSEng in the context of philosophy of science - sociology of technology - ethics and artificial intelligence - human computer interaction - digital humanities - fundamentals and values of RSEng - ethics and responsibility of (research) software engineers - RSEng in the context of Open Science and the common good - dual use dilemma - sustainability and green technology - future of work - gender inequalities - Technology assessment\n\n\n\nThis module conveys competences in areas such as but not limited to: - discussion of ethical questions - awareness of societal consequences - conducting and leading research (NEW) - understanding the research cycle (RC)"
  },
  {
    "objectID": "components/rse_teaching/description.html",
    "href": "components/rse_teaching/description.html",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "",
    "text": "This seminar introduces students to possible teaching methods for RSEng in their third semester. As preparation for working as an RSE in interdisciplinary teams, students need some skills in teaching others about research software and the development process of it (see TEACH in (Goth et al. 2024))\nThis includes but is not limited to: - General didactic principles for designing learning units, competence orientation, task design, differentiation, feedback, diagnostics, criteria for good teaching and learning materials and formats (face-to-face, online, integrated or hybrid teaching) - Dealing with diverse learning prerequisites in computer science education, e.g. participation, motivation, self-regulation, subject-specific interest, subject-specific self-concept, self-efficacy expectations, fear of failure and misconceptions - Common approaches and methods for computer science education - PRIMM approach (Predict; Run; Investigate; Modify; Make) - Project-based learning, possibly with external partners - Gamification & game-based learning - Mastery learning - Self-regulated learning - Cooperative learning, team formation and the influence of team composition - Constructionism - (Distributed) pair programming - Live coding - Programming paradigms (especially procedures vs. objects first) - Understanding and improving given code (refactoring) - The twelve principles for practical digital teaching of software engineering - Tools for modern computer science education, in particular programming environments, pair programming with AI, debugging and automated testing - RSE-SE concepts"
  },
  {
    "objectID": "components/rse_teaching/description.html#rseng-teaching",
    "href": "components/rse_teaching/description.html#rseng-teaching",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "",
    "text": "This seminar introduces students to possible teaching methods for RSEng in their third semester. As preparation for working as an RSE in interdisciplinary teams, students need some skills in teaching others about research software and the development process of it (see TEACH in (Goth et al. 2024))\nThis includes but is not limited to: - General didactic principles for designing learning units, competence orientation, task design, differentiation, feedback, diagnostics, criteria for good teaching and learning materials and formats (face-to-face, online, integrated or hybrid teaching) - Dealing with diverse learning prerequisites in computer science education, e.g. participation, motivation, self-regulation, subject-specific interest, subject-specific self-concept, self-efficacy expectations, fear of failure and misconceptions - Common approaches and methods for computer science education - PRIMM approach (Predict; Run; Investigate; Modify; Make) - Project-based learning, possibly with external partners - Gamification & game-based learning - Mastery learning - Self-regulated learning - Cooperative learning, team formation and the influence of team composition - Constructionism - (Distributed) pair programming - Live coding - Programming paradigms (especially procedures vs. objects first) - Understanding and improving given code (refactoring) - The twelve principles for practical digital teaching of software engineering - Tools for modern computer science education, in particular programming environments, pair programming with AI, debugging and automated testing - RSE-SE concepts"
  },
  {
    "objectID": "event/kickoff-workshops/workshops.html",
    "href": "event/kickoff-workshops/workshops.html",
    "title": "Workshops for the Research Software Engineering Master",
    "section": "",
    "text": "In modern science, software-based research is playing an increasingly central role. The professional development and competent use of software are crucial for progress in nearly all scientific disciplines. Accordingly, the professional profile of Research Software Engineers (RSEs) has emerged—characterized by a combination of expertise in software development and a deep understanding of scientific research processes. With the growing importance of this role, particularly in the context of emerging Research Software Engineering (RSE) service centers at and for research institutions, there is an increasing demand for dedicated Master’s programs in RSE or for the integration of RSE profiles into existing, thematically related Master’s programs.\nWe invite all members of the RSE community and interested scientists and educators to join us in developing a Master’s curriculum tailored to the unique needs, interests, and challenges of RSE. Each module represents a specific area of the RSE landscape and will be shaped by community-driven short online workshops (2–3 hours each).\nThe main idea is to supplement general courses on software engineering, data science and advanced science classes with RSE-specific courses tailored to the growing field of software engineering in research. Mapping necessary required basic courses is part the process.\nThese example modules will be new in structure and content and provide universities a suggestion how to hire and support the growing need for RSE competencies. These courses will be optional in the sense that alternatives or similar existing classes will be suggested if a specialized lecturer is not available.\nIn these workshops, we collaboratively define:\n\nRelevant competences\nSuggested course structures\nRSE-specific perspectives\n\nThese efforts will feed directly into the development of a comprehensive and inclusive RSE Master’s curriculum. You can explore the broader project here: RSE Masters Curriculum GitHub Repository"
  },
  {
    "objectID": "event/kickoff-workshops/workshops.html#rse-management-and-communication",
    "href": "event/kickoff-workshops/workshops.html#rse-management-and-communication",
    "title": "Workshops for the Research Software Engineering Master",
    "section": "1. RSE Management and Communication",
    "text": "1. RSE Management and Communication\nThis module encapsulates the communication and management skills that are relevant for working in the interdisciplinary setting of RSE-professionals.\nThis may include but is not limited to:\n\nworking in a team (see TEAM in (Goth et al. 2024))\nteaching RSE-basics (see TEACH in (Goth et al. 2024))\nproject management (see PM in (Goth et al. 2024))\ninteraction with users and other stakeholders (see USERS in (Goth et al. 2024))\nFAIR for humans and machines\nSoftware Management Plans for research software"
  },
  {
    "objectID": "event/kickoff-workshops/workshops.html#the-missing-semester-tooling-utility",
    "href": "event/kickoff-workshops/workshops.html#the-missing-semester-tooling-utility",
    "title": "Workshops for the Research Software Engineering Master",
    "section": "2. The Missing Semester / Tooling / Utility",
    "text": "2. The Missing Semester / Tooling / Utility\nIn reference to the MIT Missing Semester this module tries to convey the nuts and bolts of code development.\nThis may include (but is not limited to):\n\nShell Tools and Scripting\nEditors & IDE (i.e. Vim)\nData Wrangling\nCommand-line Environment\nVersion Control (Git)\nDebugging and Profiling\nMetaprogramming\nDocumentation\nSecurity and Cryptography (ssh, md5)\n\nThese general competencies can be extended to RSE-specific techniques such as:\n\nSoftware publication and citation (see SP in (Goth et al. 2024))\nUsing domain repositories/directories (see DOMREP in (Goth et al. 2024))\n\nOne early idea is to employ inquiry-based learning and peer teaching to convey these issues that may otherwise be too applied to a university curriculum. This would serve the idea that communicating and teaching RSE-skills is one of the cornerstones of a RSE professional (see TEACH in (Goth et al. 2024))."
  },
  {
    "objectID": "event/kickoff-workshops/workshops.html#rse-efficient-computing-and-hardware",
    "href": "event/kickoff-workshops/workshops.html#rse-efficient-computing-and-hardware",
    "title": "Workshops for the Research Software Engineering Master",
    "section": "3. RSE Efficient Computing and Hardware",
    "text": "3. RSE Efficient Computing and Hardware\nRSEs with expertise in HPC and other performance-critical computing domains specialize in optimizing code for efficient execution across various platforms, including clusters, cloud, edge, and embedded systems. They understand parallel programming models, hardware-specific optimizations, profiling tools, and platform constraints such as memory, energy, and latency. Their skills enable them to adapt software to diverse infrastructures, manage complex dependencies, and support researchers in accessing and using advanced computing resources effectively and sustainably.\nDepending on the goals of the workshop, it may be useful to focus on participants with a background in technical computer science or some prior exposure to parallel programming. Familiarity with teaching multithreading, MPI, or GPU programming (e.g., CUDA) could be helpful, especially if we dive into hands-on HPC RSE aspects."
  },
  {
    "objectID": "event/kickoff-workshops/workshops.html#programming-and-software-engineering-for-research",
    "href": "event/kickoff-workshops/workshops.html#programming-and-software-engineering-for-research",
    "title": "Workshops for the Research Software Engineering Master",
    "section": "4. Programming and Software Engineering for Research",
    "text": "4. Programming and Software Engineering for Research\n\nProgramming for Research\nThe RSE programming module extends the Fundamentals of Computer Science module with a focus on RSE-specific programming patterns, necessary technologies and good practices.\nThis may include, but is not limited to\n\nsoftware re-use (see SRU in (Goth et al. 2024))\ncreating documented code building blocks (see DOCBB in (Goth et al. 2024))\nbuilding distributable software (see DIST in (Goth et al. 2024))\nresearch specific programming languages\nresearch specific code requirements (scalability, functional programming, …)\nVector and graph database in generative AI applications //This topic (LLM or AI) has been not yet deeply explored in RSE field. Perhaps someone here is an AI expert who can suggest more specific programmes?\n\n\n\nResearch Software Engineering\nThis module extends the Classical Software Engineering Module with research specific learnings. This may include but is not limited to\n\nAdapting the software life cycle to research (see SWLC in (Goth et al. 2024))\nSoftware behaviour awareness and analysis (see MOD in (Goth et al. 2024))\nResearch specific Engineering Patterns"
  },
  {
    "objectID": "event/kickoff-workshops/workshops.html#rse-theory",
    "href": "event/kickoff-workshops/workshops.html#rse-theory",
    "title": "Workshops for the Research Software Engineering Master",
    "section": "5. RSE Theory",
    "text": "5. RSE Theory\nThe RSE master program is more than a computer science specialisation for researchers. People working as RSE are often involved in digitalization projects, institutional development or other non-technical tasks.\nFor a university level study program it is fitting that students learn an abstract high-level understanding of their field so that they can adapt technical models, communication frameworks and policy recommendations to the complex cases. For this they need a solid understanding in some of the more theoretical fields such as …\n\nphilosophy of science\nsociology of technology\nethics and artificial intelligence\nhuman computer interaction\ndigital humanities\n\nThis module conveys competences in areas such as but not limited to …\n\nconducting and leading research (NEW)\nunderstanding the research cycle (RC)\ninteraction with users and stakeholders (USERS)"
  },
  {
    "objectID": "event/kickoff-workshops/workshops.html#rse-for-natural-sciences",
    "href": "event/kickoff-workshops/workshops.html#rse-for-natural-sciences",
    "title": "Workshops for the Research Software Engineering Master",
    "section": "6. RSE for Natural Sciences",
    "text": "6. RSE for Natural Sciences\nThis workshop focuses on the specific requirements and priorities in the natural sciences. One of the intended profiles for the RSE Master’s curriculum is the professional development and specialization of researchers working in natural science disciplines.\nThe workshop will address the following topics:\n\nRSE competencies required in the natural sciences\nProfessional development and specific working conditions in the natural sciences\nInstitutional stakeholders and interested parties involved in shaping the MNT (Mathematics, Natural Sciences, and Technology) profile"
  },
  {
    "objectID": "event/kickoff-workshops/workshops.html#institutional-constraints-of-the-rse-master",
    "href": "event/kickoff-workshops/workshops.html#institutional-constraints-of-the-rse-master",
    "title": "Workshops for the Research Software Engineering Master",
    "section": "7. Institutional Constraints of the RSE Master",
    "text": "7. Institutional Constraints of the RSE Master\nThis workshop aims to clarify the structural framework of a Master’s program in Research Software Engineering (RSE). We will discuss the typical program duration (two years in Germany) and whether alternatives—such as one- or three-year formats—should be considered.\nKey questions include:\n\nWhich faculties or departments are authorized to grant the degree? Should it be restricted to Computer Science, or could other disciplines also serve as the awarding body under certain conditions?\nWhat should the admission requirements be, particularly for applicants from interdisciplinary backgrounds?\n\nWe will also explore the composition of the curriculum:\n\nIs it possible to structure levels of RSE competence similarly to the German Informatics Society’s model for Computer Science degrees?\nHow should the program balance the research (R) and software engineering (SE) components?\nWhat profiles or tracks might be envisioned, and how modular and flexible should the curriculum be?"
  },
  {
    "objectID": "general/ideas.html",
    "href": "general/ideas.html",
    "title": "Ideas",
    "section": "",
    "text": "Electronic Lab course. Heard of this in Erlangen for physics. Talks about ELN among other things.\n\n\nThe target audience for such a master’s programme would be students holding a bachelor’s degree from a domain science, which we will call home domain in the following.\nThere is explicitly no restriction on the candidates’ home domain: it may be from the STEM disciplines, life sciences, humanities or social sciences. Candidates with a bachelor’s degree in computer science are also explicitly included, although we acknowledge that their master’s programme should include adaptations to make their interaction effective with other domain scientists.\nIn order to give the future RSE the necessary breadth, we expect this to be a four semester curriculum.\nThe curriculum is formed from a combination of modules, some of which are core modules teaching essential skills that must be completed by all students. Other modules introduce more specialised concepts and skills.\nDuring the master’s programme, students should pick an RSE specialisation from the list in this paper and attend these additional modules to deepen their knowledge in the field.\nCore modules are of course drawn from the three pillars of the RSE and can be categorised accordingly.\n\n\n\nFoundational module\nIntroduction to programming: Emphasising use cases over programming paradigms, students learn at least two languages:\n\nA language that facilitates prototyping and data processing e.g., Python or R\nA language for designing complex, performance-critical systems e.g., C/Cpp\nThis exposes them to computers in a hands-on fashion and is the foundation for DOCBB, DIST.\n\nComputing environment module\nProgramming languages are not enough to work in a landscape of many interconnected software components. Hence, we require something like software craftsmanship:\n\nTools: Unix shell, version control systems, build systems, documentation generators, package distribution platforms, and software discovery systems\nThis strengthens skills in DIST, DOCBB, SWREPOS, SRU.\n\nSoftware engineering module\nDevelop foundational software engineering competencies:\n\nRequirements engineering\nSoftware architecture and design\nImplementation, quality assurance, and software evolution\nEmphasising and strengthening DOCBB, DIST on a more abstract level.\n\n\n\n\n\n\nOptional domain mastery module\nAdditional minor research courses; students with a home-domain already have the research part well-covered.\nResearch tools module\nTeach tools used to distribute and publish software, and introduce domain-specific data repositories, gaining foundational knowledge in SRU, SP, DOMREP.\nMeta-research module\nTeach how research works: Introduce the research life cycle, the data life cycle, and the software life cycle abstractly.\n\n\n\n\n\nProject management methods\nTeach project management methods that are useful in science, such as agile ones PM.\nCommunication skills module\nCourses focusing on:\n\nInterdisciplinary communication\nInteracting across cultures\nCommunication in hierarchies\nSupporting end users effectively\nAll facets of the USERS skill.\n\nTeaching module\nCovers topics to effectively design courses and teaching material for various digital tools, strengthening the TEACH skill.\n\n\n\n\n\nRSE work also involves craftsmanship skills. Hands-on practice is integral.\n\nAt least two lab projects are required within the mandatory curriculum.\nThese should be team-based and involve a question from a domain science.\nIdeally, projects cover both the candidate’s home domain and another domain.\nProjects should stem from collaborations with scientists within the institution, with RSE students taking on a consultant role.\n\nThis setup strengthens TEAM, TEACH, USERS and likely also MOD through interaction.\nTo emphasise exposure beyond their bachelor’s domain, RSEs should support their non-home-domain project with introductory courses from that discipline. This encourages adapting vocabulary and thinking—an aspect of MOD.\n\n\n\nTo align with the specialisations listed in this paper, example optional modules include:\n\nHPC engineering / parallel programming\nNumerical mathematics / scientific computing\nWeb technologies\nData stewardship\nAI models / statistics\nCommunity management / training\n\n\n\n\nThe programme concludes with a master’s thesis that should:\n\nBe dual-supervised by an RSE project supervisor and a domain supervisor\nAnswer a relevant research question strengthening NEW using computational methods\nInclude software development as a required, gradable deliverable\n\nThe RSE supervisor ensures and grades the software craftsmanship. This ensures the effective application of RSE skills in an actual research environment."
  },
  {
    "objectID": "general/ideas.html#original-motivation",
    "href": "general/ideas.html#original-motivation",
    "title": "Ideas",
    "section": "",
    "text": "The target audience for such a master’s programme would be students holding a bachelor’s degree from a domain science, which we will call home domain in the following.\nThere is explicitly no restriction on the candidates’ home domain: it may be from the STEM disciplines, life sciences, humanities or social sciences. Candidates with a bachelor’s degree in computer science are also explicitly included, although we acknowledge that their master’s programme should include adaptations to make their interaction effective with other domain scientists.\nIn order to give the future RSE the necessary breadth, we expect this to be a four semester curriculum.\nThe curriculum is formed from a combination of modules, some of which are core modules teaching essential skills that must be completed by all students. Other modules introduce more specialised concepts and skills.\nDuring the master’s programme, students should pick an RSE specialisation from the list in this paper and attend these additional modules to deepen their knowledge in the field.\nCore modules are of course drawn from the three pillars of the RSE and can be categorised accordingly.\n\n\n\nFoundational module\nIntroduction to programming: Emphasising use cases over programming paradigms, students learn at least two languages:\n\nA language that facilitates prototyping and data processing e.g., Python or R\nA language for designing complex, performance-critical systems e.g., C/Cpp\nThis exposes them to computers in a hands-on fashion and is the foundation for DOCBB, DIST.\n\nComputing environment module\nProgramming languages are not enough to work in a landscape of many interconnected software components. Hence, we require something like software craftsmanship:\n\nTools: Unix shell, version control systems, build systems, documentation generators, package distribution platforms, and software discovery systems\nThis strengthens skills in DIST, DOCBB, SWREPOS, SRU.\n\nSoftware engineering module\nDevelop foundational software engineering competencies:\n\nRequirements engineering\nSoftware architecture and design\nImplementation, quality assurance, and software evolution\nEmphasising and strengthening DOCBB, DIST on a more abstract level.\n\n\n\n\n\n\nOptional domain mastery module\nAdditional minor research courses; students with a home-domain already have the research part well-covered.\nResearch tools module\nTeach tools used to distribute and publish software, and introduce domain-specific data repositories, gaining foundational knowledge in SRU, SP, DOMREP.\nMeta-research module\nTeach how research works: Introduce the research life cycle, the data life cycle, and the software life cycle abstractly.\n\n\n\n\n\nProject management methods\nTeach project management methods that are useful in science, such as agile ones PM.\nCommunication skills module\nCourses focusing on:\n\nInterdisciplinary communication\nInteracting across cultures\nCommunication in hierarchies\nSupporting end users effectively\nAll facets of the USERS skill.\n\nTeaching module\nCovers topics to effectively design courses and teaching material for various digital tools, strengthening the TEACH skill."
  },
  {
    "objectID": "general/ideas.html#hands-on-practice",
    "href": "general/ideas.html#hands-on-practice",
    "title": "Ideas",
    "section": "",
    "text": "RSE work also involves craftsmanship skills. Hands-on practice is integral.\n\nAt least two lab projects are required within the mandatory curriculum.\nThese should be team-based and involve a question from a domain science.\nIdeally, projects cover both the candidate’s home domain and another domain.\nProjects should stem from collaborations with scientists within the institution, with RSE students taking on a consultant role.\n\nThis setup strengthens TEAM, TEACH, USERS and likely also MOD through interaction.\nTo emphasise exposure beyond their bachelor’s domain, RSEs should support their non-home-domain project with introductory courses from that discipline. This encourages adapting vocabulary and thinking—an aspect of MOD."
  },
  {
    "objectID": "general/ideas.html#optional-modules-and-specialisations",
    "href": "general/ideas.html#optional-modules-and-specialisations",
    "title": "Ideas",
    "section": "",
    "text": "To align with the specialisations listed in this paper, example optional modules include:\n\nHPC engineering / parallel programming\nNumerical mathematics / scientific computing\nWeb technologies\nData stewardship\nAI models / statistics\nCommunity management / training"
  },
  {
    "objectID": "general/ideas.html#masters-thesis",
    "href": "general/ideas.html#masters-thesis",
    "title": "Ideas",
    "section": "",
    "text": "The programme concludes with a master’s thesis that should:\n\nBe dual-supervised by an RSE project supervisor and a domain supervisor\nAnswer a relevant research question strengthening NEW using computational methods\nInclude software development as a required, gradable deliverable\n\nThe RSE supervisor ensures and grades the software craftsmanship. This ensures the effective application of RSE skills in an actual research environment."
  },
  {
    "objectID": "general/preambel_general.html#research-skills",
    "href": "general/preambel_general.html#research-skills",
    "title": "WORK IN PROGRESS THIS IS NOT THE OFFICIAL STATEMENT OF THE COMMUNITY BUT THE CURRENT VERSION",
    "section": "Research skills",
    "text": "Research skills\nImplemented in the following components:\n\nDomain Science Project\nDomain Science Wildcard Courses\nRSE Thesis"
  },
  {
    "objectID": "general/preambel_general.html#technical-skills",
    "href": "general/preambel_general.html#technical-skills",
    "title": "WORK IN PROGRESS THIS IS NOT THE OFFICIAL STATEMENT OF THE COMMUNITY BUT THE CURRENT VERSION",
    "section": "Technical skills",
    "text": "Technical skills\nImplemented in:\n\nRSE Nuts and Bolts\nData Science Foundations\nProgramming Foundations\nSoftware Engineering Foundations\nRSE Software Engineering\nScientific Computing Basics and High Performance Computing"
  },
  {
    "objectID": "general/preambel_general.html#communication-skills",
    "href": "general/preambel_general.html#communication-skills",
    "title": "WORK IN PROGRESS THIS IS NOT THE OFFICIAL STATEMENT OF THE COMMUNITY BUT THE CURRENT VERSION",
    "section": "Communication skills",
    "text": "Communication skills\nImplemented in:\n\nRSE Management\nDomain Science Project or RSE Lab Project\nRSE, Ethics & Society\nRSE Lecture Series"
  },
  {
    "objectID": "generation/generated/cs_complexitytheory.html",
    "href": "generation/generated/cs_complexitytheory.html",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "",
    "text": "This module covers advanced complexity theory.\n\n\n\nThe module includes the following topics:\n\nDeterministic, non-deterministic, probabilistic and parallel computational models\nComplexity classes; reductions\nComplexity of approximation problems\nSelection of advanced topics such as interactive proofs, derandomisation, circuit complexity, communication complexity, parametric complexity\nProperties of NP-complete sets, autoreducibility, polynomial time hierarchy\ncomplexity of probabilistic algorithms.\n\n\n\n\nStudents are able to analyse the correctness, security and complexity of processes. Students will be able to classify algorithmic problems according to their complexity. Students will be able to analyse the relationship between different complexity classes.\n\n\n\n\nEither a 90-minute written exam.\nOr a 20-30 minute oral examination.\n\nLecture: Complexity Theory\nSWS: 2 ECTS: 2\nExercise: Complexity Theory Exercise\nSWS: 2 ECTS: 4\n\n\n\n\n\n\nID\nDescription\nDisciplines\nPrerequisites\nEvidence\nAuthor\nSource\n\n\n\n\nformal_methods_1\napply formal methods in system design and software engineering.\nComputer Science\nBasic knowledge of software engineering.\nSubmit application of formal methods for a given software system.\nUniversity of Potsdam\nLink\n\n\nformal_methods_2\nAnalyse theoretical and practical problems in modelling and implementation using formal methods together with others.\nComputer Science\nBasic knowledge of formal methods.\nParticipate in self-regulated team exercises and presentations.\nUniversity of Potsdam\nLink\n\n\n\n\n\n\n\n\n\nNone\n\n\n\n\n\nKomplexitätstheorie\nSicherheit, Information und Komplexität\nKomplexitätstheorie II\n\n\n\n\n\nNone\n\n\n\n\n\nUP Computational Science Master\nRWTH Informatik Master\nJMUW Informatik Master"
  },
  {
    "objectID": "generation/generated/cs_complexitytheory.html#complexity-theory",
    "href": "generation/generated/cs_complexitytheory.html#complexity-theory",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "",
    "text": "This module covers advanced complexity theory.\n\n\n\nThe module includes the following topics:\n\nDeterministic, non-deterministic, probabilistic and parallel computational models\nComplexity classes; reductions\nComplexity of approximation problems\nSelection of advanced topics such as interactive proofs, derandomisation, circuit complexity, communication complexity, parametric complexity\nProperties of NP-complete sets, autoreducibility, polynomial time hierarchy\ncomplexity of probabilistic algorithms.\n\n\n\n\nStudents are able to analyse the correctness, security and complexity of processes. Students will be able to classify algorithmic problems according to their complexity. Students will be able to analyse the relationship between different complexity classes.\n\n\n\n\nEither a 90-minute written exam.\nOr a 20-30 minute oral examination.\n\nLecture: Complexity Theory\nSWS: 2 ECTS: 2\nExercise: Complexity Theory Exercise\nSWS: 2 ECTS: 4\n\n\n\n\n\n\nID\nDescription\nDisciplines\nPrerequisites\nEvidence\nAuthor\nSource\n\n\n\n\nformal_methods_1\napply formal methods in system design and software engineering.\nComputer Science\nBasic knowledge of software engineering.\nSubmit application of formal methods for a given software system.\nUniversity of Potsdam\nLink\n\n\nformal_methods_2\nAnalyse theoretical and practical problems in modelling and implementation using formal methods together with others.\nComputer Science\nBasic knowledge of formal methods.\nParticipate in self-regulated team exercises and presentations.\nUniversity of Potsdam\nLink\n\n\n\n\n\n\n\n\n\nNone\n\n\n\n\n\nKomplexitätstheorie\nSicherheit, Information und Komplexität\nKomplexitätstheorie II\n\n\n\n\n\nNone\n\n\n\n\n\nUP Computational Science Master\nRWTH Informatik Master\nJMUW Informatik Master"
  },
  {
    "objectID": "generation/generated/cs_curriculum.html",
    "href": "generation/generated/cs_curriculum.html",
    "title": "Track 1: Computer Science Generalist Track",
    "section": "",
    "text": "Research Paradigms and Methodology for RSEs\nScientific Computing\nMathematical Foundations of Data Science\nComputer Vision\nRSEng, Ethics & Society\nNatural Language Processing\nDeclarative Programming\nEfficient Algorithms\nCurrent Topics in Artificial Intelligence\nDistributed Systems\nRSEng Teaching\nSoftware Engineering for RSEs\nHigh-Performance Computing\nData Science\nComplexity Theory\nRSEng Nuts and Bolts\nRSEng Lecture Series\nEmbedded Systems\nMaster’s Thesis\nSecurity and Cryptography\nRSEng Lab Project\nRSEng Management\nCompulsory Elective Area\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nType\nDescription\nSWS\nSem 1\nSem 2\nSem 3\nSem 4\nExisting Courses\nNew Concept\n\n\n\n\nLecture\nRSEng Lecture Series\n2\n3\n0\n0\n0\n\nyes\n\n\nSeminar\nRSEng Nuts and Bolts\n2\n3\n0\n0\n0\n\nyes\n\n\nLecture\nRSEng Management Lecture\n2\n3\n0\n0\n0\n\nyes\n\n\nExercise\nRSEng Management Exercise\n2\n3\n0\n0\n0\n\nyes\n\n\nLecture\nStatistical Data Analysis\n4\n6\n0\n0\n0\n\nno\n\n\nExercise\nStatistical Data Analysis Exercise\n2\n3\n0\n0\n0\n\nno\n\n\nLecture\nMathematical Foundations of Data Science\n2\n2\n0\n0\n0\n\nno\n\n\nExercise\nMathematical Foundations of Data Science Exercise\n2\n4\n0\n0\n0\n\nno\n\n\nSeminar\nRSEng, Ethics & Society\n2\n0\n3\n0\n0\n\nyes\n\n\nSeminar\nResearch Paradigms and Methodology for RSEs\n2\n0\n3\n0\n0\n\nyes\n\n\nSeminar\nSoftware Engineering for RSEs\n2\n0\n3\n0\n0\n\nyes\n\n\nExercise\nSoftware Engineering Exercise for RSEs\n2\n0\n3\n0\n0\n\nyes\n\n\nany\nCompulsory Elective 1\n4\n0\n6\n0\n0\n\nno\n\n\nany\nCompulsory Elective 2\n4\n0\n6\n0\n0\n\nno\n\n\nany\nCompulsory Elective 3\n4\n0\n6\n0\n0\n\nno\n\n\nSeminar\nRSEng Teaching\n2\n0\n0\n3\n0\n\nyes\n\n\nLecture\nNatural Language Processing\n2\n0\n0\n4\n0\n\nno\n\n\nExercise\nNatural Language Processing Exercise\n2\n0\n0\n2\n0\n\nno\n\n\nLecture\nScientific Computing\n2\n0\n0\n3\n0\n\nyes\n\n\nExercise\nScientific Computing Exercise\n2\n0\n0\n3\n0\n\nyes\n\n\nLab\nRSEng Lab Project\n8\n0\n0\n12\n0\n\nyes\n\n\nLecture and Exercise\nCurrent topics in Artificial Intelligence\n4\n0\n0\n6\n0\n\nno\n\n\nThesis\nRSEng Master Thesis\n0\n0\n0\n0\n30\n\nyes\n\n\n\nTotal ECTS per semester\n\n27\n30\n33\n30\n\n\n\n\n\nTotal Curriculum ECTS: 120"
  },
  {
    "objectID": "generation/generated/cs_curriculum.html#module-descriptions-linked",
    "href": "generation/generated/cs_curriculum.html#module-descriptions-linked",
    "title": "Track 1: Computer Science Generalist Track",
    "section": "",
    "text": "Research Paradigms and Methodology for RSEs\nScientific Computing\nMathematical Foundations of Data Science\nComputer Vision\nRSEng, Ethics & Society\nNatural Language Processing\nDeclarative Programming\nEfficient Algorithms\nCurrent Topics in Artificial Intelligence\nDistributed Systems\nRSEng Teaching\nSoftware Engineering for RSEs\nHigh-Performance Computing\nData Science\nComplexity Theory\nRSEng Nuts and Bolts\nRSEng Lecture Series\nEmbedded Systems\nMaster’s Thesis\nSecurity and Cryptography\nRSEng Lab Project\nRSEng Management\nCompulsory Elective Area"
  },
  {
    "objectID": "generation/generated/cs_curriculum.html#suggested-study-plan",
    "href": "generation/generated/cs_curriculum.html#suggested-study-plan",
    "title": "Track 1: Computer Science Generalist Track",
    "section": "",
    "text": "Type\nDescription\nSWS\nSem 1\nSem 2\nSem 3\nSem 4\nExisting Courses\nNew Concept\n\n\n\n\nLecture\nRSEng Lecture Series\n2\n3\n0\n0\n0\n\nyes\n\n\nSeminar\nRSEng Nuts and Bolts\n2\n3\n0\n0\n0\n\nyes\n\n\nLecture\nRSEng Management Lecture\n2\n3\n0\n0\n0\n\nyes\n\n\nExercise\nRSEng Management Exercise\n2\n3\n0\n0\n0\n\nyes\n\n\nLecture\nStatistical Data Analysis\n4\n6\n0\n0\n0\n\nno\n\n\nExercise\nStatistical Data Analysis Exercise\n2\n3\n0\n0\n0\n\nno\n\n\nLecture\nMathematical Foundations of Data Science\n2\n2\n0\n0\n0\n\nno\n\n\nExercise\nMathematical Foundations of Data Science Exercise\n2\n4\n0\n0\n0\n\nno\n\n\nSeminar\nRSEng, Ethics & Society\n2\n0\n3\n0\n0\n\nyes\n\n\nSeminar\nResearch Paradigms and Methodology for RSEs\n2\n0\n3\n0\n0\n\nyes\n\n\nSeminar\nSoftware Engineering for RSEs\n2\n0\n3\n0\n0\n\nyes\n\n\nExercise\nSoftware Engineering Exercise for RSEs\n2\n0\n3\n0\n0\n\nyes\n\n\nany\nCompulsory Elective 1\n4\n0\n6\n0\n0\n\nno\n\n\nany\nCompulsory Elective 2\n4\n0\n6\n0\n0\n\nno\n\n\nany\nCompulsory Elective 3\n4\n0\n6\n0\n0\n\nno\n\n\nSeminar\nRSEng Teaching\n2\n0\n0\n3\n0\n\nyes\n\n\nLecture\nNatural Language Processing\n2\n0\n0\n4\n0\n\nno\n\n\nExercise\nNatural Language Processing Exercise\n2\n0\n0\n2\n0\n\nno\n\n\nLecture\nScientific Computing\n2\n0\n0\n3\n0\n\nyes\n\n\nExercise\nScientific Computing Exercise\n2\n0\n0\n3\n0\n\nyes\n\n\nLab\nRSEng Lab Project\n8\n0\n0\n12\n0\n\nyes\n\n\nLecture and Exercise\nCurrent topics in Artificial Intelligence\n4\n0\n0\n6\n0\n\nno\n\n\nThesis\nRSEng Master Thesis\n0\n0\n0\n0\n30\n\nyes\n\n\n\nTotal ECTS per semester\n\n27\n30\n33\n30\n\n\n\n\n\nTotal Curriculum ECTS: 120"
  },
  {
    "objectID": "generation/generated/cs_distributedsystems.html",
    "href": "generation/generated/cs_distributedsystems.html",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "",
    "text": "This module deals with distributed IT systems and their performance.\n\n\n\nThe module covers a selection of the following topics:\n\nReliability of distributed systems: Concepts of distributed file systems, synchronization techniques for reliable distributed applications, concepts of load balancing in high-availability clusters,\nExample: Sensor networks: Routing in sensor networks, operating systems for sensor networks, security in sensor networks,\nSecure internet protocols (IP security (IPsec), Pretty Good Privacy (PGP), Secure Socket Layer (SSL), Transport Layer Security (TLS), Secure Shell (SSH), DNS security (DNSsec)), secure IPv6 networks.\nexample: internet of things\nTraffic theory models, basic concepts of probability theory, transformation methods, stochastic processes, methodology for performance analysis of technical systems, queueing and traffic theory discrete-time and continuous-time Markov chains, analysis of Markov and non-Markov systems, application examples for performance analysis of current computer systems and networks: service quality and other characteristics\nAlgorithms in message-passing systems\nLeader election and consensus\nRouting in networks: centralized and distributed approaches\nRandomized methods for contention resolution and congestion avoidance\nContagion and Distributed Network Dynamics\n\n\n\n\nStudents - can evaluate existing distributed systems in terms of reliability and security and identify vulnerabilities. - can correctly identify reliability and security requirements when designing new distributed systems and consider them early in the development process. - have the methodological knowledge and practical skills to model technical systems using probability theory and mathematical statistics. - describe foundational problems arising in distributed systems and explain algorithmic solutions for these problems. - apply general algorithmic design principles like randomized contention resolution and congestion avoidance and to use techniques like load balancing and randomization to solve problems arising in network contexts. - model distributed systems in a formal way and to develop algorithmic solutions enabling the efficient usage of computer networks and other distributed systems\n\n\n\n\neither 120 min written exam\nor 20-30 min oral examination\n\nLecture: Distributed Systems\nSWS: 2 ECTS: 2\nExercise: Distributed Systems Exercise\nSWS: 2 ECTS: 4\n\n\n\n\n\n\nID\nDescription\nDisciplines\nPrerequisites\nEvidence\nAuthor\nSource\n\n\n\n\ndist_systems_1\nevaluate existing distributed systems in terms of reliability and security and identify vulnerabilities\nComputer Science\n\nSubmit written analysis of existing distributed systems\nUniversity of Potsdam\nLink\n\n\ndist_systems_2\nidentify reliability and security requirements when designing new distributed system and consider them early in the development process\nComputer Science\n\ndiscuss necessary requirements for a design of a distributed system\nUniversity of Potsdam\nLink\n\n\n\n\n\n\n\n\n\nNone\n\n\n\n\n\nVerteilte Systeme\nTheory of Distributed Systems\nLeistungsbewertung verteilter Systeme\n\n\n\n\n\nNone\n\n\n\n\n\nUP Computational Science Master\nRWTH Informatik Master\nJMUW Informatik Master"
  },
  {
    "objectID": "generation/generated/cs_distributedsystems.html#distributed-systems",
    "href": "generation/generated/cs_distributedsystems.html#distributed-systems",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "",
    "text": "This module deals with distributed IT systems and their performance.\n\n\n\nThe module covers a selection of the following topics:\n\nReliability of distributed systems: Concepts of distributed file systems, synchronization techniques for reliable distributed applications, concepts of load balancing in high-availability clusters,\nExample: Sensor networks: Routing in sensor networks, operating systems for sensor networks, security in sensor networks,\nSecure internet protocols (IP security (IPsec), Pretty Good Privacy (PGP), Secure Socket Layer (SSL), Transport Layer Security (TLS), Secure Shell (SSH), DNS security (DNSsec)), secure IPv6 networks.\nexample: internet of things\nTraffic theory models, basic concepts of probability theory, transformation methods, stochastic processes, methodology for performance analysis of technical systems, queueing and traffic theory discrete-time and continuous-time Markov chains, analysis of Markov and non-Markov systems, application examples for performance analysis of current computer systems and networks: service quality and other characteristics\nAlgorithms in message-passing systems\nLeader election and consensus\nRouting in networks: centralized and distributed approaches\nRandomized methods for contention resolution and congestion avoidance\nContagion and Distributed Network Dynamics\n\n\n\n\nStudents - can evaluate existing distributed systems in terms of reliability and security and identify vulnerabilities. - can correctly identify reliability and security requirements when designing new distributed systems and consider them early in the development process. - have the methodological knowledge and practical skills to model technical systems using probability theory and mathematical statistics. - describe foundational problems arising in distributed systems and explain algorithmic solutions for these problems. - apply general algorithmic design principles like randomized contention resolution and congestion avoidance and to use techniques like load balancing and randomization to solve problems arising in network contexts. - model distributed systems in a formal way and to develop algorithmic solutions enabling the efficient usage of computer networks and other distributed systems\n\n\n\n\neither 120 min written exam\nor 20-30 min oral examination\n\nLecture: Distributed Systems\nSWS: 2 ECTS: 2\nExercise: Distributed Systems Exercise\nSWS: 2 ECTS: 4\n\n\n\n\n\n\nID\nDescription\nDisciplines\nPrerequisites\nEvidence\nAuthor\nSource\n\n\n\n\ndist_systems_1\nevaluate existing distributed systems in terms of reliability and security and identify vulnerabilities\nComputer Science\n\nSubmit written analysis of existing distributed systems\nUniversity of Potsdam\nLink\n\n\ndist_systems_2\nidentify reliability and security requirements when designing new distributed system and consider them early in the development process\nComputer Science\n\ndiscuss necessary requirements for a design of a distributed system\nUniversity of Potsdam\nLink\n\n\n\n\n\n\n\n\n\nNone\n\n\n\n\n\nVerteilte Systeme\nTheory of Distributed Systems\nLeistungsbewertung verteilter Systeme\n\n\n\n\n\nNone\n\n\n\n\n\nUP Computational Science Master\nRWTH Informatik Master\nJMUW Informatik Master"
  },
  {
    "objectID": "generation/generated/cs_elective.html",
    "href": "generation/generated/cs_elective.html",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "",
    "text": "Students in the cs-track have to choose a few advanced computer science modules. These can include: - Complexity Theory - Computer Vision - Declarative Programming - Distributed Systems - Efficient Algorithms - Embedded Systems - Security and Cryptography - High Performance Computing - Software Engineering II\nContents, competences and examination methods depend on the chosen modules. Obviously, every module can be completed only once.\nany: Compulsory Elective 1\nSWS: 4 ECTS: 6\nany: Compulsory Elective 2\nSWS: 4 ECTS: 6\nany: Compulsory Elective 3\nSWS: 4 ECTS: 6"
  },
  {
    "objectID": "generation/generated/cs_elective.html#compulsory-electives",
    "href": "generation/generated/cs_elective.html#compulsory-electives",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "",
    "text": "Students in the cs-track have to choose a few advanced computer science modules. These can include: - Complexity Theory - Computer Vision - Declarative Programming - Distributed Systems - Efficient Algorithms - Embedded Systems - Security and Cryptography - High Performance Computing - Software Engineering II\nContents, competences and examination methods depend on the chosen modules. Obviously, every module can be completed only once.\nany: Compulsory Elective 1\nSWS: 4 ECTS: 6\nany: Compulsory Elective 2\nSWS: 4 ECTS: 6\nany: Compulsory Elective 3\nSWS: 4 ECTS: 6"
  },
  {
    "objectID": "generation/generated/cs_project.html",
    "href": "generation/generated/cs_project.html",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "",
    "text": "Applied Research Software Engineering in scientific institutions\nThis lab module provides students with a hands-on opportunity to apply research software engineering principles to real-world scientific problems from the MINT disciplines (Mathematics, Informatics, Natural Sciences, and Technology). Students work in teams on projects originating from active research contexts — such as simulations in physics, data analysis in chemistry, modeling in biology, or …\nLab: RSEng Lab Project\nSWS: 8 ECTS: 12\n\n\n\n\n\nID\nDescription\nDisciplines\nPrerequisites\nEvidence\nAuthor\nSource\n\n\n\n\nproject_1\n\nComputer Science\n\n\n\nLink\n\n\n\n\n\n\n\n\n\nNone\n\n\n\n\n\nSoftware-Projektpraktikum\nPraktikum\nSoftwarepraktikum\nPraktikum Software Engineering\nPraktikum\nInterdisziplinäre Projektarbeit\n\n\n\n\n\nNone\n\n\n\n\n\nJMUW Informatik Bachelor\nJMUW Informatik Master\nRWTH Informatik Bachelor\nRWTH Informatik Master\nUP Informatik/Computational Science Bachelor\nUP Computational Science Master"
  },
  {
    "objectID": "generation/generated/cs_project.html#rseng-lab-module",
    "href": "generation/generated/cs_project.html#rseng-lab-module",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "",
    "text": "Applied Research Software Engineering in scientific institutions\nThis lab module provides students with a hands-on opportunity to apply research software engineering principles to real-world scientific problems from the MINT disciplines (Mathematics, Informatics, Natural Sciences, and Technology). Students work in teams on projects originating from active research contexts — such as simulations in physics, data analysis in chemistry, modeling in biology, or …\nLab: RSEng Lab Project\nSWS: 8 ECTS: 12\n\n\n\n\n\nID\nDescription\nDisciplines\nPrerequisites\nEvidence\nAuthor\nSource\n\n\n\n\nproject_1\n\nComputer Science\n\n\n\nLink\n\n\n\n\n\n\n\n\n\nNone\n\n\n\n\n\nSoftware-Projektpraktikum\nPraktikum\nSoftwarepraktikum\nPraktikum Software Engineering\nPraktikum\nInterdisziplinäre Projektarbeit\n\n\n\n\n\nNone\n\n\n\n\n\nJMUW Informatik Bachelor\nJMUW Informatik Master\nRWTH Informatik Bachelor\nRWTH Informatik Master\nUP Informatik/Computational Science Bachelor\nUP Computational Science Master"
  },
  {
    "objectID": "generation/generated/gen_cs.html",
    "href": "generation/generated/gen_cs.html",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "",
    "text": "This module covers the basics of computer science and introduces the students from domain sciences to programming.\n\n\n\nIntroduction to computer science, basic concepts of operating systems using UNIX/Linux as an example\nFrom problem to algorithm: concept of an algorithm, design of algorithms, pseudocode, refinement, brute-force algorithms, models and modeling, graphs and their representation, simple algorithms on graphs, analysis of algorithms (correctness, termination, runtime)\nImplementation of algorithms (e.g., using Python)\nProgramming paradigms: procedural, object-oriented, and functional programming; recursion versus iteration\nFrom program to process: assembly languages, assembler, compiler, interpreter, syntax and semantics of programming languages\nLimits of algorithms: computability, decidability, undecidability\n\nLecture: Fundamentals of Computer Science\nSWS: 2 ECTS: 2\nExercise: Fundamentals of Computer Science Exercise\nSWS: 2 ECTS: 4\n\n\n\n\n\n\nID\nDescription\nDisciplines\nPrerequisites\nEvidence\nAuthor\nSource\n\n\n\n\nex_programming_mod1_1\nUse an imperative-procedural programming language (e.g., C) and an object-oriented language (e.g., Java) with confidence\nComputer Science\n\nSubmit working programs in both languages demonstrating syntax and language-specific features\nUniversity of Potsdam\nLink\n\n\nex_programming_mod1_2\nImplement basic data structures and algorithms\nComputer Science\nex_programming_mod1_1\nSubmit a project with implemented algorithms and data structures (e.g., lists, trees, sorting)\nUniversity of Potsdam\nLink\n\n\nex_programming_mod1_3\nDistinguish between error types and handle them appropriately in code\nComputer Science\nex_programming_mod1_1\nDemonstrate error handling techniques in submitted code (e.g., input validation, error codes, exceptions)\nUniversity of Potsdam\nLink\n\n\nex_programming_mod1_4\nIdentify and use appropriate library functions in programming tasks\nComputer Science\nex_programming_mod1_1\nIntegrate external libraries in coding tasks and document their usage\nUniversity of Potsdam\nLink\n\n\nex_programming_mod1_5\nUse basic functions and mechanisms of operating systems using UNIX/Linux as an example\nComputer Science\n\nDemonstrate file handling, permissions, and process control using UNIX/Linux commands\nUniversity of Potsdam\nLink\n\n\nex_programming_mod1_6\nCreate and refine simple algorithms using semi-formal notation\nComputer Science\n\nSubmit pseudocode or flowcharts for given algorithmic problems\nUniversity of Potsdam\nLink\n\n\nex_programming_mod1_7\nEvaluate and compare algorithms using runtime analysis\nComputer Science\nex_programming_mod1_6\nProvide time complexity comparisons for multiple algorithmic solutions\nUniversity of Potsdam\nLink\n\n\nex_programming_mod1_8\nImplement simple algorithms using imperative and functional programming styles (e.g., in Python)\nComputer Science\nex_programming_mod1_6\nSubmit code demonstrating both imperative and functional styles for the same problem\nUniversity of Potsdam\nLink\n\n\nex_programming_mod1_9\nDistinguish between programming paradigms and identify their characteristics\nComputer Science\nex_programming_mod1_1\nClassify given code snippets by paradigm and justify the classification\nUniversity of Potsdam\nLink\n\n\nC10\nExpress simple programs in an assembly language\nComputer Science\n\nTranslate simple high-level logic into assembler code\nUniversity of Potsdam\nLink\n\n\nC11\nDiscuss the limits of algorithms, including computability and decidability\nComputer Science\n\nWrite a short essay or present on concepts such as the Halting Problem or undecidability\nUniversity of Potsdam\nLink\n\n\n\n\n\n\n\n\n\nComputing Curricula 2020\n\n\n\n\n\nGrundlagen der Programmierung\nPython for Psychologists\nGrundlagen der Informatik\nGrundlagen der Programmierung\nProgrammierung\nProgrammierung 1\n\n\n\n\n\nUP Informatik/Computational Science Bachelor\nJMUW Informatik Bachelor\nRWTH Informatik Bachelor\nUdS Informatik Bachelor"
  },
  {
    "objectID": "generation/generated/gen_cs.html#fundamentals-of-computer-science",
    "href": "generation/generated/gen_cs.html#fundamentals-of-computer-science",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "",
    "text": "This module covers the basics of computer science and introduces the students from domain sciences to programming.\n\n\n\nIntroduction to computer science, basic concepts of operating systems using UNIX/Linux as an example\nFrom problem to algorithm: concept of an algorithm, design of algorithms, pseudocode, refinement, brute-force algorithms, models and modeling, graphs and their representation, simple algorithms on graphs, analysis of algorithms (correctness, termination, runtime)\nImplementation of algorithms (e.g., using Python)\nProgramming paradigms: procedural, object-oriented, and functional programming; recursion versus iteration\nFrom program to process: assembly languages, assembler, compiler, interpreter, syntax and semantics of programming languages\nLimits of algorithms: computability, decidability, undecidability\n\nLecture: Fundamentals of Computer Science\nSWS: 2 ECTS: 2\nExercise: Fundamentals of Computer Science Exercise\nSWS: 2 ECTS: 4\n\n\n\n\n\n\nID\nDescription\nDisciplines\nPrerequisites\nEvidence\nAuthor\nSource\n\n\n\n\nex_programming_mod1_1\nUse an imperative-procedural programming language (e.g., C) and an object-oriented language (e.g., Java) with confidence\nComputer Science\n\nSubmit working programs in both languages demonstrating syntax and language-specific features\nUniversity of Potsdam\nLink\n\n\nex_programming_mod1_2\nImplement basic data structures and algorithms\nComputer Science\nex_programming_mod1_1\nSubmit a project with implemented algorithms and data structures (e.g., lists, trees, sorting)\nUniversity of Potsdam\nLink\n\n\nex_programming_mod1_3\nDistinguish between error types and handle them appropriately in code\nComputer Science\nex_programming_mod1_1\nDemonstrate error handling techniques in submitted code (e.g., input validation, error codes, exceptions)\nUniversity of Potsdam\nLink\n\n\nex_programming_mod1_4\nIdentify and use appropriate library functions in programming tasks\nComputer Science\nex_programming_mod1_1\nIntegrate external libraries in coding tasks and document their usage\nUniversity of Potsdam\nLink\n\n\nex_programming_mod1_5\nUse basic functions and mechanisms of operating systems using UNIX/Linux as an example\nComputer Science\n\nDemonstrate file handling, permissions, and process control using UNIX/Linux commands\nUniversity of Potsdam\nLink\n\n\nex_programming_mod1_6\nCreate and refine simple algorithms using semi-formal notation\nComputer Science\n\nSubmit pseudocode or flowcharts for given algorithmic problems\nUniversity of Potsdam\nLink\n\n\nex_programming_mod1_7\nEvaluate and compare algorithms using runtime analysis\nComputer Science\nex_programming_mod1_6\nProvide time complexity comparisons for multiple algorithmic solutions\nUniversity of Potsdam\nLink\n\n\nex_programming_mod1_8\nImplement simple algorithms using imperative and functional programming styles (e.g., in Python)\nComputer Science\nex_programming_mod1_6\nSubmit code demonstrating both imperative and functional styles for the same problem\nUniversity of Potsdam\nLink\n\n\nex_programming_mod1_9\nDistinguish between programming paradigms and identify their characteristics\nComputer Science\nex_programming_mod1_1\nClassify given code snippets by paradigm and justify the classification\nUniversity of Potsdam\nLink\n\n\nC10\nExpress simple programs in an assembly language\nComputer Science\n\nTranslate simple high-level logic into assembler code\nUniversity of Potsdam\nLink\n\n\nC11\nDiscuss the limits of algorithms, including computability and decidability\nComputer Science\n\nWrite a short essay or present on concepts such as the Halting Problem or undecidability\nUniversity of Potsdam\nLink\n\n\n\n\n\n\n\n\n\nComputing Curricula 2020\n\n\n\n\n\nGrundlagen der Programmierung\nPython for Psychologists\nGrundlagen der Informatik\nGrundlagen der Programmierung\nProgrammierung\nProgrammierung 1\n\n\n\n\n\nUP Informatik/Computational Science Bachelor\nJMUW Informatik Bachelor\nRWTH Informatik Bachelor\nUdS Informatik Bachelor"
  },
  {
    "objectID": "generation/generated/gen_datascience.html",
    "href": "generation/generated/gen_datascience.html",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "",
    "text": "This module introduces the students to statistical data analysis.\n\n\nThis module focuses on the statistical study and quantitative analysis of the dependence between observed random variables (e.g., yield/production settings; lifespan/treatment type and injury type). Essential foundations for the statistical treatment of such relationships are provided by the linear regression model, which is studied in detail in the first part of the lecture. Within this framework, topics such as estimation, testing, and uncertainty quantification (analysis of variance) are addressed. In the second part, an introduction to advanced methods and approaches for examining relationships is offered, including nonlinear and nonparametric regression models. Additionally, questions of classification and dimensionality reduction are covered.\n\n\n\nStudents will acquire a comprehensive, detailed and specialised understanding of the linear regression model based on the latest findings. They will learn basic concepts and methods of non-parametric statistics. They will also be able to solve complex statistical data analysis problems, weigh up alternative modelling approaches and evaluate them according to different criteria. They will be able to use functions from statistical software packages for this purpose.\n\n\n\nexam (120-180 minutes) or oral exam (30 minutes)\nLecture: Statistical Data Analysis\nSWS: 4 ECTS: 6\nExercise: Statistical Data Analysis Exercise\nSWS: 2 ECTS: 3\n\n\n\n\n\n\nID\nDescription\nDisciplines\nPrerequisites\nEvidence\nAuthor\nSource\n\n\n\n\ngen_datascience_1\nPossess comprehensive, detailed, and specialized knowledge of selected fundamentals in the field of Data Science\nData Science\n\nDemonstrate knowledge through theoretical exams and practical assignments\nUniversity of Potsdam\nLink\n\n\ngen_datascience_2\nDemonstrate an in-depth understanding of selected Data Science methods\nData Science\ngen_datascience_1\nApply Data Science methods in practical projects and case studies\nUniversity of Potsdam\nLink\n\n\ngen_datascience_3\nAnalyze novel data assimilation and inference problems, develop and implement solutions, and assess solution quality\nData Science\ngen_datascience_2\nSolve complex inference problems and present implemented solutions with evaluation\nUniversity of Potsdam\nLink\n\n\ngen_datascience_4\nDevelop new ideas and methods, weigh alternatives under incomplete information, and evaluate them considering different evaluation criteria\nData Science\ngen_datascience_2\nPresent projects showcasing creative problem-solving and alternative evaluations under uncertainty\nUniversity of Potsdam\nLink\n\n\ngen_statistics_1\nPossess comprehensive, detailed, and specialized understanding of the linear regression model based on the latest research\nData Science, Statistics\n\nApply linear regression models to practical problems and interpret results\nUniversity of Potsdam\nLink\n\n\ngen_statistics_2\nUnderstand fundamental concepts and methods of nonparametric statistics\nData Science, Statistics\ngen_statistics_1\nSolve problems involving nonparametric methods and explain applied techniques\nUniversity of Potsdam\nLink\n\n\ngen_statistics_3\nSolve complex statistical data analysis problems, evaluate alternative modeling approaches according to various criteria, and use statistical software packages for analysis\nData Science, Statistics\ngen_statistics_2\nDevelop solutions for complex data problems using appropriate statistical methods and software\nUniversity of Potsdam\nLink\n\n\ngen_statistics_4\nDemonstrate academic competences including self-organization, planning skills (identifying work steps), scientific thinking and working techniques (developing solutions for complex questions), discussion of methods, verification of hypotheses, application of mathematical and statistical methods, and use of software packages\nData Science, Statistics\ngen_statistics_2\nDocument project workflows demonstrating planning, analysis, evaluation, and use of statistical software tools\nUniversity of Potsdam\nLink\n\n\n\n\n\n\n\n\n\nEmpfehlungen Masterstudiengänge Data Science\n\n\n\n\n\nData Exploration and Visualisation\nSoftware and tools\nData Processing with R\nData Processing with Python (Pandas)\nPlotting in Python with Matplotlib\nStatistical Data Analysis (MATVMD837)\nProgrammieren für Data Scientists Python\nElements of Machine Learning and Data Science\nIntroduction to Data Science\nData Science\n\n\n\n\n\nUP Data Science Master\nJMUW Informatik Bachelor\nJMUW Informatik Master\nRWTH Informatik Bachelor\nRWTH Data Science Master"
  },
  {
    "objectID": "generation/generated/gen_datascience.html#statistical-data-analysis",
    "href": "generation/generated/gen_datascience.html#statistical-data-analysis",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "",
    "text": "This module introduces the students to statistical data analysis.\n\n\nThis module focuses on the statistical study and quantitative analysis of the dependence between observed random variables (e.g., yield/production settings; lifespan/treatment type and injury type). Essential foundations for the statistical treatment of such relationships are provided by the linear regression model, which is studied in detail in the first part of the lecture. Within this framework, topics such as estimation, testing, and uncertainty quantification (analysis of variance) are addressed. In the second part, an introduction to advanced methods and approaches for examining relationships is offered, including nonlinear and nonparametric regression models. Additionally, questions of classification and dimensionality reduction are covered.\n\n\n\nStudents will acquire a comprehensive, detailed and specialised understanding of the linear regression model based on the latest findings. They will learn basic concepts and methods of non-parametric statistics. They will also be able to solve complex statistical data analysis problems, weigh up alternative modelling approaches and evaluate them according to different criteria. They will be able to use functions from statistical software packages for this purpose.\n\n\n\nexam (120-180 minutes) or oral exam (30 minutes)\nLecture: Statistical Data Analysis\nSWS: 4 ECTS: 6\nExercise: Statistical Data Analysis Exercise\nSWS: 2 ECTS: 3\n\n\n\n\n\n\nID\nDescription\nDisciplines\nPrerequisites\nEvidence\nAuthor\nSource\n\n\n\n\ngen_datascience_1\nPossess comprehensive, detailed, and specialized knowledge of selected fundamentals in the field of Data Science\nData Science\n\nDemonstrate knowledge through theoretical exams and practical assignments\nUniversity of Potsdam\nLink\n\n\ngen_datascience_2\nDemonstrate an in-depth understanding of selected Data Science methods\nData Science\ngen_datascience_1\nApply Data Science methods in practical projects and case studies\nUniversity of Potsdam\nLink\n\n\ngen_datascience_3\nAnalyze novel data assimilation and inference problems, develop and implement solutions, and assess solution quality\nData Science\ngen_datascience_2\nSolve complex inference problems and present implemented solutions with evaluation\nUniversity of Potsdam\nLink\n\n\ngen_datascience_4\nDevelop new ideas and methods, weigh alternatives under incomplete information, and evaluate them considering different evaluation criteria\nData Science\ngen_datascience_2\nPresent projects showcasing creative problem-solving and alternative evaluations under uncertainty\nUniversity of Potsdam\nLink\n\n\ngen_statistics_1\nPossess comprehensive, detailed, and specialized understanding of the linear regression model based on the latest research\nData Science, Statistics\n\nApply linear regression models to practical problems and interpret results\nUniversity of Potsdam\nLink\n\n\ngen_statistics_2\nUnderstand fundamental concepts and methods of nonparametric statistics\nData Science, Statistics\ngen_statistics_1\nSolve problems involving nonparametric methods and explain applied techniques\nUniversity of Potsdam\nLink\n\n\ngen_statistics_3\nSolve complex statistical data analysis problems, evaluate alternative modeling approaches according to various criteria, and use statistical software packages for analysis\nData Science, Statistics\ngen_statistics_2\nDevelop solutions for complex data problems using appropriate statistical methods and software\nUniversity of Potsdam\nLink\n\n\ngen_statistics_4\nDemonstrate academic competences including self-organization, planning skills (identifying work steps), scientific thinking and working techniques (developing solutions for complex questions), discussion of methods, verification of hypotheses, application of mathematical and statistical methods, and use of software packages\nData Science, Statistics\ngen_statistics_2\nDocument project workflows demonstrating planning, analysis, evaluation, and use of statistical software tools\nUniversity of Potsdam\nLink\n\n\n\n\n\n\n\n\n\nEmpfehlungen Masterstudiengänge Data Science\n\n\n\n\n\nData Exploration and Visualisation\nSoftware and tools\nData Processing with R\nData Processing with Python (Pandas)\nPlotting in Python with Matplotlib\nStatistical Data Analysis (MATVMD837)\nProgrammieren für Data Scientists Python\nElements of Machine Learning and Data Science\nIntroduction to Data Science\nData Science\n\n\n\n\n\nUP Data Science Master\nJMUW Informatik Bachelor\nJMUW Informatik Master\nRWTH Informatik Bachelor\nRWTH Data Science Master"
  },
  {
    "objectID": "generation/generated/gen_programming.html",
    "href": "generation/generated/gen_programming.html",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "",
    "text": "This module builds on the basics of computer science and introduces the students to more advanced programming concepts like programming paradigms, algorithms and data structures.\n\n\nProgramming with an imperative-procedural language (such as C):\n\nData types, type casting, control structures, functions and procedures, parameter passing paradigms, call stack\nPointers, arrays, strings, structured types\nErrors and their handling\nDynamic memory management\nProgram libraries\n\n\n\n\n\nClasses, objects, constructors\nInheritance, polymorphism, abstract classes/interfaces\nExceptions and exception handling\nNamespaces (packages)\nGeneric classes and types\nProgram libraries\n\nLecture: Basic Programming\nSWS: 2 ECTS: 2\nExercise: Basic Programming Exercise\nSWS: 2 ECTS: 4\nLecture: Applied Programming\nSWS: 2 ECTS: 2\nExercise: Applied Programming Exercise\nSWS: 2 ECTS: 4\n\n\n\n\n\n\nComputing Curricula 2020\n\n\n\n\n\nPraxis der Programmierung\nAlgorithmen und Datenstrukturen\nPython for Psychologists\nFortgeschrittenes Programmieren\nAlgorithmen und Datenstrukturen\nAdvanced Programming\nProgrammierung 2\n\n\n\n\n\nUP Informatik/Computational Science Bachelor\nJMUW Informatik Bachelor\nJMUW Informatik Master\nRWTH Informatik Bachelor\nUdS Informatik Bachelor"
  },
  {
    "objectID": "generation/generated/gen_programming.html#applied-programming",
    "href": "generation/generated/gen_programming.html#applied-programming",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "",
    "text": "This module builds on the basics of computer science and introduces the students to more advanced programming concepts like programming paradigms, algorithms and data structures.\n\n\nProgramming with an imperative-procedural language (such as C):\n\nData types, type casting, control structures, functions and procedures, parameter passing paradigms, call stack\nPointers, arrays, strings, structured types\nErrors and their handling\nDynamic memory management\nProgram libraries\n\n\n\n\n\nClasses, objects, constructors\nInheritance, polymorphism, abstract classes/interfaces\nExceptions and exception handling\nNamespaces (packages)\nGeneric classes and types\nProgram libraries\n\nLecture: Basic Programming\nSWS: 2 ECTS: 2\nExercise: Basic Programming Exercise\nSWS: 2 ECTS: 4\nLecture: Applied Programming\nSWS: 2 ECTS: 2\nExercise: Applied Programming Exercise\nSWS: 2 ECTS: 4\n\n\n\n\n\n\nComputing Curricula 2020\n\n\n\n\n\nPraxis der Programmierung\nAlgorithmen und Datenstrukturen\nPython for Psychologists\nFortgeschrittenes Programmieren\nAlgorithmen und Datenstrukturen\nAdvanced Programming\nProgrammierung 2\n\n\n\n\n\nUP Informatik/Computational Science Bachelor\nJMUW Informatik Bachelor\nJMUW Informatik Master\nRWTH Informatik Bachelor\nUdS Informatik Bachelor"
  },
  {
    "objectID": "generation/generated/gen_softwareeng2.html",
    "href": "generation/generated/gen_softwareeng2.html",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "",
    "text": "The module covers a selection of advanced topics in the field of software engineering, for example in the areas of software quality assurance, service engineering, virtualisation, programming languages and design, and formal methods in system design. It builds on knowledge and competencies from Software Engineering I.\n\n\nStudents - have an in-depth understanding of and the ability to use various approaches to software engineering - are familiar with the characteristics of numerous technologies and tools for specification, component-based development and quality assurance of modern software systems, as well as their application in various contexts.\n\n\n\n\nwritten exam (100 min)\nexercise sheets or group project\n\nLecture: Software Engineering II\nSWS: 2 ECTS: 4\nExercise: Software Engineering II Exercise\nSWS: 2 ECTS: 2\n\n\n\n\n\n\nSoftware Engineering II\n\n\n\n\n\nUP Informatik/Computational Science Bachelor"
  },
  {
    "objectID": "generation/generated/gen_softwareeng2.html#classical-software-engineering-ii",
    "href": "generation/generated/gen_softwareeng2.html#classical-software-engineering-ii",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "",
    "text": "The module covers a selection of advanced topics in the field of software engineering, for example in the areas of software quality assurance, service engineering, virtualisation, programming languages and design, and formal methods in system design. It builds on knowledge and competencies from Software Engineering I.\n\n\nStudents - have an in-depth understanding of and the ability to use various approaches to software engineering - are familiar with the characteristics of numerous technologies and tools for specification, component-based development and quality assurance of modern software systems, as well as their application in various contexts.\n\n\n\n\nwritten exam (100 min)\nexercise sheets or group project\n\nLecture: Software Engineering II\nSWS: 2 ECTS: 4\nExercise: Software Engineering II Exercise\nSWS: 2 ECTS: 2\n\n\n\n\n\n\nSoftware Engineering II\n\n\n\n\n\nUP Informatik/Computational Science Bachelor"
  },
  {
    "objectID": "generation/generated/mnt_curriculum.html",
    "href": "generation/generated/mnt_curriculum.html",
    "title": "Track 2: Domain Science / Natural Science Track",
    "section": "",
    "text": "Software Engineering\nComputational Science Wildcard\nResearch Paradigms and Methodology for RSEs\nScience Lab\nScientific Computing\nMathematical Foundations of Data Science\nNatural Language Processing\nApplied Programming\nSoftware Engineering II\nScience Wildcard\nRSEng Teaching\nSoftware Engineering for RSEs\nHigh-Performance Computing\nData Science\nRSEng Nuts and Bolts\nRSEng Lecture Series\nMaster’s Thesis\nRSEng Management\nFundamentals of Computer Science\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nType\nDescription\nSWS\nSem 1\nSem 2\nSem 3\nSem 4\nExisting Courses\nNew Concept\n\n\n\n\nLecture\nRSEng Lecture Series\n2\n3\n0\n0\n0\n\nyes\n\n\nSeminar\nRSEng Nuts and Bolts\n2\n3\n0\n0\n0\n\nyes\n\n\nLecture\nStatistical Data Analysis\n4\n6\n0\n0\n0\n\nno\n\n\nExercise\nStatistical Data Analysis Exercise\n2\n3\n0\n0\n0\n\nno\n\n\nLecture\nFundamentals of Computer Science\n2\n2\n0\n0\n0\n\nno\n\n\nExercise\nFundamentals of Computer Science Exercise\n2\n4\n0\n0\n0\n\nno\n\n\nLecture\nSoftware Engineering I\n2\n4\n0\n0\n0\n\nno\n\n\nExercise\nSoftware Engineering I Exercise\n2\n2\n0\n0\n0\n\nno\n\n\nLecture\nWildcard Science I\n2\n2\n0\n0\n0\n\nno\n\n\nSeminar\nRSEng, Ethics & Society\n2\n0\n3\n0\n0\n\nyes\n\n\nSeminar\nResearch Paradigms and Methodology for RSEs\n2\n0\n3\n0\n0\n\nyes\n\n\nLab\nWildcard Science Lab I\n2\n0\n4\n0\n0\n\nno\n\n\nLecture\nWildcard Science II\n2\n0\n2\n0\n0\n\nno\n\n\nLecture\nComputational Wildcard Science\n2\n0\n3\n0\n0\n\nno\n\n\nLab\nComputational Wildcard Science Lab\n2\n0\n3\n0\n0\n\nno\n\n\nSeminar\nSoftware Engineering for RSEs\n2\n0\n3\n0\n0\n\nyes\n\n\nExercise\nSoftware Engineering Exercise for RSEs\n2\n0\n3\n0\n0\n\nyes\n\n\nLecture\nApplied Programming\n2\n0\n2\n0\n0\n\nno\n\n\nExercise\nApplied Programming Exercise\n2\n0\n4\n0\n0\n\nno\n\n\nLab\nWildcard Science Lab II\n2\n0\n0\n4\n0\n\nno\n\n\nSeminar\nRSEng Teaching\n2\n0\n0\n3\n0\n\nyes\n\n\nLecture\nRSEng Management Lecture\n2\n0\n0\n3\n0\n\nyes\n\n\nExercise\nRSEng Management Exercise\n2\n0\n0\n3\n0\n\nyes\n\n\nLecture\nNatural Language Processing\n2\n0\n0\n4\n0\n\nno\n\n\nExercise\nNatural Language Processing Exercise\n2\n0\n0\n2\n0\n\nno\n\n\nLecture\nScientific Computing\n2\n0\n0\n3\n0\n\nyes\n\n\nExercise\nScientific Computing Exercise\n2\n0\n0\n3\n0\n\nyes\n\n\nLab\nScience Lab Project\n4\n0\n0\n6\n0\n\nno\n\n\nThesis\nRSEng Master Thesis\n0\n0\n0\n0\n30\n\nyes\n\n\n\nTotal ECTS per semester\n\n29\n30\n31\n30\n\n\n\n\n\nTotal Curriculum ECTS: 120"
  },
  {
    "objectID": "generation/generated/mnt_curriculum.html#module-descriptions-linked",
    "href": "generation/generated/mnt_curriculum.html#module-descriptions-linked",
    "title": "Track 2: Domain Science / Natural Science Track",
    "section": "",
    "text": "Software Engineering\nComputational Science Wildcard\nResearch Paradigms and Methodology for RSEs\nScience Lab\nScientific Computing\nMathematical Foundations of Data Science\nNatural Language Processing\nApplied Programming\nSoftware Engineering II\nScience Wildcard\nRSEng Teaching\nSoftware Engineering for RSEs\nHigh-Performance Computing\nData Science\nRSEng Nuts and Bolts\nRSEng Lecture Series\nMaster’s Thesis\nRSEng Management\nFundamentals of Computer Science"
  },
  {
    "objectID": "generation/generated/mnt_curriculum.html#suggested-study-plan",
    "href": "generation/generated/mnt_curriculum.html#suggested-study-plan",
    "title": "Track 2: Domain Science / Natural Science Track",
    "section": "",
    "text": "Type\nDescription\nSWS\nSem 1\nSem 2\nSem 3\nSem 4\nExisting Courses\nNew Concept\n\n\n\n\nLecture\nRSEng Lecture Series\n2\n3\n0\n0\n0\n\nyes\n\n\nSeminar\nRSEng Nuts and Bolts\n2\n3\n0\n0\n0\n\nyes\n\n\nLecture\nStatistical Data Analysis\n4\n6\n0\n0\n0\n\nno\n\n\nExercise\nStatistical Data Analysis Exercise\n2\n3\n0\n0\n0\n\nno\n\n\nLecture\nFundamentals of Computer Science\n2\n2\n0\n0\n0\n\nno\n\n\nExercise\nFundamentals of Computer Science Exercise\n2\n4\n0\n0\n0\n\nno\n\n\nLecture\nSoftware Engineering I\n2\n4\n0\n0\n0\n\nno\n\n\nExercise\nSoftware Engineering I Exercise\n2\n2\n0\n0\n0\n\nno\n\n\nLecture\nWildcard Science I\n2\n2\n0\n0\n0\n\nno\n\n\nSeminar\nRSEng, Ethics & Society\n2\n0\n3\n0\n0\n\nyes\n\n\nSeminar\nResearch Paradigms and Methodology for RSEs\n2\n0\n3\n0\n0\n\nyes\n\n\nLab\nWildcard Science Lab I\n2\n0\n4\n0\n0\n\nno\n\n\nLecture\nWildcard Science II\n2\n0\n2\n0\n0\n\nno\n\n\nLecture\nComputational Wildcard Science\n2\n0\n3\n0\n0\n\nno\n\n\nLab\nComputational Wildcard Science Lab\n2\n0\n3\n0\n0\n\nno\n\n\nSeminar\nSoftware Engineering for RSEs\n2\n0\n3\n0\n0\n\nyes\n\n\nExercise\nSoftware Engineering Exercise for RSEs\n2\n0\n3\n0\n0\n\nyes\n\n\nLecture\nApplied Programming\n2\n0\n2\n0\n0\n\nno\n\n\nExercise\nApplied Programming Exercise\n2\n0\n4\n0\n0\n\nno\n\n\nLab\nWildcard Science Lab II\n2\n0\n0\n4\n0\n\nno\n\n\nSeminar\nRSEng Teaching\n2\n0\n0\n3\n0\n\nyes\n\n\nLecture\nRSEng Management Lecture\n2\n0\n0\n3\n0\n\nyes\n\n\nExercise\nRSEng Management Exercise\n2\n0\n0\n3\n0\n\nyes\n\n\nLecture\nNatural Language Processing\n2\n0\n0\n4\n0\n\nno\n\n\nExercise\nNatural Language Processing Exercise\n2\n0\n0\n2\n0\n\nno\n\n\nLecture\nScientific Computing\n2\n0\n0\n3\n0\n\nyes\n\n\nExercise\nScientific Computing Exercise\n2\n0\n0\n3\n0\n\nyes\n\n\nLab\nScience Lab Project\n4\n0\n0\n6\n0\n\nno\n\n\nThesis\nRSEng Master Thesis\n0\n0\n0\n0\n30\n\nyes\n\n\n\nTotal ECTS per semester\n\n29\n30\n31\n30\n\n\n\n\n\nTotal Curriculum ECTS: 120"
  },
  {
    "objectID": "generation/generated/mnt_wildcard.html",
    "href": "generation/generated/mnt_wildcard.html",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "",
    "text": "This module offers RSE students the opportunity to deepen their understanding of a scientific discipline outside of their home domain. Students choose a science module — such as physics, chemistry, biology, or earth sciences — and engage with its research practices, core questions, and data/software challenges.\nThe goal is to help students become better collaborators by gaining first-hand exposure to the terminology, logic, and needs of another scientific domain. This broadens the student’s ability to apply RSE skills in interdisciplinary teams and unfamiliar environments.\nThe module may consist of lectures, lab sessions, and domain-specific mini-projects. RSEs are encouraged to reflect on how software engineering, data handling, reproducibility, and tooling intersect with the chosen discipline.\nThis module is deliberately flexible to accommodate institutional offerings and student interests as well as providing the option to stay attached to the identity of the chosen discipline.\nLecture: Wildcard Science I\nSWS: 2 ECTS: 2\nLecture: Wildcard Science II\nSWS: 2 ECTS: 2\nLab: Wildcard Science Lab I\nSWS: 2 ECTS: 4\nLab: Wildcard Science Lab II\nSWS: 2 ECTS: 4\n\n\n\n\n\nID\nDescription\nDisciplines\nPrerequisites\nEvidence\nAuthor\nSource\n\n\n\n\nNone\n\nWildcard Domain Science\n\n\n\nLink\n\n\n\n\n\n\n\n\n\nJMUW Master Physik\nJMUW Master Chemie"
  },
  {
    "objectID": "generation/generated/mnt_wildcard.html#wildcard-science-module",
    "href": "generation/generated/mnt_wildcard.html#wildcard-science-module",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "",
    "text": "This module offers RSE students the opportunity to deepen their understanding of a scientific discipline outside of their home domain. Students choose a science module — such as physics, chemistry, biology, or earth sciences — and engage with its research practices, core questions, and data/software challenges.\nThe goal is to help students become better collaborators by gaining first-hand exposure to the terminology, logic, and needs of another scientific domain. This broadens the student’s ability to apply RSE skills in interdisciplinary teams and unfamiliar environments.\nThe module may consist of lectures, lab sessions, and domain-specific mini-projects. RSEs are encouraged to reflect on how software engineering, data handling, reproducibility, and tooling intersect with the chosen discipline.\nThis module is deliberately flexible to accommodate institutional offerings and student interests as well as providing the option to stay attached to the identity of the chosen discipline.\nLecture: Wildcard Science I\nSWS: 2 ECTS: 2\nLecture: Wildcard Science II\nSWS: 2 ECTS: 2\nLab: Wildcard Science Lab I\nSWS: 2 ECTS: 4\nLab: Wildcard Science Lab II\nSWS: 2 ECTS: 4\n\n\n\n\n\nID\nDescription\nDisciplines\nPrerequisites\nEvidence\nAuthor\nSource\n\n\n\n\nNone\n\nWildcard Domain Science\n\n\n\nLink\n\n\n\n\n\n\n\n\n\nJMUW Master Physik\nJMUW Master Chemie"
  },
  {
    "objectID": "generation/generated/rse_lectureseries.html",
    "href": "generation/generated/rse_lectureseries.html",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "",
    "text": "This lecture series covers current RSEng research and provides room for guest lectures and varying focus topics.\n\n\n\nvary between semesters and weeks, but are all related to RSEng\n\n\n\n\nstudents get a broad image of RSEng in the wild\n\n\n\n\nnone?\nLecture: RSEng Lecture Series\nSWS: 2 ECTS: 3\n\n\n\n\n\n\nID\nDescription\nDisciplines\nPrerequisites\nEvidence\nAuthor\nSource\n\n\n\n\nrse_0\ndescribe RSE activities\nComputer Science\n\nname x different fields and analyse their differences\n\nLink\n\n\n\n\n\n\n\n\n\nNone\n\n\n\n\n\nLecture Series on Research Methods\n\n\n\n\n\nNone\n\n\n\n\n\nNone"
  },
  {
    "objectID": "generation/generated/rse_lectureseries.html#rseng-lecture-series",
    "href": "generation/generated/rse_lectureseries.html#rseng-lecture-series",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "",
    "text": "This lecture series covers current RSEng research and provides room for guest lectures and varying focus topics.\n\n\n\nvary between semesters and weeks, but are all related to RSEng\n\n\n\n\nstudents get a broad image of RSEng in the wild\n\n\n\n\nnone?\nLecture: RSEng Lecture Series\nSWS: 2 ECTS: 3\n\n\n\n\n\n\nID\nDescription\nDisciplines\nPrerequisites\nEvidence\nAuthor\nSource\n\n\n\n\nrse_0\ndescribe RSE activities\nComputer Science\n\nname x different fields and analyse their differences\n\nLink\n\n\n\n\n\n\n\n\n\nNone\n\n\n\n\n\nLecture Series on Research Methods\n\n\n\n\n\nNone\n\n\n\n\n\nNone"
  },
  {
    "objectID": "generation/generated/rse_nuts_bolts.html",
    "href": "generation/generated/rse_nuts_bolts.html",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "",
    "text": "This module, inspired by the MIT Missing Semester, addresses the “nuts and bolts” often missing from traditional academic training in computing. It aims to provide students with practical skills and conceptual understanding for building robust, maintainable, and reproducible research software—key competencies in Research Software Engineering (RSEng).\n\n\n\nThe module begins with general-purpose computing tools and techniques that are foundational for any research software engineer:\n\nShell tools and scripting\nCommand-line environments\nEditors and IDEs (e.g., Vim)\nVersion control (Git)\nData wrangling\nDebugging and profiling\nMetaprogramming\nSecurity and cryptography\n\n\n\n\nBuilding on these foundations, the module introduces RSE-specific concepts and good practices:\n\nVersion control and collaboration\n\nGit for code history, collaboration, and issue tracking\n\nVirtualization concepts\n\nContainerization and environment management\n\nThe Data Life Cycle\n\nManaging research data and understanding data provenance\n\nGood coding practices\n\nReproducible and testable code\nMeaningful documentation and error messages\nModular software design\nPerformance-conscious coding\nEasily installable and distributable software\nCoding standards, formatting, and linting\n\nSoftware management planning\n\nWriting Data and Software Management Plans\nSustainable development and community involvement\n\nLow-level programming\n\nIntroduction to a compiled language (e.g., C) to expose hardware-level concerns and efficient memory management\n\nLong-term software maintenance\n\nVersion tracking, bug management, and sustainability strategies\nBuilding and maintaining research software communities\n\n\n\n\n\nFinally, the module touches on practices that support the scholarly nature of research software:\n\nSoftware publication and citation (see SP in (Goth et al. 2024))\nUse of domain-specific repositories and registries (see DOMREP in (Goth et al. 2024))\n\nBy the end of this module, students will be well-equipped to design, develop, document, and maintain research software that meets high standards of quality, sustainability, and reproducibility.\nSeminar: RSEng Nuts and Bolts\nSWS: 2 ECTS: 3\n\n\n\n\n\n\nID\nDescription\nDisciplines\nPrerequisites\nEvidence\nAuthor\nSource\n\n\n\n\nrse_tooling_1\nUse literate programming tools (e.g., Quarto, Marimo, Pluto.jl, Jupyter) to combine code, results, and narrative\nResearch Software Engineering\n\nSubmit a literate notebook or document integrating code, visualizations, and explanatory text\nWorkshop Participants\nLink\n\n\nrse_tooling_2\nUse Python for visualization, scripting, templating, and integration tasks\nResearch Software Engineering\n\nSubmit a Python project demonstrating use of libraries for visualisation, web tasks, and templating\nWorkshop Participants\nLink\n\n\nrse_tooling_3\nWrite and use Bash scripts for automation\nResearch Software Engineering\n\nSubmit shell scripts automating file manipulation or computational workflows\nWorkshop Participants\nLink\n\n\nrse_tooling_4\nApply testing, debugging, and logging techniques to ensure software reliability\nResearch Software Engineering\nrse_tooling_2\nSubmit logs, test cases, and debugging documentation for a non-trivial Python or Bash project\nWorkshop Participants\nLink\n\n\nrse_tooling_5\nUse workflow management tools (e.g., CWL, Nextflow) to design scalable, reproducible pipelines\nResearch Software Engineering\nrse_tooling_3, rse_tooling_11\nSubmit a reproducible workflow including metadata and input/output definitions\nWorkshop Participants\nLink\n\n\nrse_tooling_6\nEstimate resource requirements for computational tasks using profiling and benchmarking\nResearch Software Engineering\nrse_tooling_2, rse_tooling_5\nProvide resource usage profiles and discuss optimization implications\nWorkshop Participants\nLink\n\n\nrse_tooling_7\nUse package managers and virtual environments (e.g., conda, nix) to manage software dependencies\nResearch Software Engineering\n\nSubmit environment definitions and reproducible setup instructions for a project\nWorkshop Participants\nLink\n\n\nrse_tooling_8\nDocument and package software for usability and reusability, using generators and modular design\nResearch Software Engineering\nrse_tooling_2\nSubmit user and developer documentation generated with Sphinx or similar, plus a reusable code module\nWorkshop Participants\nLink\n\n\nrse_tooling_9\nCommunicate technical RSE topics effectively with non-technical audiences\nResearch Software Engineering\n\nPrepare and deliver a presentation or write an article explaining RSE concepts to a general audience\nWorkshop Participants\nLink\n\n\nrse_tooling_10\nApply authentication and authorization mechanisms (e.g., LDAP, ACLs, Active Directory)\nResearch Software Engineering\n\nConfigure and demonstrate access control for a multi-user service or application\nWorkshop Participants\nLink\n\n\nrse_tooling_11\nMake informed decisions about tooling and infrastructure (e.g., Jupyter vs scripts, local vs HPC/cloud)\nResearch Software Engineering\nrse_tooling_1, rse_tooling_2, rse_tooling_3\nSubmit a comparative analysis justifying tooling and infrastructure choices for a research project\nWorkshop Participants\nLink\n\n\nrse_tooling_12\nTeach and practice collaborative development, including version control and code review\nResearch Software Engineering\nrse_tooling_2\nSubmit a project with version history and documented code reviews\nWorkshop Participants\nLink\n\n\nrse_tooling_13\nMentor others in research software engineering practices\nResearch Software Engineering\nrse_tooling_12\nDocument a mentoring session, workshop, or support activity\nWorkshop Participants\nLink\n\n\nrse_tooling_14\nDeploy and maintain web servers for research applications\nResearch Software Engineering\nrse_tooling_2\nDeploy a working web application with setup and maintenance documentation\nWorkshop Participants\nLink\n\n\nrse_tooling_15\nUnderstand and manage file systems, including local and network-attached storage\nResearch Software Engineering\n\nDocument storage strategies and access mechanisms in a real-world setup\nWorkshop Participants\nLink\n\n\n\n\n\n\n\n\n\nMIT Missing Semester\nCodeRefinery\nINTERSECT Training Materials\nDigital Research Academy Materials (Git, HPC, Reproducibility, Research Software)\nBuilding Better Research Software (SSI)\nDocker for neuroscience (jupyter book)\nFurther Git and GitHub\nBash Shell\nGit\nPython\nR\nIntroduction to version control\nCollaborative distributed version control\nJupyter notebooks\nPython for Researchers\nIntermediate General Python\nIntroduction to R\nIntroduction to Git and GitHub\n\n\n\nGoth, F, R Alves, M Braun, LJ Castro, G Chourdakis, S Christ, J Cohen, et al. 2024. “Foundational Competencies and Responsibilities of a Research Software Engineer [Version 1; Peer Review: Awaiting Peer Review].” F1000Research 13 (1429). https://doi.org/10.12688/f1000research.157778.1."
  },
  {
    "objectID": "generation/generated/rse_nuts_bolts.html#rseng-nuts-and-bolts",
    "href": "generation/generated/rse_nuts_bolts.html#rseng-nuts-and-bolts",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "",
    "text": "This module, inspired by the MIT Missing Semester, addresses the “nuts and bolts” often missing from traditional academic training in computing. It aims to provide students with practical skills and conceptual understanding for building robust, maintainable, and reproducible research software—key competencies in Research Software Engineering (RSEng).\n\n\n\nThe module begins with general-purpose computing tools and techniques that are foundational for any research software engineer:\n\nShell tools and scripting\nCommand-line environments\nEditors and IDEs (e.g., Vim)\nVersion control (Git)\nData wrangling\nDebugging and profiling\nMetaprogramming\nSecurity and cryptography\n\n\n\n\nBuilding on these foundations, the module introduces RSE-specific concepts and good practices:\n\nVersion control and collaboration\n\nGit for code history, collaboration, and issue tracking\n\nVirtualization concepts\n\nContainerization and environment management\n\nThe Data Life Cycle\n\nManaging research data and understanding data provenance\n\nGood coding practices\n\nReproducible and testable code\nMeaningful documentation and error messages\nModular software design\nPerformance-conscious coding\nEasily installable and distributable software\nCoding standards, formatting, and linting\n\nSoftware management planning\n\nWriting Data and Software Management Plans\nSustainable development and community involvement\n\nLow-level programming\n\nIntroduction to a compiled language (e.g., C) to expose hardware-level concerns and efficient memory management\n\nLong-term software maintenance\n\nVersion tracking, bug management, and sustainability strategies\nBuilding and maintaining research software communities\n\n\n\n\n\nFinally, the module touches on practices that support the scholarly nature of research software:\n\nSoftware publication and citation (see SP in (Goth et al. 2024))\nUse of domain-specific repositories and registries (see DOMREP in (Goth et al. 2024))\n\nBy the end of this module, students will be well-equipped to design, develop, document, and maintain research software that meets high standards of quality, sustainability, and reproducibility.\nSeminar: RSEng Nuts and Bolts\nSWS: 2 ECTS: 3\n\n\n\n\n\n\nID\nDescription\nDisciplines\nPrerequisites\nEvidence\nAuthor\nSource\n\n\n\n\nrse_tooling_1\nUse literate programming tools (e.g., Quarto, Marimo, Pluto.jl, Jupyter) to combine code, results, and narrative\nResearch Software Engineering\n\nSubmit a literate notebook or document integrating code, visualizations, and explanatory text\nWorkshop Participants\nLink\n\n\nrse_tooling_2\nUse Python for visualization, scripting, templating, and integration tasks\nResearch Software Engineering\n\nSubmit a Python project demonstrating use of libraries for visualisation, web tasks, and templating\nWorkshop Participants\nLink\n\n\nrse_tooling_3\nWrite and use Bash scripts for automation\nResearch Software Engineering\n\nSubmit shell scripts automating file manipulation or computational workflows\nWorkshop Participants\nLink\n\n\nrse_tooling_4\nApply testing, debugging, and logging techniques to ensure software reliability\nResearch Software Engineering\nrse_tooling_2\nSubmit logs, test cases, and debugging documentation for a non-trivial Python or Bash project\nWorkshop Participants\nLink\n\n\nrse_tooling_5\nUse workflow management tools (e.g., CWL, Nextflow) to design scalable, reproducible pipelines\nResearch Software Engineering\nrse_tooling_3, rse_tooling_11\nSubmit a reproducible workflow including metadata and input/output definitions\nWorkshop Participants\nLink\n\n\nrse_tooling_6\nEstimate resource requirements for computational tasks using profiling and benchmarking\nResearch Software Engineering\nrse_tooling_2, rse_tooling_5\nProvide resource usage profiles and discuss optimization implications\nWorkshop Participants\nLink\n\n\nrse_tooling_7\nUse package managers and virtual environments (e.g., conda, nix) to manage software dependencies\nResearch Software Engineering\n\nSubmit environment definitions and reproducible setup instructions for a project\nWorkshop Participants\nLink\n\n\nrse_tooling_8\nDocument and package software for usability and reusability, using generators and modular design\nResearch Software Engineering\nrse_tooling_2\nSubmit user and developer documentation generated with Sphinx or similar, plus a reusable code module\nWorkshop Participants\nLink\n\n\nrse_tooling_9\nCommunicate technical RSE topics effectively with non-technical audiences\nResearch Software Engineering\n\nPrepare and deliver a presentation or write an article explaining RSE concepts to a general audience\nWorkshop Participants\nLink\n\n\nrse_tooling_10\nApply authentication and authorization mechanisms (e.g., LDAP, ACLs, Active Directory)\nResearch Software Engineering\n\nConfigure and demonstrate access control for a multi-user service or application\nWorkshop Participants\nLink\n\n\nrse_tooling_11\nMake informed decisions about tooling and infrastructure (e.g., Jupyter vs scripts, local vs HPC/cloud)\nResearch Software Engineering\nrse_tooling_1, rse_tooling_2, rse_tooling_3\nSubmit a comparative analysis justifying tooling and infrastructure choices for a research project\nWorkshop Participants\nLink\n\n\nrse_tooling_12\nTeach and practice collaborative development, including version control and code review\nResearch Software Engineering\nrse_tooling_2\nSubmit a project with version history and documented code reviews\nWorkshop Participants\nLink\n\n\nrse_tooling_13\nMentor others in research software engineering practices\nResearch Software Engineering\nrse_tooling_12\nDocument a mentoring session, workshop, or support activity\nWorkshop Participants\nLink\n\n\nrse_tooling_14\nDeploy and maintain web servers for research applications\nResearch Software Engineering\nrse_tooling_2\nDeploy a working web application with setup and maintenance documentation\nWorkshop Participants\nLink\n\n\nrse_tooling_15\nUnderstand and manage file systems, including local and network-attached storage\nResearch Software Engineering\n\nDocument storage strategies and access mechanisms in a real-world setup\nWorkshop Participants\nLink\n\n\n\n\n\n\n\n\n\nMIT Missing Semester\nCodeRefinery\nINTERSECT Training Materials\nDigital Research Academy Materials (Git, HPC, Reproducibility, Research Software)\nBuilding Better Research Software (SSI)\nDocker for neuroscience (jupyter book)\nFurther Git and GitHub\nBash Shell\nGit\nPython\nR\nIntroduction to version control\nCollaborative distributed version control\nJupyter notebooks\nPython for Researchers\nIntermediate General Python\nIntroduction to R\nIntroduction to Git and GitHub\n\n\n\nGoth, F, R Alves, M Braun, LJ Castro, G Chourdakis, S Christ, J Cohen, et al. 2024. “Foundational Competencies and Responsibilities of a Research Software Engineer [Version 1; Peer Review: Awaiting Peer Review].” F1000Research 13 (1429). https://doi.org/10.12688/f1000research.157778.1."
  },
  {
    "objectID": "generation/generated/rse_scientificcomputing.html",
    "href": "generation/generated/rse_scientificcomputing.html",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "",
    "text": "RSEs with expertise in HPC and other performance-critical computing domains specialize in optimizing code for efficient execution across various platforms, including clusters, cloud, edge, and embedded systems. They understand parallel programming models, hardware-specific optimizations, profiling tools, and platform constraints such as memory, energy, and latency. Their skills enable them to adapt software to diverse infrastructures, manage complex dependencies, and support researchers in accessing and using advanced computing resources effectively and sustainably.\n\n\nThis module provides an entry‑level yet rigorous foundation in scientific computing for graduate students and researchers who need to design, implement, and evaluate computational experiments. Learners gain an awareness of the numerical underpinnings of modern simulation and data‑driven research, with an emphasis on writing reproducible, efficient, and trustworthy code.\n\n\n\nBy the end of the module participants will be able to\n\nBenchmark small programs and interpret performance metrics in a research context.\nExplain how approximation theory and floating‑point arithmetic affect numerical accuracy and stability.\nIdentify when to use established simulation libraries (e.g. BLAS/LAPACK, PETSc, Trilinos) instead of custom code.\nWrite simple GPU kernels and describe the core principles of accelerator programming.\nSubmit and monitor batch & array jobs on a mid‑size compute cluster.\nDescribe common HPC challenges—such as I/O bottlenecks, threading, and NUMA—and propose mitigation strategies.\nMaintain research software through continuous benchmarking.\n\nThe module qualifies for the more advanced module Scientific (High-Performance) Computing.\n\n\n\n\n\n\n\n\n\n\n\nWeek\nTheme\nTopics\n\n\n\n\n1\nBenchmarking & Profiling\nTiming strategies · micro vs. macro benchmarks · tooling overview\n\n\n2\nPrecision & Approximation\nIEEE‑754 recap · conditioning & stability · error propagation\n\n\n3\nScientific Libraries\nBLAS/LAPACK anatomy · hierarchical I/O libraries · overview of PETSc/Trilinos/Hypre\n\n\n4\nGPU Primer\nKernel model · memory hierarchy · CUDA/OpenCL/PyTorch lightning intro\n\n\n5\nWorking on a Cluster\nSlurm basics · job arrays · job dependencies · simple Bash launchers\n\n\n6\nHPC Pitfalls\nI/O throughput · thread oversubscription · NUMA awareness\n\n\n7\nSoftware Maintenance\nRegression + performance tests · continuous benchmarking pipelines\n\n\n\n\n\n\nShort lectures (30%) are coupled with hands‑on labs (70%). Students complete weekly notebooks and a mini‑project that reproduces and optimises a published computational result.\n\n\n\n\n\n\nComponent\nWeight\nDetails\n\n\n\n\nContinuous labs\n40%\nWeekly graded notebooks\n\n\nFinal mini‑project\n60%\nReport, code, and benchmark suite\n\n\n\n\n\n\n\nBasic programming in Python, C/C++, or Julia\nUndergraduate calculus & linear algebra\n\n\n\n\nChatGPT fantasy\nLecture: Scientific Computing\nSWS: 2 ECTS: 3\nExercise: Scientific Computing Exercise\nSWS: 2 ECTS: 3\n\n\n\n\n\n\nID\nDescription\nDisciplines\nPrerequisites\nEvidence\nAuthor\nSource\n\n\n\n\ncomp_module_1\nBenchmark and profile computational code to evaluate performance and bottlenecks\nScientific Computing\nrse_tooling_2\nSubmit benchmark reports comparing implementations and justifying trade-offs\nRSE Curriculum Draft\nLink\n\n\ncomp_module_2\nExplain and apply principles of approximation theory and numerical precision in scientific computing\nScientific Computing\n\nAnswer conceptual questions and implement small examples highlighting precision trade-offs\nRSE Curriculum Draft\nLink\n\n\ncomp_module_3\nExplain floating-point arithmetic and its implications for scientific accuracy and performance\nScientific Computing\ncomp_module_2\nProvide examples showing effects of precision loss and propose mitigations\nRSE Curriculum Draft\nLink\n\n\ncomp_module_4\nDescribe common simulation libraries and numerical frameworks (e.g., BLAS, LAPACK, PETSc, Trilinos)\nScientific Computing\n\nList relevant libraries for a task and justify choice or avoidance of custom implementations\nRSE Curriculum Draft\nLink\n\n\ncomp_module_5\nCompare interpreted and compiled languages in terms of performance and suitability for computing tasks\nScientific Computing\n\nWrite code samples in both types of language and explain their performance characteristics\nRSE Curriculum Draft\nLink\n\n\n\n\n\n\n\n\n\nEUMaster4HPC\n\n\n\n\n\nNumerical Computing in Python\nScientific Computing\n\n\n\n\n\nWhat every computer scientist should know about floating-point arithmetic\n\n\n\n\n\nScientific Computing"
  },
  {
    "objectID": "generation/generated/rse_scientificcomputing.html#scientific-computing-for-rse",
    "href": "generation/generated/rse_scientificcomputing.html#scientific-computing-for-rse",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "",
    "text": "RSEs with expertise in HPC and other performance-critical computing domains specialize in optimizing code for efficient execution across various platforms, including clusters, cloud, edge, and embedded systems. They understand parallel programming models, hardware-specific optimizations, profiling tools, and platform constraints such as memory, energy, and latency. Their skills enable them to adapt software to diverse infrastructures, manage complex dependencies, and support researchers in accessing and using advanced computing resources effectively and sustainably.\n\n\nThis module provides an entry‑level yet rigorous foundation in scientific computing for graduate students and researchers who need to design, implement, and evaluate computational experiments. Learners gain an awareness of the numerical underpinnings of modern simulation and data‑driven research, with an emphasis on writing reproducible, efficient, and trustworthy code.\n\n\n\nBy the end of the module participants will be able to\n\nBenchmark small programs and interpret performance metrics in a research context.\nExplain how approximation theory and floating‑point arithmetic affect numerical accuracy and stability.\nIdentify when to use established simulation libraries (e.g. BLAS/LAPACK, PETSc, Trilinos) instead of custom code.\nWrite simple GPU kernels and describe the core principles of accelerator programming.\nSubmit and monitor batch & array jobs on a mid‑size compute cluster.\nDescribe common HPC challenges—such as I/O bottlenecks, threading, and NUMA—and propose mitigation strategies.\nMaintain research software through continuous benchmarking.\n\nThe module qualifies for the more advanced module Scientific (High-Performance) Computing.\n\n\n\n\n\n\n\n\n\n\n\nWeek\nTheme\nTopics\n\n\n\n\n1\nBenchmarking & Profiling\nTiming strategies · micro vs. macro benchmarks · tooling overview\n\n\n2\nPrecision & Approximation\nIEEE‑754 recap · conditioning & stability · error propagation\n\n\n3\nScientific Libraries\nBLAS/LAPACK anatomy · hierarchical I/O libraries · overview of PETSc/Trilinos/Hypre\n\n\n4\nGPU Primer\nKernel model · memory hierarchy · CUDA/OpenCL/PyTorch lightning intro\n\n\n5\nWorking on a Cluster\nSlurm basics · job arrays · job dependencies · simple Bash launchers\n\n\n6\nHPC Pitfalls\nI/O throughput · thread oversubscription · NUMA awareness\n\n\n7\nSoftware Maintenance\nRegression + performance tests · continuous benchmarking pipelines\n\n\n\n\n\n\nShort lectures (30%) are coupled with hands‑on labs (70%). Students complete weekly notebooks and a mini‑project that reproduces and optimises a published computational result.\n\n\n\n\n\n\nComponent\nWeight\nDetails\n\n\n\n\nContinuous labs\n40%\nWeekly graded notebooks\n\n\nFinal mini‑project\n60%\nReport, code, and benchmark suite\n\n\n\n\n\n\n\nBasic programming in Python, C/C++, or Julia\nUndergraduate calculus & linear algebra\n\n\n\n\nChatGPT fantasy\nLecture: Scientific Computing\nSWS: 2 ECTS: 3\nExercise: Scientific Computing Exercise\nSWS: 2 ECTS: 3\n\n\n\n\n\n\nID\nDescription\nDisciplines\nPrerequisites\nEvidence\nAuthor\nSource\n\n\n\n\ncomp_module_1\nBenchmark and profile computational code to evaluate performance and bottlenecks\nScientific Computing\nrse_tooling_2\nSubmit benchmark reports comparing implementations and justifying trade-offs\nRSE Curriculum Draft\nLink\n\n\ncomp_module_2\nExplain and apply principles of approximation theory and numerical precision in scientific computing\nScientific Computing\n\nAnswer conceptual questions and implement small examples highlighting precision trade-offs\nRSE Curriculum Draft\nLink\n\n\ncomp_module_3\nExplain floating-point arithmetic and its implications for scientific accuracy and performance\nScientific Computing\ncomp_module_2\nProvide examples showing effects of precision loss and propose mitigations\nRSE Curriculum Draft\nLink\n\n\ncomp_module_4\nDescribe common simulation libraries and numerical frameworks (e.g., BLAS, LAPACK, PETSc, Trilinos)\nScientific Computing\n\nList relevant libraries for a task and justify choice or avoidance of custom implementations\nRSE Curriculum Draft\nLink\n\n\ncomp_module_5\nCompare interpreted and compiled languages in terms of performance and suitability for computing tasks\nScientific Computing\n\nWrite code samples in both types of language and explain their performance characteristics\nRSE Curriculum Draft\nLink\n\n\n\n\n\n\n\n\n\nEUMaster4HPC\n\n\n\n\n\nNumerical Computing in Python\nScientific Computing\n\n\n\n\n\nWhat every computer scientist should know about floating-point arithmetic\n\n\n\n\n\nScientific Computing"
  },
  {
    "objectID": "generation/generated/rse_softwareengineering.html",
    "href": "generation/generated/rse_softwareengineering.html",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "",
    "text": "This module extends the Classical Software Engineering Module with research specific learnings. This includes but is not limited to\n\nsoftware re-use (see SRU in (Goth et al. 2024))\ncreating documented code building blocks (see DOCBB in (Goth et al. 2024))\nbuilding distributable software (see DIST in (Goth et al. 2024))\nresearch specific programming languages\nresearch specific code requirements (scalability, functional programming, …)\nAdapting the software life cycle to research (see SWLC in (Goth et al. 2024))\nSoftware behaviour awareness and analysis (see MOD in (Goth et al. 2024))\nResearch specific Engineering Patterns\n\nAlso, the seminar provides room for reflection and discussions of SE lab experiences.\nSeminar: Software Engineering for RSEs\nSWS: 2 ECTS: 3\nExercise: Software Engineering Exercise for RSEs\nSWS: 2 ECTS: 3\n\n\n\n\n\nID\nDescription\nDisciplines\nPrerequisites\nEvidence\nAuthor\nSource\n\n\n\n\nrse_practices_1\nApply good coding practices including formatting, linting, and modular design\nResearch Software Engineering\nrse_tooling_2\nSubmit a code project demonstrating modularity, consistent formatting, and use of linters\nRSE Curriculum Draft\nLink\n\n\nrse_practices_2\nWrite code and documentation that supports reproducibility in research\nResearch Software Engineering\nrse_tooling_1, rse_tooling_4\nSubmit a project with data, software, and instructions allowing full reproduction of results\nRSE Curriculum Draft\nLink\n\n\nrse_practices_3\nOrganise files and name code artifacts using clear, consistent conventions\nResearch Software Engineering\n\nSubmit a software repository with a structured layout and consistent naming scheme\nRSE Curriculum Draft\nLink\n\n\nrse_practices_4\nVersion control code and collaborate using platforms like GitHub or GitLab\nResearch Software Engineering\nrse_tooling_12\nParticipate in a collaborative coding project using Git-based workflows and merge requests\nRSE Curriculum Draft\nLink\n\n\nrse_practices_5\nWrite effective documentation and user-facing error messages\nResearch Software Engineering\nrse_tooling_8\nProvide documentation and example error handling demonstrating clarity and user support\nRSE Curriculum Draft\nLink\n\n\nrse_practices_12\nWrite performant code suitable for use in compute-intensive contexts\nResearch Software Engineering\nrse_tooling_2\nSubmit benchmark results comparing an optimized version of code with a naive implementation\nRSE Curriculum Draft\nLink\n\n\nrse_practices_13\nPublish code and software in trusted repositories and package managers\nResearch Software Engineering\nrse_practices_6\nPublish software to a repository (e.g., GitHub, PyPI, CRAN) and register it with a long-term archive (e.g., Zenodo)\nRSE Curriculum Draft\nLink\n\n\nrse_practices_6\nApply licensing and publishing strategies to make software reusable and citable\nResearch Software Engineering\n\nSubmit a software project with an appropriate open license and published DOI (e.g., via Zenodo)\nRSE Curriculum Draft\nLink\n\n\nrse_practices_7\nApply principles of Open Source and FAIR (Findable, Accessible, Interoperable, Reusable) software\nResearch Software Engineering\nrse_practices_6\nReview or create a software project and evaluate its compliance with FAIR/Open Source principles\nRSE Curriculum Draft\nLink\n\n\nrse_practices_14\nManage data within a software project in accordance with best practices\nResearch Software Engineering, Data Management\n\nSubmit a data-driven project showing clear data organisation, metadata, and reproducibility\nRSE Curriculum Draft\nLink\n\n\n\n\n\n\n\n\n\nResearch Software Engineering\nAutomated testing\nDocumenting your research software\nIntroduction to Research Software Engineering\nResearch Software Engineering\n\n\n\n\n\nUP Computational Science Master\n\n\n\nGoth, F, R Alves, M Braun, LJ Castro, G Chourdakis, S Christ, J Cohen, et al. 2024. “Foundational Competencies and Responsibilities of a Research Software Engineer [Version 1; Peer Review: Awaiting Peer Review].” F1000Research 13 (1429). https://doi.org/10.12688/f1000research.157778.1."
  },
  {
    "objectID": "generation/generated/rse_softwareengineering.html#software-engineering-for-rses",
    "href": "generation/generated/rse_softwareengineering.html#software-engineering-for-rses",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "",
    "text": "This module extends the Classical Software Engineering Module with research specific learnings. This includes but is not limited to\n\nsoftware re-use (see SRU in (Goth et al. 2024))\ncreating documented code building blocks (see DOCBB in (Goth et al. 2024))\nbuilding distributable software (see DIST in (Goth et al. 2024))\nresearch specific programming languages\nresearch specific code requirements (scalability, functional programming, …)\nAdapting the software life cycle to research (see SWLC in (Goth et al. 2024))\nSoftware behaviour awareness and analysis (see MOD in (Goth et al. 2024))\nResearch specific Engineering Patterns\n\nAlso, the seminar provides room for reflection and discussions of SE lab experiences.\nSeminar: Software Engineering for RSEs\nSWS: 2 ECTS: 3\nExercise: Software Engineering Exercise for RSEs\nSWS: 2 ECTS: 3\n\n\n\n\n\nID\nDescription\nDisciplines\nPrerequisites\nEvidence\nAuthor\nSource\n\n\n\n\nrse_practices_1\nApply good coding practices including formatting, linting, and modular design\nResearch Software Engineering\nrse_tooling_2\nSubmit a code project demonstrating modularity, consistent formatting, and use of linters\nRSE Curriculum Draft\nLink\n\n\nrse_practices_2\nWrite code and documentation that supports reproducibility in research\nResearch Software Engineering\nrse_tooling_1, rse_tooling_4\nSubmit a project with data, software, and instructions allowing full reproduction of results\nRSE Curriculum Draft\nLink\n\n\nrse_practices_3\nOrganise files and name code artifacts using clear, consistent conventions\nResearch Software Engineering\n\nSubmit a software repository with a structured layout and consistent naming scheme\nRSE Curriculum Draft\nLink\n\n\nrse_practices_4\nVersion control code and collaborate using platforms like GitHub or GitLab\nResearch Software Engineering\nrse_tooling_12\nParticipate in a collaborative coding project using Git-based workflows and merge requests\nRSE Curriculum Draft\nLink\n\n\nrse_practices_5\nWrite effective documentation and user-facing error messages\nResearch Software Engineering\nrse_tooling_8\nProvide documentation and example error handling demonstrating clarity and user support\nRSE Curriculum Draft\nLink\n\n\nrse_practices_12\nWrite performant code suitable for use in compute-intensive contexts\nResearch Software Engineering\nrse_tooling_2\nSubmit benchmark results comparing an optimized version of code with a naive implementation\nRSE Curriculum Draft\nLink\n\n\nrse_practices_13\nPublish code and software in trusted repositories and package managers\nResearch Software Engineering\nrse_practices_6\nPublish software to a repository (e.g., GitHub, PyPI, CRAN) and register it with a long-term archive (e.g., Zenodo)\nRSE Curriculum Draft\nLink\n\n\nrse_practices_6\nApply licensing and publishing strategies to make software reusable and citable\nResearch Software Engineering\n\nSubmit a software project with an appropriate open license and published DOI (e.g., via Zenodo)\nRSE Curriculum Draft\nLink\n\n\nrse_practices_7\nApply principles of Open Source and FAIR (Findable, Accessible, Interoperable, Reusable) software\nResearch Software Engineering\nrse_practices_6\nReview or create a software project and evaluate its compliance with FAIR/Open Source principles\nRSE Curriculum Draft\nLink\n\n\nrse_practices_14\nManage data within a software project in accordance with best practices\nResearch Software Engineering, Data Management\n\nSubmit a data-driven project showing clear data organisation, metadata, and reproducibility\nRSE Curriculum Draft\nLink\n\n\n\n\n\n\n\n\n\nResearch Software Engineering\nAutomated testing\nDocumenting your research software\nIntroduction to Research Software Engineering\nResearch Software Engineering\n\n\n\n\n\nUP Computational Science Master\n\n\n\nGoth, F, R Alves, M Braun, LJ Castro, G Chourdakis, S Christ, J Cohen, et al. 2024. “Foundational Competencies and Responsibilities of a Research Software Engineer [Version 1; Peer Review: Awaiting Peer Review].” F1000Research 13 (1429). https://doi.org/10.12688/f1000research.157778.1."
  },
  {
    "objectID": "generation/generated/rse_thesis.html",
    "href": "generation/generated/rse_thesis.html",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "",
    "text": "The master’s thesis is the culminating component of the RSE programme. In this module, students apply the full spectrum of Research Software Engineering skills in a real-world research setting, demonstrating their ability to independently design, implement, and document a computational research contribution.\nThe thesis must address a research question in collaboration with a scientific or applied domain, but its core should include a substantial computational component. This may involve software development, data-intensive research, reproducibility infrastructure, or performance engineering — depending on the chosen topic and specialization.\nEach thesis must be supervised jointly by:\n\nA domain expert (e.g., in physics, life sciences, or humanities)\nAn RSE mentor (who ensures the quality and relevance of the computational contribution)\n\nStudents are expected to follow best practices in software engineering, version control, testing, and documentation. The final submission must include:\n\nA written thesis describing both the scientific and software contributions\nA structured, reproducible code repository\nA presentation and defense in a thesis colloquium\n\nThe colloquium serves as both a public communication exercise and a final evaluation, where students present their project and reflect on challenges and insights gained during the thesis.\nThesis: RSEng Master Thesis\nSWS: 0 ECTS: 30"
  },
  {
    "objectID": "generation/generated/rse_thesis.html#masters-thesis-module-research-software-engineering-thesis",
    "href": "generation/generated/rse_thesis.html#masters-thesis-module-research-software-engineering-thesis",
    "title": "RSE Curriculum (WORK IN PROGRESS)",
    "section": "",
    "text": "The master’s thesis is the culminating component of the RSE programme. In this module, students apply the full spectrum of Research Software Engineering skills in a real-world research setting, demonstrating their ability to independently design, implement, and document a computational research contribution.\nThe thesis must address a research question in collaboration with a scientific or applied domain, but its core should include a substantial computational component. This may involve software development, data-intensive research, reproducibility infrastructure, or performance engineering — depending on the chosen topic and specialization.\nEach thesis must be supervised jointly by:\n\nA domain expert (e.g., in physics, life sciences, or humanities)\nAn RSE mentor (who ensures the quality and relevance of the computational contribution)\n\nStudents are expected to follow best practices in software engineering, version control, testing, and documentation. The final submission must include:\n\nA written thesis describing both the scientific and software contributions\nA structured, reproducible code repository\nA presentation and defense in a thesis colloquium\n\nThe colloquium serves as both a public communication exercise and a final evaluation, where students present their project and reflect on challenges and insights gained during the thesis.\nThesis: RSEng Master Thesis\nSWS: 0 ECTS: 30"
  },
  {
    "objectID": "index.html#research-skills",
    "href": "index.html#research-skills",
    "title": "WORK IN PROGRESS THIS IS NOT THE OFFICIAL STATEMENT OF THE COMMUNITY BUT THE CURRENT VERSION",
    "section": "Research skills",
    "text": "Research skills\nImplemented in the following components:\n\nDomain Science Project\nDomain Science Wildcard Courses\nRSE Thesis"
  },
  {
    "objectID": "index.html#technical-skills",
    "href": "index.html#technical-skills",
    "title": "WORK IN PROGRESS THIS IS NOT THE OFFICIAL STATEMENT OF THE COMMUNITY BUT THE CURRENT VERSION",
    "section": "Technical skills",
    "text": "Technical skills\nImplemented in:\n\nRSE Nuts and Bolts\nData Science Foundations\nProgramming Foundations\nSoftware Engineering Foundations\nRSE Software Engineering\nScientific Computing Basics and High Performance Computing"
  },
  {
    "objectID": "index.html#communication-skills",
    "href": "index.html#communication-skills",
    "title": "WORK IN PROGRESS THIS IS NOT THE OFFICIAL STATEMENT OF THE COMMUNITY BUT THE CURRENT VERSION",
    "section": "Communication skills",
    "text": "Communication skills\nImplemented in:\n\nRSE Management\nDomain Science Project or RSE Lab Project\nRSE, Ethics & Society\nRSE Lecture Series"
  }
]