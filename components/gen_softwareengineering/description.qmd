## (Classical) Software Engineering

_To summarise the vast range of the skills a software engineer is typically equipped with, we refer to the Guide to the Software Engineering Body of Knowledge [@swebok_2014]. Because research software engineering is an interface discipline, RSEs are often stronger in topics more commonly encountered in research software contexts (e.g., mathematical and engineering foundations) than in other areas (e.g., software engineering economics). However, they bring a solid level of competence in all software engineering topics. Therefore, RSEs can set and analyse software requirements in the context of open-ended, question-driven research. They can design software so that it can sustainably grow, often in an environment of rapid turnover of contributors. They are competent in implementing solutions themselves in a wide range of technologies fit for different scientific applications. They can formulate and implement various types of tests, they can independently maintain software and automate operations of the integration and release process. They can provide working, scalable, and future-proof solutions in a professional context and with common project and software management techniques, adapted to the needs of the research environment. Finally, as people who have often gained significant research experience in a particular discipline, they combine the necessary foundations from their domain with software engineering skills to develop complex software._[@competencies-F1000]

This module tries to lay the foundations for the advanced RSE software engineering training.

::: {#refs}
:::

### Contents
* Basic concepts of software engineering, 
* software and product life cycle, 
* process models for the design of large software systems,
* semantic aspects of domain description, hierarchy, parallelism, real-time and embedded systems as fundamental paradigms,
* organizational principles of complex software systems, design by contract, 
* patterns in modeling and design methods of quality assurance, evolution and re-engineering, 
* selected languages and tools for process- and object-oriented modeling,
* methods and languages for object-oriented design, architectures and architectural patterns of software systems,
* architecture of enterprise applications, 
* design and implementation models in the object-oriented paradigm, e.g., Java 2 SE, design patterns, software testing methods
* a selection of advanced topics such as software quality assurance, service engineering, virtualization, and formal methods in system design
